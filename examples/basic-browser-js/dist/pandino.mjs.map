{"version":3,"file":"pandino.mjs","sources":["../../../pandino-api/dist/esm/pandino-api.mjs","../../src/lib/utils/helpers.ts","../../src/lib/framework/wiring/bundle-capability-impl.ts","../../src/lib/framework/util/manifest-parser/parsed-header-clause.ts","../../src/lib/filter/parse.ts","../../src/lib/filter/workarounds.ts","../../src/lib/filter/filter.ts","../../src/lib/semver-lite/src/semver.ts","../../src/lib/semver-lite/src/index.ts","../../src/lib/utils/semver-impl.ts","../../src/lib/framework/capability-set/capability-set.ts","../../src/lib/framework/wiring/bundle-requirement-impl.ts","../../src/lib/framework/util/manifest-parser/manifest-parser-impl.ts","../../src/lib/framework/bundle-revision-impl.ts","../../src/lib/framework/bundle-impl.ts","../../src/lib/framework/util/listener-info.ts","../../src/lib/framework/service-event-impl.ts","../../src/lib/framework/event-dispatcher.ts","../../src/lib/framework/service-objects-impl.ts","../../src/lib/framework/abstract-tracked.ts","../../src/lib/framework/bundle-tracker-impl.ts","../../src/lib/framework/service-tracker-impl.ts","../../src/lib/framework/bundle-context-impl.ts","../../src/lib/framework/bundle-event-impl.ts","../../src/lib/framework/wiring/bundle-wire-impl.ts","../../src/lib/framework/bundle-wiring-impl.ts","../../src/lib/framework/stateful-resolver.ts","../../src/lib/framework/service-reference-impl.ts","../../src/lib/framework/service-registration-impl.ts","../../src/lib/framework/usage-count-impl.ts","../../src/lib/framework/service-registry-impl.ts","../../src/lib/framework/framework-event-impl.ts","../../src/lib/utils/console-logger.ts","../../src/lib/utils/void-fetcher.ts","../../src/lib/utils/void-importer.ts","../../src/lib/filter/filter-parser.ts","../../src/lib/utils/semver-factory.ts","../../src/pandino.ts"],"sourcesContent":["/**\n * PANDINO\n */\nconst DEPLOYMENT_ROOT_PROP = 'pandino.deployment.root';\nconst LOG_LEVEL_PROP = 'pandino.log.level';\nconst LOG_LOGGER_PROP = 'pandino.log.logger';\nconst PANDINO_BUNDLE_IMPORTER_PROP = 'pandino.bundle.importer';\nconst PANDINO_MANIFEST_FETCHER_PROP = 'pandino.manifest.fetcher';\nconst BUNDLE_NAMESPACE = 'pandino.wiring.bundle';\nconst IDENTITY_NAMESPACE = 'pandino.identity';\nconst TYPE_BUNDLE = 'pandino.bundle';\nconst TYPE_FRAGMENT = 'pandino.fragment';\nconst SYSTEMBUNDLE_ACTIVATORS_PROP = 'pandino.systembundle.activators';\nconst PANDINO_VERSION_PROPERTY = 'pandino.version';\nconst PACKAGE_NAMESPACE = 'pandino.wiring.package';\nconst HOST_NAMESPACE = 'pandino.wiring.host';\n/**\n * Location identifier of the Pandino <i>system bundle </i>, which is defined to be &quot;System Bundle&quot;.\n */\nconst SYSTEM_BUNDLE_LOCATION = 'System Bundle';\n/**\n * Manifest header identifying the bundle's name.\n */\nconst BUNDLE_NAME = 'Bundle-Name';\n/**\n * Manifest header containing a brief description of the bundle's functionality.\n */\nconst BUNDLE_DESCRIPTION = 'Bundle-Description';\n/**\n * Manifest header identifying the bundle's vendor.\n */\nconst BUNDLE_VENDOR = 'Bundle-Vendor';\n/**\n * Manifest header identifying the bundle's version.\n *\n * (Required attribute)\n */\nconst BUNDLE_VERSION = 'Bundle-Version';\n/**\n * If the corresponding value is a path string, then the value <b>MUST</b> be a relative path calculated from the\n * {@link DEPLOYMENT_ROOT_PROP}'s value!\n *\n * (Required attribute)\n */\nconst BUNDLE_ACTIVATOR = 'Bundle-Activator';\n/**\n * Manifest header identifying the bundle's activation policy.\n *\n * (Not yet implemented)\n */\nconst BUNDLE_ACTIVATIONPOLICY = 'Bundle-ActivationPolicy';\n/**\n * Manifest header identifying the bundle's symbolic name.\n *\n * (Required attribute)\n */\nconst BUNDLE_SYMBOLICNAME = 'Bundle-SymbolicName';\n/**\n * Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in\n * which it is written by specifying a bundle manifest version.\n *\n * (Required attribute)\n */\nconst BUNDLE_MANIFESTVERSION = 'Bundle-ManifestVersion';\n/**\n * Manifest header identifying the bundle's copyright information.\n */\nconst BUNDLE_COPYRIGHT = 'Bundle-Copyright';\n/**\n * Manifest header identifying the symbolic names of other bundles required by the bundle.\n *\n * (Not yet implemented)\n */\nconst REQUIRE_BUNDLE = 'Require-Bundle';\n/**\n * Manifest header identifying the capabilities that the bundle offers to provide to other bundles.\n */\nconst PROVIDE_CAPABILITY = 'Provide-Capability';\n/**\n * Manifest header identifying the capabilities on which the bundle depends.\n */\nconst REQUIRE_CAPABILITY = 'Require-Capability';\n/**\n * Manifest header identifying the path to a LICENSE file (if any).\n */\nconst BUNDLE_LICENSE = 'Bundle-License';\n/**\n * Manifest header directive value identifying an optional resolution type. An optional resolution type indicates that\n * the import, require bundle or require capability is optional and the bundle may be resolved without the import,\n * require bundle or require capability being resolved. If the import, require bundle or require capability is not\n * resolved when the bundle is resolved, the import, require bundle or require capability may not be resolved until the\n * bundle is refreshed.\n *\n * (Not yet implemented)\n */\nconst RESOLUTION_OPTIONAL = 'optional';\nconst SYSTEM_BUNDLE_SYMBOLICNAME = '@pandino/pandino';\n/**\n * Bundle activation policy declaring the bundle must be activated when the first class load is made from the bundle.\n *\n * <p>\n * A bundle with the lazy activation policy that is started with the \"START_ACTIVATION_POLICY\" option will wait in the\n * \"STARTING\" state until the first class load from the bundle occurs. The bundle will then be activated before the\n * class is returned to the requester.\n *\n * (Not yet implemented)\n */\nconst ACTIVATION_LAZY = 'lazy';\n/**\n * Manifest header identifying the symbolic name of another bundle for which that the bundle is a fragment.\n *\n * (Not yet implemented)\n */\nconst FRAGMENT_HOST = 'Fragment-Host';\nconst FRAMEWORK_LOGGER = '@pandino/pandino/Logger';\nconst FRAMEWORK_MANIFEST_FETCHER = '@pandino/pandino/ManifestFetcher';\nconst FRAMEWORK_BUNDLE_IMPORTER = '@pandino/pandino/BundleImporter';\nconst FRAMEWORK_FILTER_PARSER = '@pandino/pandino/FilterParser';\nconst FRAMEWORK_SEMVER_FACTORY = '@pandino/pandino/SemVerFactory';\nconst FRAMEWORK_UUID = '@pandino/pandino/uuid';\nconst FRAMEWORK_VERSION = '@pandino/pandino/version';\nconst FRAMEWORK_VENDOR = '@pandino/pandino/vendor';\nconst SERVICE_DEFAULT_RANK = 0;\nconst SERVICE_EVENT_INTERFACE_KEY = '@pandino/pandino/service/ServiceEvent';\nconst SERVICE_LISTENER_INTERFACE_KEY = '@pandino/pandino/service/ServiceListener';\n/**\n * Service property identifying a service's registration number. The value of this property must be of type\n * {@code number}.\n *\n * <p>\n * The value of this property is assigned by the Framework when a service is registered. The Framework assigns a unique,\n * non-negative value that is larger than all previously assigned values since the Framework was started. These values\n * are NOT persistent across restarts of the Framework.\n */\nconst SERVICE_ID = 'service.id';\n/**\n * Service property identifying a service's ranking number.\n *\n * <p>\n * This property may be supplied in the {@code properties Record} object passed to the\n * {@code BundleContext.registerService} method. The value of this property must be of type {@code number}.\n *\n * <p>\n * The service ranking is used by the Framework to determine the <i>natural order</i> of services, see\n * {@link ServiceReference#compareTo(Object)}, and the <i>default</i> service to be returned from a call to the\n * {@link BundleContext#getServiceReference(Class)} or\n * {@link BundleContext#getServiceReference(String)} method.\n *\n * <p>\n * The default ranking is zero (0). A service with a ranking of {@code Number.MAX_VALUE} is very likely to be returned\n * as the default service, whereas a service with a ranking of {@code Number.MIN_VALUE} is very unlikely to be\n * returned.\n */\nconst SERVICE_RANKING = 'service.ranking';\n/**\n * Service property identifying the {@link Bundle#getBundleId() bundle id} of the {@link ServiceReference#getBundle()\n * bundle registering the service}.\n *\n * <p>\n * This property is set by the Framework when a service is registered. The value of this property must be of type\n * {@code number}.\n */\nconst SERVICE_BUNDLEID = 'service.bundleid';\n/**\n * Service property identifying a service's description.\n */\nconst SERVICE_DESCRIPTION = 'service.description';\n/**\n * Service property identifying a service's scope.\n *\n * <p>\n * This property is set by the Framework when a service is registered. If the registered object implements\n * {@link PrototypeServiceFactory}, then the value of this service property will be {@link #SCOPE_PROTOTYPE}. Otherwise,\n * if the registered object implements {@link ServiceFactory}, then the value of this service property will be\n * {@link #SCOPE_BUNDLE}. Otherwise, the value of this service property will be {@link #SCOPE_SINGLETON}.\n */\nconst SERVICE_SCOPE = 'service.scope';\nconst SERVICE_PID = 'service.pid';\n/**\n * Service scope is singleton. All bundles using the service receive the same service object.\n */\nconst SCOPE_SINGLETON = 'singleton';\n/**\n * Service scope is bundle. Each bundle using the service receives a customized service object.\n */\nconst SCOPE_BUNDLE = 'bundle';\n/**\n * Service scope is prototype. Each bundle using the service receives either a customized service object or can request\n * multiple customized service objects.\n */\nconst SCOPE_PROTOTYPE = 'prototype';\n/**\n * Service property identifying all of the class names under which a service was registered in the Framework. The value\n * of this property must be of type {@code string | string[]}.\n *\n * <p>\n * This property is set by the Framework when a service is registered.\n */\nconst OBJECTCLASS = 'objectClass';\n/**\n * Manifest header attribute identifying a range of versions for a bundle specified in the {@code Require-Bundle} or\n * {@code Fragment-Host} manifest headers. The default value is {@code 0.0.0}.\n */\nconst BUNDLE_VERSION_ATTRIBUTE = 'bundle-version';\n/**\n * Manifest header attribute identifying the version of a package specified in the Export-Package or Import-Package\n * manifest header.\n */\nconst VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute identifying the {@code SemVer} of the resource if one is specified or {@code 0.0.0} if not\n * specified. The value of this attribute must be of type {@code SemVer}.\n */\nconst CAPABILITY_VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute that contains a human readable copyright notice for the resource. See the\n * {@code Bundle-Copyright} manifest header.\n */\nconst CAPABILITY_COPYRIGHT_ATTRIBUTE = 'copyright';\n/**\n * The attribute value that contains tags for the resource. A tag is used to identify an aspect of the resource that is\n * not otherwise expressed by the capabilities of the resource. The value of this attribute must be of type\n * {@code Array<string>}.\n */\nconst CAPABILITY_TAGS_ATTRIBUTE = 'tags';\n/**\n * The capability attribute identifying the resource type. If the resource has no type then the value\n * {@link #TYPE_UNKNOWN unknown} must be used for the attribute.\n */\nconst CAPABILITY_TYPE_ATTRIBUTE = 'type';\n/**\n * The capability attribute that contains a human readable description for the resource. See the\n * {@code Bundle-Description} manifest header.\n */\nconst CAPABILITY_DESCRIPTION_ATTRIBUTE = 'description';\n/**\n * Manifest header directive identifying a list of packages that an exported package or provided capability uses.\n */\nconst USES_DIRECTIVE = 'uses';\n/**\n * Manifest header directive identifying names of matching attributes which must be specified by matching Import-Package\n * statements in the Export-Package manifest header.\n */\nconst MANDATORY_DIRECTIVE = 'mandatory';\n/**\n * Manifest header directive identifying the capability filter specified in the Require-Capability manifest header.\n */\nconst FILTER_DIRECTIVE = 'filter';\n/**\n * Manifest header directive identifying a list of classes to include in the exported package.\n *\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must be allowed to be exported.\n */\nconst INCLUDE_DIRECTIVE = 'include';\n/**\n * Manifest header directive identifying a list of classes to exclude in the exported package..\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must not be allowed to be exported.\n */\nconst EXCLUDE_DIRECTIVE = 'exclude';\n/**\n * Manifest header directive identifying the resolution type in the Import-Package, Require-Bundle or Require-Capability\n * manifest header. The default value is {@link #RESOLUTION_MANDATORY mandatory}.\n */\nconst RESOLUTION_DIRECTIVE = 'resolution';\n/**\n * Manifest header directive identifying whether a bundle is a singleton. The default value is {@code false}.\n */\nconst SINGLETON_DIRECTIVE = 'singleton';\n/**\n * The capability directive identifying if the resource is a singleton. A {@code string} value of &quot;true&quot;\n * indicates the resource is a singleton; any other value or {@code undefined} indicates the resource is not a\n * singleton.\n */\nconst CAPABILITY_SINGLETON_DIRECTIVE = 'singleton';\n/**\n * Manifest header directive identifying the effective time of the provided capability. The default value is\n * {@link #EFFECTIVE_RESOLVE resolve}.\n */\nconst EFFECTIVE_DIRECTIVE = 'effective';\n/**\n * Manifest header directive value identifying a capability that is effective at resolve time. Capabilities with an\n * effective time of resolve are the only capabilities which are processed by the resolver.\n */\nconst EFFECTIVE_RESOLVE = 'resolve';\n/**\n * The requirement directive used to specify a capability filter. This filter is used to match against a capability's\n * attributes.\n */\nconst REQUIREMENT_FILTER_DIRECTIVE = 'filter';\n/**\n * The requirement directive used to specify the cardinality for a requirement. The default value is {@link #CARDINALITY_SINGLE single}.\n */\nconst REQUIREMENT_CARDINALITY_DIRECTIVE = 'cardinality';\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"TRACE\"] = 5] = \"TRACE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    LogLevel[LogLevel[\"LOG\"] = 3] = \"LOG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\n\nexport { ACTIVATION_LAZY, BUNDLE_ACTIVATIONPOLICY, BUNDLE_ACTIVATOR, BUNDLE_COPYRIGHT, BUNDLE_DESCRIPTION, BUNDLE_LICENSE, BUNDLE_MANIFESTVERSION, BUNDLE_NAME, BUNDLE_NAMESPACE, BUNDLE_SYMBOLICNAME, BUNDLE_VENDOR, BUNDLE_VERSION, BUNDLE_VERSION_ATTRIBUTE, CAPABILITY_COPYRIGHT_ATTRIBUTE, CAPABILITY_DESCRIPTION_ATTRIBUTE, CAPABILITY_SINGLETON_DIRECTIVE, CAPABILITY_TAGS_ATTRIBUTE, CAPABILITY_TYPE_ATTRIBUTE, CAPABILITY_VERSION_ATTRIBUTE, DEPLOYMENT_ROOT_PROP, EFFECTIVE_DIRECTIVE, EFFECTIVE_RESOLVE, EXCLUDE_DIRECTIVE, FILTER_DIRECTIVE, FRAGMENT_HOST, FRAMEWORK_BUNDLE_IMPORTER, FRAMEWORK_FILTER_PARSER, FRAMEWORK_LOGGER, FRAMEWORK_MANIFEST_FETCHER, FRAMEWORK_SEMVER_FACTORY, FRAMEWORK_UUID, FRAMEWORK_VENDOR, FRAMEWORK_VERSION, HOST_NAMESPACE, IDENTITY_NAMESPACE, INCLUDE_DIRECTIVE, LOG_LEVEL_PROP, LOG_LOGGER_PROP, LogLevel, MANDATORY_DIRECTIVE, OBJECTCLASS, PACKAGE_NAMESPACE, PANDINO_BUNDLE_IMPORTER_PROP, PANDINO_MANIFEST_FETCHER_PROP, PANDINO_VERSION_PROPERTY, PROVIDE_CAPABILITY, REQUIREMENT_CARDINALITY_DIRECTIVE, REQUIREMENT_FILTER_DIRECTIVE, REQUIRE_BUNDLE, REQUIRE_CAPABILITY, RESOLUTION_DIRECTIVE, RESOLUTION_OPTIONAL, SCOPE_BUNDLE, SCOPE_PROTOTYPE, SCOPE_SINGLETON, SERVICE_BUNDLEID, SERVICE_DEFAULT_RANK, SERVICE_DESCRIPTION, SERVICE_EVENT_INTERFACE_KEY, SERVICE_ID, SERVICE_LISTENER_INTERFACE_KEY, SERVICE_PID, SERVICE_RANKING, SERVICE_SCOPE, SINGLETON_DIRECTIVE, SYSTEMBUNDLE_ACTIVATORS_PROP, SYSTEM_BUNDLE_LOCATION, SYSTEM_BUNDLE_SYMBOLICNAME, TYPE_BUNDLE, TYPE_FRAGMENT, USES_DIRECTIVE, VERSION_ATTRIBUTE };\n","export function isAnyMissing(...parameters: any[]): boolean {\n  for (const param of parameters) {\n    if (param === null || param === undefined) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isAllPresent(...parameters: any[]): boolean {\n  return !isAnyMissing(...parameters);\n}\n","import { MANDATORY_DIRECTIVE, USES_DIRECTIVE } from '@pandino/pandino-api';\nimport { ManifestParserImpl } from '../util/manifest-parser/manifest-parser-impl';\nimport { isAnyMissing } from '../../utils/helpers';\nimport { BundleCapability } from './bundle-capability';\nimport { BundleRevision } from '../bundle-revision';\n\nexport class BundleCapabilityImpl implements BundleCapability {\n  private readonly revision: BundleRevision;\n  private readonly namespace: string;\n  private readonly dirs: Record<string, string> = {};\n  private readonly attrs: Record<string, any> = {};\n  private readonly uses: string[] = [];\n  private readonly mandatory: Set<string> = new Set<string>();\n\n  constructor(\n    revision: BundleRevision,\n    namespace: string,\n    dirs: Record<string, string> = {},\n    attrs: Record<string, any> = {},\n  ) {\n    this.revision = revision;\n    this.namespace = namespace;\n    this.dirs = dirs;\n    this.attrs = attrs;\n\n    let value = this.dirs[USES_DIRECTIVE];\n    if (value !== null && value !== undefined) {\n      const uses: string[] = value.split(',').map((i) => i.trim());\n      for (const u of uses) {\n        this.uses.push(u);\n      }\n    }\n\n    let mandatory: Set<string> = new Set<string>();\n    value = this.dirs[MANDATORY_DIRECTIVE];\n    if (value !== null && value !== undefined) {\n      const names = ManifestParserImpl.parseDelimitedString(value, ',');\n      for (let name of names) {\n        if (this.attrs.hasOwnProperty(name)) {\n          mandatory.add(name);\n        } else {\n          throw new Error(\"Mandatory attribute '\" + name + \"' does not exist.\");\n        }\n      }\n    }\n    this.mandatory = mandatory;\n  }\n\n  equals(other: any): boolean {\n    if (isAnyMissing(other) || !(other instanceof BundleCapabilityImpl)) {\n      return false;\n    }\n    if (\n      this.revision.getVersion().compare(other.revision.getVersion()) === 0 &&\n      this.getNamespace() === other.getNamespace()\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  getAttributes(): Record<string, any> {\n    return this.attrs;\n  }\n\n  getDirectives(): Record<string, string> {\n    return this.dirs;\n  }\n\n  getNamespace(): string {\n    return this.namespace;\n  }\n\n  getResource(): BundleRevision {\n    return this.revision;\n  }\n\n  getRevision(): BundleRevision {\n    return this.revision;\n  }\n\n  isAttributeMandatory(name: string): boolean {\n    return this.mandatory.size > 0 && this.mandatory.has(name);\n  }\n\n  getUses(): string[] {\n    return this.uses;\n  }\n\n  toString(): string {\n    if (isAnyMissing(this.revision)) {\n      return this.stringifyAttributes();\n    }\n    return '[' + this.revision + '] ' + this.namespace + '; ' + this.stringifyAttributes();\n  }\n\n  private stringifyAttributes(): string {\n    const list: string[] = Object.keys(this.attrs).map((key) => `${key}=${this.attrs[key]}`);\n    return `${list.join('; ')}`;\n  }\n}\n","export class ParsedHeaderClause {\n  public readonly paths: Array<string>;\n  public readonly dirs: Record<string, string>;\n  public readonly attrs: Record<string, any>;\n  public readonly types: Record<string, string>;\n\n  constructor(\n    paths: Array<string>,\n    dirs: Record<string, string>,\n    attrs: Record<string, any>,\n    types: Record<string, string>,\n  ) {\n    this.paths = paths;\n    this.dirs = dirs;\n    this.attrs = attrs;\n    this.types = types;\n  }\n}\n","import Filter, { FilterComp } from './filter';\n\n/* istanbul ignore file */\nfunction peg$subclass(child: any, parent: any) {\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  // @ts-ignore\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message: any, expected: any, found: any, location: any) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = 'SyntaxError';\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$parse(input: any) {\n  let options = arguments.length > 1 ? arguments[1] : {},\n    peg$FAILED = {},\n    peg$startRuleFunctions: any = { start: peg$parsestart },\n    peg$startRuleFunction = peg$parsestart,\n    peg$c0 = function (filter: any) {\n      return filter;\n    },\n    peg$c1 = function (filter: any) {\n      filter.value = filter.value.replace(/ +$/, '');\n      return filter;\n    },\n    peg$c2 = '(',\n    peg$c3 = { type: 'literal', value: '(', description: '\"(\"' },\n    peg$c4 = ')',\n    peg$c5 = { type: 'literal', value: ')', description: '\")\"' },\n    peg$c6 = '&',\n    peg$c7 = { type: 'literal', value: '&', description: '\"&\"' },\n    peg$c8 = function (filters: any) {\n      return Filter.AND(filters);\n    },\n    peg$c9 = '|',\n    peg$c10 = { type: 'literal', value: '|', description: '\"|\"' },\n    peg$c11 = function (filters: any) {\n      return Filter.OR(filters);\n    },\n    peg$c12 = '!',\n    peg$c13 = { type: 'literal', value: '!', description: '\"!\"' },\n    peg$c14 = function (filter: any) {\n      return Filter.NOT(filter);\n    },\n    peg$c15 = function (attr: any, comp: any, value: any) {\n      return new Filter(attr.attribute, comp, value);\n    },\n    peg$c16 = '=',\n    peg$c17 = { type: 'literal', value: '=', description: '\"=\"' },\n    peg$c18 = '~=',\n    peg$c19 = { type: 'literal', value: '~=', description: '\"~=\"' },\n    peg$c20 = '>=',\n    peg$c21 = { type: 'literal', value: '>=', description: '\">=\"' },\n    peg$c22 = '<=',\n    peg$c23 = { type: 'literal', value: '<=', description: '\"<=\"' },\n    peg$c24 = '=*',\n    peg$c25 = { type: 'literal', value: '=*', description: '\"=*\"' },\n    peg$c26 = function (attr: any) {\n      return Filter.attribute(attr.attribute).present();\n    },\n    peg$c27 = function (attr: any, value: any) {\n      return new Filter(attr.attribute, FilterComp.EQ, value);\n    },\n    peg$c28 = '*',\n    peg$c29 = { type: 'literal', value: '*', description: '\"*\"' },\n    peg$c30 = { type: 'other', description: 'attribute description' },\n    peg$c31 = ';',\n    peg$c32 = { type: 'literal', value: ';', description: '\";\"' },\n    peg$c33 = function (attr: any, opts: any) {\n      if (opts) {\n        opts.shift();\n        opts = opts.shift();\n        opts = opts.split(';');\n      }\n      attr.options = opts || [];\n      return attr;\n    },\n    peg$c34 = { type: 'other', description: 'attribute Type' },\n    peg$c35 = function (oid: any) {\n      return {\n        type: 'oid',\n        attribute: oid,\n      };\n    },\n    peg$c36 = function (name: any) {\n      return {\n        type: 'attribute',\n        attribute: name,\n      };\n    },\n    peg$c37 = { type: 'other', description: 'attribute type chars' },\n    peg$c38 = '-',\n    peg$c39 = { type: 'literal', value: '-', description: '\"-\"' },\n    peg$c40 = { type: 'other', description: 'OID' },\n    peg$c41 = '.',\n    peg$c42 = { type: 'literal', value: '.', description: '\".\"' },\n    peg$c43 = { type: 'other', description: 'attribute options' },\n    peg$c44 = { type: 'other', description: 'attribute option' },\n    peg$c45 = /^[^)]/,\n    peg$c46 = { type: 'class', value: '[^\\\\x29]', description: '[^\\\\x29]' },\n    peg$c47 = '\\\\',\n    peg$c48 = { type: 'literal', value: '\\\\', description: '\"\\\\\\\\\"' },\n    peg$c49 = function (char: any) {\n      return String.fromCharCode(char);\n    },\n    peg$c50 = function (value: any) {\n      return parseInt(value, 16);\n    },\n    peg$c51 = /^[a-fA-F0-9]/,\n    peg$c52 = { type: 'class', value: '[a-fA-F0-9]', description: '[a-fA-F0-9]' },\n    peg$c53 = { type: 'other', description: 'WHITESPACE' },\n    peg$c54 = { type: 'other', description: 'SPACE' },\n    peg$c55 = /^[ ]/,\n    peg$c56 = { type: 'class', value: '[\\\\x20]', description: '[\\\\x20]' },\n    peg$c57 = { type: 'other', description: 'TAB' },\n    peg$c58 = /^[\\t]/,\n    peg$c59 = { type: 'class', value: '[\\\\x09]', description: '[\\\\x09]' },\n    peg$c60 = { type: 'other', description: 'DIGIT' },\n    peg$c61 = /^[0-9]/,\n    peg$c62 = { type: 'class', value: '[0-9]', description: '[0-9]' },\n    peg$c63 = { type: 'other', description: 'ALPHA' },\n    peg$c64 = /^[a-zA-Z]/,\n    peg$c65 = { type: 'class', value: '[a-zA-Z]', description: '[a-zA-Z]' },\n    peg$c66 = { type: 'other', description: 'NEWLINE' },\n    peg$c67 = '\\r\\n',\n    peg$c68 = { type: 'literal', value: '\\r\\n', description: '\"\\\\r\\\\n\"' },\n    peg$c69 = '\\n',\n    peg$c70 = { type: 'literal', value: '\\n', description: '\"\\\\n\"' },\n    peg$currPos = 0,\n    peg$savedPos = 0,\n    peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }],\n    peg$maxFailPos = 0,\n    peg$maxFailExpected: any[] = [],\n    peg$silentFails = 0,\n    peg$result;\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description: any) {\n    throw peg$buildException(\n      null,\n      [{ type: 'other', description: description }],\n      input.substring(peg$savedPos, peg$currPos),\n      peg$computeLocation(peg$savedPos, peg$currPos),\n    );\n  }\n\n  function error(message: any) {\n    throw peg$buildException(\n      message,\n      null,\n      input.substring(peg$savedPos, peg$currPos),\n      peg$computeLocation(peg$savedPos, peg$currPos),\n    );\n  }\n\n  function peg$computePosDetails(pos: any) {\n    let details = peg$posDetailsCache[pos],\n      p,\n      ch;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column,\n        seenCR: details.seenCR,\n      };\n\n      while (p < pos) {\n        ch = input.charAt(p);\n        if (ch === '\\n') {\n          if (!details.seenCR) {\n            details.line++;\n          }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === '\\r' || ch === '\\u2028' || ch === '\\u2029') {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos: any, endPos: any) {\n    let startPosDetails = peg$computePosDetails(startPos),\n      endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column,\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column,\n      },\n    };\n  }\n\n  function peg$fail(expected: any) {\n    if (peg$currPos < peg$maxFailPos) {\n      return;\n    }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message: any, expected: any, found: any, location: any) {\n    function cleanupExpected(expected: any) {\n      let i = 1;\n\n      expected.sort(function (a: any, b: any) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected: any, found: any) {\n      function stringEscape(s: any) {\n        function hex(ch: any) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        return s\n          .replace(/\\\\/g, '\\\\\\\\')\n          .replace(/\"/g, '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g, '\\\\t')\n          .replace(/\\n/g, '\\\\n')\n          .replace(/\\f/g, '\\\\f')\n          .replace(/\\r/g, '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch: any) {\n            return '\\\\x0' + hex(ch);\n          })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch: any) {\n            return '\\\\x' + hex(ch);\n          })\n          .replace(/[\\u0100-\\u0FFF]/g, function (ch: any) {\n            return '\\\\u0' + hex(ch);\n          })\n          .replace(/[\\u1000-\\uFFFF]/g, function (ch: any) {\n            return '\\\\u' + hex(ch);\n          });\n      }\n\n      let expectedDescs = new Array(expected.length),\n        expectedDesc,\n        foundDesc,\n        i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc =\n        expected.length > 1\n          ? expectedDescs.slice(0, -1).join(', ') + ' or ' + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n      foundDesc = found ? '\"' + stringEscape(found) + '\"' : 'end of input';\n\n      return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';\n    }\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    // @ts-ignore\n    return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);\n  }\n\n  function peg$parsestart() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefilter();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c0(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseFILL();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseFILL();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseitem();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter(): any {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseFILL();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseFILL();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c2;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c3);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltercomp();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s4 = peg$c4;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c5);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseFILL();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseFILL();\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c0(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltercomp() {\n    let s0;\n\n    s0 = peg$parseand();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseor();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsenot();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseitem();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseand() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 38) {\n      s1 = peg$c6;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c7);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseFILL();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseFILL();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefilterlist();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseFILL();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseFILL();\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c8(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseor() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 124) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c10);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseFILL();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseFILL();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefilterlist();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseFILL();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseFILL();\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenot() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 33) {\n      s1 = peg$c12;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c13);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseFILL();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseFILL();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefilter();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseFILL();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseFILL();\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c14(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilterlist() {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parsefilter();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsefilter();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseitem() {\n    let s0;\n\n    s0 = peg$parsesubstring();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsesimple();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsepresent();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesimple() {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseAttributeDescription();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefiltertype();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsevalue();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltertype() {\n    let s0;\n\n    s0 = peg$parseequal();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseapprox();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsegreater();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseless();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseequal() {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 61) {\n      s0 = peg$c16;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseapprox() {\n    let s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c18) {\n      s0 = peg$c18;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c19);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegreater() {\n    let s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c20) {\n      s0 = peg$c20;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c21);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseless() {\n    let s0;\n\n    if (input.substr(peg$currPos, 2) === peg$c22) {\n      s0 = peg$c22;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c23);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepresent() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseAttributeDescription();\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c24) {\n        s2 = peg$c24;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c25);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c26(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubstring() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseAttributeDescription();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseequal();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        s5 = peg$parsevalue();\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseany();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsevalue();\n            if (s7 === peg$FAILED) {\n              s7 = null;\n            }\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c27(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseany() {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s2 = peg$c28;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c29);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsevalue();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s5 = peg$c28;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c29);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsevalue();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s5 = peg$c28;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c29);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseAttributeValue();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseAttributeValue();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseAttributeDescription() {\n    let s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseAttributeType();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s3 = peg$c31;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c32);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseoptions();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c33(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c30);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAttributeType() {\n    let s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseLDAP_OID();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c35(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = peg$parseALPHA();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parseAttrTypeChars();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parseAttrTypeChars();\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c36(s1);\n      }\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c34);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAttrTypeChars() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseALPHA();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseDIGIT();\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s0 = peg$c38;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c39);\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c37);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLDAP_OID() {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseDIGIT();\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDIGIT();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s5 = peg$c41;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c42);\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = [];\n        s7 = peg$parseDIGIT();\n        if (s7 !== peg$FAILED) {\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parseDIGIT();\n          }\n        } else {\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          s5 = [s5, s6];\n          s4 = s5;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s5 = peg$c41;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c42);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parseDIGIT();\n          if (s7 !== peg$FAILED) {\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parseDIGIT();\n            }\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c40);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseoptions(): any {\n    let s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseoption();\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s3 = peg$c31;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c32);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseoptions();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseoption();\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c43);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseoption() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parseAttrTypeChars();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parseAttrTypeChars();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c44);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAttributeValue() {\n    let s0;\n\n    s0 = peg$parseEscapedCharacter();\n    if (s0 === peg$FAILED) {\n      if (peg$c45.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c46);\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapedCharacter() {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c47;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c48);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseASCII_VALUE();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c49(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseASCII_VALUE() {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parseHEX_CHAR();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parseHEX_CHAR();\n      if (s4 !== peg$FAILED) {\n        s3 = [s3, s4];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c50(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseHEX_CHAR() {\n    let s0;\n\n    if (peg$c51.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c52);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseFILL() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseSPACE();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseTAB();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseSEP();\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c53);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSPACE() {\n    let s0, s1;\n\n    peg$silentFails++;\n    if (peg$c55.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c56);\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c54);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseTAB() {\n    let s0, s1;\n\n    peg$silentFails++;\n    if (peg$c58.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c59);\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c57);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseDIGIT() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (peg$c61.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c62);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c60);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseALPHA() {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (peg$c64.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c65);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c63);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSEP() {\n    let s0, s1;\n\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c67) {\n      s0 = peg$c67;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c68);\n      }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c69;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c70);\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c66);\n      }\n    }\n\n    return s0;\n  }\n\n  function base64_decode(val: any) {\n    return new Buffer(val, 'base64').toString();\n  }\n\n  let _pluck = function (list: any, attr: any) {\n    return list.map(function (cv: any) {\n      return cv[attr];\n    });\n  };\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: 'end', description: 'end of input' });\n    }\n\n    throw peg$buildException(\n      null,\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),\n    );\n  }\n}\n\nexport default peg$parse;\n","import {\n  SERVICE_BUNDLEID,\n  SERVICE_DESCRIPTION,\n  SERVICE_ID,\n  SERVICE_RANKING,\n  SERVICE_SCOPE,\n} from '@pandino/pandino-api';\n\n/**\n * The original PegPARSE built Filter cannot handle dots (.) Needs to be fixed later...\n */\n\nexport const replaceMap: Map<string, string> = new Map<string, string>([\n  [SERVICE_ID, 'serviceId'],\n  [SERVICE_RANKING, 'serviceRanking'],\n  [SERVICE_BUNDLEID, 'serviceBundleid'],\n  [SERVICE_SCOPE, 'serviceScope'],\n  [SERVICE_DESCRIPTION, 'serviceDescription'],\n]);\n\nexport const inverseMap: Map<string, string> = new Map<string, string>([\n  ['serviceId', SERVICE_ID],\n  ['serviceRanking', SERVICE_RANKING],\n  ['serviceBundleid', SERVICE_BUNDLEID],\n  ['serviceScope', SERVICE_SCOPE],\n  ['serviceDescription', SERVICE_DESCRIPTION],\n]);\n","import { FilterApi } from '@pandino/pandino-api';\nimport peg$parse from './parse';\nimport { inverseMap, replaceMap } from './workarounds';\n\nexport enum FilterComp {\n  NOT = '!',\n  AND = '&',\n  OR = '|',\n  EQ = '=',\n  LTE = '<=',\n  GTE = '>=',\n  APPROX = '~=',\n  MATCH_ALL = '*',\n  PRESENT = '=*',\n}\n\nexport default class Filter implements FilterApi {\n  public readonly type: any = 'filter';\n\n  constructor(public attrib: string, public comp: FilterComp, public value: any, public filters: Filter[] = []) {}\n\n  static attribute(name: any): Attribute {\n    return new Attribute(name);\n  }\n\n  static parse(input: string): Filter {\n    if (input === '(*)') {\n      return new Filter(undefined, FilterComp.MATCH_ALL, undefined);\n    }\n\n    let newInput = input;\n    for (const [original, replaceVal] of replaceMap.entries()) {\n      newInput = newInput.replace(new RegExp(original, 'g'), replaceVal);\n    }\n\n    const originalFilter = peg$parse(newInput);\n    return Filter.recursiveReplace(originalFilter, inverseMap);\n  }\n\n  private static recursiveReplace(filter: Filter, inverseMap: Map<string, string>): Filter {\n    for (const [original, replaceVal] of inverseMap.entries()) {\n      if (filter.attrib) {\n        filter.attrib = filter.attrib.replace(new RegExp(original, 'g'), replaceVal);\n      }\n    }\n\n    for (const f of filter.filters) {\n      Filter.recursiveReplace(f, inverseMap);\n    }\n\n    return filter;\n  }\n\n  static convert(attrs: Record<string, any>): Filter {\n    const filters: Filter[] = [];\n\n    for (let [_, value] of Object.entries(attrs)) {\n      filters.push(Filter.parse(value.toString()));\n    }\n\n    let filter: Filter;\n\n    if (filters.length === 1) {\n      filter = filters[0];\n    } else if (Object.keys(attrs).length > 1) {\n      filter = new Filter(null, FilterComp.AND, filters);\n    } else if (filters.length === 0) {\n      filter = new Filter(null, FilterComp.MATCH_ALL, null);\n    }\n\n    return filter;\n  }\n\n  match(data: any): boolean {\n    const value = this.value;\n    const attrv = data[this.attrib];\n\n    switch (this.comp) {\n      case '!':\n        return Filter.NOT(this.filters)._match(data);\n      case '&':\n        return Filter.AND(this.filters)._match(data);\n      case '|':\n        return Filter.OR(this.filters)._match(data);\n      case '=':\n        if (value === '*' && attrv) {\n          return true;\n        }\n        return Filter.matchString(attrv, value);\n      case '<=':\n        return Filter.matchLTE(attrv, value);\n      case '>=':\n        return Filter.matchGTE(attrv, value);\n      default:\n        throw new Error('Unsupported comparison type');\n    }\n  }\n\n  simplify(): Filter {\n    if (this.filters) {\n      if (this.filters.length == 1) {\n        return this.filters[0].simplify();\n      } else {\n        this.filters = this.filters.map((filter) => filter.simplify());\n      }\n    }\n    return this;\n  }\n\n  protected _indent(indent?: any, level?: number, id_char?: string | number): string {\n    const _i = parseInt(indent);\n    if (indent === true) {\n      indent = Filter.indent;\n    } else if (!isNaN(_i)) {\n      indent = _i;\n    } else {\n      return '';\n    }\n\n    if (id_char !== undefined && typeof id_char != 'string') {\n      throw new Error('Indent string must be string');\n    }\n\n    level = level || 0;\n    id_char = id_char || Filter.indent_char;\n    if (typeof id_char === 'number') {\n      id_char = id_char.toString();\n    }\n\n    return id_char.repeat(level * indent);\n  }\n\n  toString(indent?: any, level?: number, id_char?: string | number): string {\n    return [this._indent(indent, level, id_char), '(', this.attrib, this.comp, this.value, ')'].join('');\n  }\n\n  static escapeChars = ['*', '(', ')', '\\\\', String.fromCharCode(0)];\n  static indent = 4;\n  static indent_char = ' ';\n  static collapse_not = true;\n\n  static escape(value: string): string {\n    if (!value) return '';\n\n    return value\n      .split('')\n      .map((c) => {\n        return Filter.escapeChars.indexOf(c) >= 0 ? '\\\\' + c.charCodeAt(0).toString(16) : c;\n      })\n      .join('');\n  }\n\n  static unescape(data: any): string {\n    const chars = data.split('');\n    const out = [];\n    let tmp;\n\n    while (chars.length) {\n      tmp = chars.shift();\n\n      if (tmp == '\\\\') {\n        tmp = chars.shift() + chars.shift();\n        tmp = parseInt(tmp, 16);\n        tmp = String.fromCharCode(tmp);\n      }\n      out.push(tmp);\n    }\n\n    return out.join('');\n  }\n\n  static matchString(data: any, filter: string): boolean {\n    if (!data) return false;\n    const match = Array.isArray(data) ? data : [data];\n    if (filter.indexOf('*') < 0) {\n      return match.some((cv) => {\n        if (cv) {\n          return cv.toLowerCase() === Filter.unescape(filter).toLowerCase();\n        }\n      });\n    }\n    return Filter.matchSubstring(data, filter);\n  }\n\n  static matchSubstring(data: any, filter: string): boolean {\n    const match = Array.isArray(data) ? data : [data];\n    let pattern = filter.replace(/\\*/g, '.*');\n    pattern = pattern.replace(/\\\\([0-9a-fA-F]{2,2})/g, (m: any, $1: any) => {\n      let s = String.fromCharCode(parseInt($1, 16));\n      if (['(', ')', '\\\\', '*'].indexOf(s) >= 0) {\n        s = '\\\\x' + $1.toUpperCase();\n      }\n      return s;\n    });\n    const regex = new RegExp('^' + pattern + '$', 'i');\n    return match.some((cv) => cv.match(regex));\n  }\n\n  static matchLTE(data: any, filter: number): boolean {\n    const match = Array.isArray(data) ? data : [data];\n    return match.some((cv) => cv <= filter);\n  }\n\n  static matchGTE(data: any, filter: number): boolean {\n    const match = Array.isArray(data) ? data : [data];\n    return match.some((cv) => cv >= filter);\n  }\n\n  static AND(filters: Filter[]): GroupAnd {\n    return new GroupAnd(filters);\n  }\n\n  static OR(filters: Filter[]): GroupOr {\n    return new GroupOr(filters);\n  }\n\n  static NOT(filter: Filter | Filter[]): GroupNot {\n    if (!Array.isArray(filter)) {\n      filter = [filter];\n    }\n    if (filter.length != 1) {\n      throw new Error('NOT must wrap single filter');\n    }\n    return new GroupNot(filter);\n  }\n}\n\nclass Group extends Filter {\n  public readonly type: any = 'group';\n\n  constructor(comp: FilterComp, filters: Filter[] = []) {\n    super(null, comp, null, filters);\n  }\n\n  match(data: any): boolean {\n    return super.match(data);\n  }\n\n  toString(indent?: any, level?: number, id_char?: string): string {\n    level = level || 0;\n    let id_str = this._indent(indent, level, id_char);\n    let id_str2 = id_str;\n    let nl = indent ? '\\n' : '';\n\n    if (Filter.collapse_not && this.comp === '!') {\n      nl = '';\n      id_str2 = '';\n      indent = 0;\n    }\n\n    return [\n      id_str,\n      '(',\n      this.comp,\n      nl,\n      this.filters.map((item) => item.toString(indent, level + 1, id_char)).join(nl),\n      nl,\n      id_str2,\n      ')',\n    ].join('');\n  }\n}\n\nclass GroupOr extends Group {\n  constructor(filters: Filter[] = []) {\n    super(FilterComp.OR, filters);\n  }\n\n  _match(data: any): boolean {\n    return this.filters.some((cv) => cv.match(data));\n  }\n}\n\nclass GroupAnd extends Group {\n  constructor(filters: Filter[] = []) {\n    super(FilterComp.AND, filters);\n  }\n\n  _match(data: any): boolean {\n    return this.filters.every((cv) => cv.match(data));\n  }\n}\n\nclass GroupNot extends Group {\n  constructor(filters: Filter[] = []) {\n    super(FilterComp.NOT, filters);\n  }\n\n  _match(data: any): boolean {\n    return this.filters.every((cv) => {\n      if (cv && typeof cv.match === 'function') {\n        return !!!cv.match(data);\n      }\n    });\n  }\n\n  simplify(): GroupNot {\n    return this;\n  }\n}\n\nclass Attribute {\n  private escapeChars: string[] = ['*', '(', ')', '\\\\', String.fromCharCode(0)];\n\n  constructor(private name: string) {}\n\n  present(): Filter {\n    return new Filter(this.name, FilterComp.EQ, '*');\n  }\n\n  raw(value: any): Filter {\n    return new Filter(this.name, FilterComp.EQ, value);\n  }\n\n  equalTo(value: any): Filter {\n    return new Filter(this.name, FilterComp.EQ, this.escape(value));\n  }\n\n  endsWith(value: any): Filter {\n    return new Filter(this.name, FilterComp.EQ, '*' + this.escape(value));\n  }\n\n  startsWith(value: any): Filter {\n    return new Filter(this.name, FilterComp.EQ, this.escape(value) + '*');\n  }\n\n  contains(value: any): Filter {\n    return new Filter(this.name, FilterComp.EQ, '*' + this.escape(value) + '*');\n  }\n\n  approx(value: any): Filter {\n    return new Filter(this.name, FilterComp.APPROX, this.escape(value));\n  }\n\n  lte(value: any): Filter {\n    return new Filter(this.name, FilterComp.LTE, this.escape(value));\n  }\n\n  gte(value: any): Filter {\n    return new Filter(this.name, FilterComp.GTE, this.escape(value));\n  }\n\n  escape(value: any): string {\n    if (typeof value === 'number') {\n      value = value.toString();\n    }\n    const rv = [];\n    for (let i = 0, l = value.length; i < l; i++) {\n      rv.push(this.escapeChars.indexOf(value[i]) >= 0 ? '\\\\' + value.charCodeAt(i).toString(16) : value[i]);\n    }\n    return rv.join('');\n  }\n}\n","const MAX_LENGTH = 256;\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// \n//  0\nconst NUMERIC_IDENTIFIER = '0|[1-9]\\\\d*';\n// \nconst NUMERIC_LETTERS_IDENTIFIER = '[0-9A-Za-z-]*';\nconst BUILD_IDENTIFIER = `[0-9A-Za-z-]+`;\n// 0\nconst NON_NUMERIC_IDENTIFIER = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\nconst MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})`;\n//  ASCII  [0-9A-Za-z-] \n//  MUST NOT  MUST NOT \nconst PRERELEASE_IDENTIFIER = `(?:${NUMERIC_IDENTIFIER}|${NON_NUMERIC_IDENTIFIER})`;\nconst PRERELEASE = `(?:\\\\-(${PRERELEASE_IDENTIFIER}(?:\\\\.${PRERELEASE_IDENTIFIER})*))`;\n// \nconst BUILD = `(?:\\\\+(${BUILD_IDENTIFIER}(?:\\\\.${BUILD_IDENTIFIER})*))`;\nconst FULL_VERSION_IDENTIFIER = `^v?${MAIN_VERSION_IDENTIFIER}${PRERELEASE}?${BUILD}?$`;\n\n// \nconst REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);\nconst REGEX_FULL_VERSION = new RegExp(FULL_VERSION_IDENTIFIER);\nconst REGEX_NUMERIC = /^[0-9]+$/;\n\nexport class SemverVersion {\n  private rawVersion: any;\n  private major: any;\n  private minor: any;\n  private patch: any;\n  private prereleaseArray: any;\n  private prerelease: any;\n  private build: any;\n  mainVersion: any;\n  private version: any;\n\n  constructor(version: any) {\n    if (version instanceof SemverVersion) {\n      return version;\n    } else if (typeof version !== 'string') {\n      throw new TypeError('Invalid Version: ' + version);\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);\n    }\n\n    if (!(this instanceof SemverVersion)) {\n      return new SemverVersion(version);\n    }\n\n    const matches = version.trim().match(REGEX_FULL_VERSION);\n\n    this.rawVersion = version;\n    this.major = +matches[1];\n    this.minor = +matches[2];\n    this.patch = +matches[3];\n\n    this._isThrowVersionNumericError(this.major, 'major');\n    this._isThrowVersionNumericError(this.minor, 'minor');\n    this._isThrowVersionNumericError(this.patch, 'patch');\n\n    if (matches[4]) {\n      this.prereleaseArray = matches[4].split('.').map(function (id) {\n        if (REGEX_NUMERIC.test(id)) {\n          var num = +id;\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num;\n          }\n        }\n        return id;\n      });\n    } else {\n      this.prereleaseArray = [];\n    }\n\n    //this.build = matches[5] ? matches[5].split('.') : [];\n\n    this.prerelease = matches[4];\n    this.build = matches[5];\n    this.mainVersion = [this.major, this.minor, this.patch].join('.');\n    this.version =\n      this.mainVersion + (this.prerelease ? `-${this.prerelease}` : '') + (this.build ? `+${this.build}` : '');\n  }\n\n  private _isThrowVersionNumericError(versionNumber: any, versionName: any) {\n    if (versionNumber > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError(`Invalid ${versionName} version`);\n    }\n  }\n\n  private _isNumeric(numeric: any) {\n    return REGEX_NUMERIC.test(numeric);\n  }\n\n  private _padNumber(num: any, fill: any) {\n    const length = ('' + num).length;\n    return Array(fill > length ? fill - length + 1 || 0 : 0).join(0 as any) + num;\n  }\n\n  static validate(version: any) {\n    return REGEX_FULL_VERSION.test(version);\n  }\n\n  mainVersionToNumeric(digit: any) {\n    const numericStr = [\n      this._padNumber(this.major, digit),\n      this._padNumber(this.minor, digit),\n      this._padNumber(this.patch, digit),\n    ].join('');\n    return parseInt(numericStr);\n  }\n\n  compare(other: any, needCompareBuildVersion = false) {\n    let otherSemver = other;\n    if (!(other instanceof SemverVersion)) {\n      otherSemver = new SemverVersion(other);\n    }\n    const result = this.compareMainVersion(otherSemver) || this.comparePreReleaseVersion(otherSemver);\n    if (!result && needCompareBuildVersion) {\n      return this.compareBuildVersion(otherSemver);\n    } else {\n      return result;\n    }\n  }\n\n  // \n  compareNumeric(a: any, b: any) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  compareIdentifiers(a: any, b: any) {\n    const aIsNumeric = this._isNumeric(a);\n    const bIsNumeric = this._isNumeric(b);\n    if (aIsNumeric && bIsNumeric) {\n      a = +a;\n      b = +b;\n    }\n    // \n    if (aIsNumeric && !bIsNumeric) {\n      return -1;\n    } else if (bIsNumeric && !aIsNumeric) {\n      return 1;\n    } else {\n      return this.compareNumeric(a, b);\n    }\n  }\n\n  compareMainVersion(otherSemver: any) {\n    return (\n      this.compareNumeric(this.major, otherSemver.major) ||\n      this.compareNumeric(this.minor, otherSemver.minor) ||\n      this.compareNumeric(this.patch, otherSemver.patch)\n    );\n  }\n\n  comparePreReleaseVersion(otherSemver: any) {\n    if (this.prereleaseArray.length && !otherSemver.prereleaseArray.length) {\n      return -1;\n    } else if (!this.prereleaseArray.length && otherSemver.prereleaseArray.length) {\n      return 1;\n    } else if (!this.prereleaseArray.length && !otherSemver.prereleaseArray.length) {\n      return 0;\n    }\n    let i = 0;\n    do {\n      const a = this.prereleaseArray[i];\n      const b = otherSemver.prereleaseArray[i];\n      if (a === undefined && b === undefined) {\n        return 0;\n      } else if (b === undefined) {\n        return 1;\n      } else if (a === undefined) {\n        return -1;\n      } else if (a === b) {\n        continue;\n      } else {\n        return this.compareIdentifiers(a, b);\n      }\n    } while (++i);\n  }\n\n  compareBuildVersion(otherSemver: any) {\n    if (this.build && !otherSemver.build) {\n      return 1;\n    } else if (!this.build && otherSemver.build) {\n      return -1;\n    } else {\n      return this.compareIdentifiers(this.build, otherSemver.build);\n    }\n  }\n}\n","import { SemverVersion } from './semver';\n\nexport const version = '0.0.5';\n\nexport const validate = (version: any) => {\n  return SemverVersion.validate(version);\n};\n\nexport const compare = (a: any, b: any, needCompareBuildVersion?: boolean) => {\n  return new SemverVersion(a).compare(new SemverVersion(b), needCompareBuildVersion);\n};\n\nexport const instance = (version: any) => {\n  return new SemverVersion(version);\n};\n\nexport const compareMainVersion = (a: any, b: any) => {\n  return new SemverVersion(a).compareMainVersion(new SemverVersion(b));\n};\n\nexport const gt = (a: any, b: any, needCompareBuildVersion?: boolean) => {\n  const result = compare(a, b, needCompareBuildVersion);\n  return result === 1;\n};\n\nexport const gte = (a: any, b: any, needCompareBuildVersion?: any) => {\n  const result = compare(a, b, needCompareBuildVersion);\n  return result === 1 || result === 0;\n};\n\nexport const lt = (a: any, b: any, needCompareBuildVersion?: boolean) => {\n  const result = compare(a, b, needCompareBuildVersion);\n  return result === -1;\n};\n\nexport const lte = (a: any, b: any, needCompareBuildVersion?: boolean) => {\n  const result = compare(a, b, needCompareBuildVersion);\n  return result === -1 || result === 0;\n};\n\nexport const equal = (a: any, b: any, needCompareBuildVersion?: boolean) => {\n  const result = compare(a, b, needCompareBuildVersion);\n  return result === 0;\n};\n\nexport const equalMain = (a: any, b: any) => {\n  return new SemverVersion(a).mainVersion === new SemverVersion(b).mainVersion;\n};\n\n// \nexport const mainVersionToNumeric = (version: any, digit = 6) => {\n  const semverVersion = new SemverVersion(version);\n  return semverVersion.mainVersionToNumeric(digit);\n};\n","import { SemVer } from '@pandino/pandino-api';\nimport { compare, lte, equal, gte } from '../semver-lite/src';\n\nexport class SemVerImpl implements SemVer {\n  constructor(private readonly version: string) {}\n\n  toString(): string {\n    return this.version.toString();\n  }\n\n  compare(other: SemVer): number {\n    return compare(this.version, other.toString());\n  }\n\n  equal(other: string): boolean {\n    return equal(this.version, other);\n  }\n\n  lte(other: string): boolean {\n    return lte(this.version, other);\n  }\n\n  gte(other: string): boolean {\n    return gte(this.version, other);\n  }\n\n  neq(other: string): boolean {\n    return !this.equal(other);\n  }\n}\n","import { BundleCapabilityImpl } from '../wiring/bundle-capability-impl';\nimport Filter, { FilterComp } from '../../filter/filter';\nimport { isAllPresent, isAnyMissing } from '../../utils/helpers';\nimport { BundleCapability } from '../wiring/bundle-capability';\nimport { Capability } from '../resource/capability';\nimport { SemVerImpl } from '../../utils/semver-impl';\nimport { equal, gte, lte } from '../../semver-lite/src';\n\nexport type CapabilityIndex = Record<any, Set<BundleCapability>>;\n\nexport class CapabilitySet {\n  private readonly indices: Record<string, CapabilityIndex> = {};\n  private readonly capSet: Set<Capability> = new Set<Capability>();\n\n  constructor(indexProps: Array<string> = []) {\n    for (const indexProp in indexProps) {\n      this.indices[indexProp] = {};\n    }\n  }\n\n  match(sf: Filter, obeyMandatory: boolean): Set<Capability> {\n    const matches: Set<Capability> = this.matchCapSet(this.capSet, sf);\n    return obeyMandatory ? CapabilitySet.matchMandatoryCapSet(matches, sf) : matches;\n  }\n\n  addCapability(cap: BundleCapability): void {\n    this.capSet.add(cap);\n\n    for (const [key, value] of Object.entries(this.indices)) {\n      let value = cap.getAttributes()[key];\n      if (isAllPresent(value)) {\n        const index: CapabilityIndex = value;\n\n        if (Array.isArray(value)) {\n          const c: any[] = value;\n          for (const o of c) {\n            CapabilitySet.indexCapability(index, cap, o);\n          }\n        } else {\n          CapabilitySet.indexCapability(index, cap, value);\n        }\n      }\n    }\n  }\n\n  removeCapability(cap: BundleCapability): void {\n    const hadCap = this.capSet.has(cap);\n    this.capSet.delete(cap);\n    if (hadCap) {\n      for (const [key, eValue] of Object.entries(this.indices)) {\n        let value = cap.getAttributes()[key];\n        if (isAllPresent(value)) {\n          const index: Record<any, Set<BundleCapability>> = eValue;\n\n          if (Array.isArray(value)) {\n            const c: any[] = value;\n            for (const o of c) {\n              CapabilitySet.deindexCapability(index, cap, o);\n            }\n          } else {\n            CapabilitySet.deindexCapability(index, cap, value);\n          }\n        }\n      }\n    }\n  }\n\n  static matches(cap: Capability, sf?: Filter): boolean {\n    return CapabilitySet.matchesInternal(cap, sf) && CapabilitySet.matchMandatory(cap, sf);\n  }\n\n  static matchMandatory(cap: Capability, sf?: Filter): boolean {\n    if (isAnyMissing(sf)) {\n      return false;\n    }\n    const attrs = cap.getAttributes();\n    for (const key of Object.keys(attrs)) {\n      if ((cap as BundleCapabilityImpl).isAttributeMandatory(key) && !CapabilitySet.matchMandatoryAttribute(key, sf)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static matchMandatoryAttribute(attrName: string, sf?: Filter): boolean {\n    if (!sf) {\n      return false;\n    }\n\n    if (sf.attrib !== null && sf.attrib !== undefined && sf.attrib === attrName) {\n      return true;\n    } else if (sf.comp === FilterComp.AND) {\n      let list: any[] = sf.filters;\n      for (let i = 0; i < list.length; i++) {\n        let sf2 = list[i] as Filter;\n        if (sf2.attrib !== null && sf.attrib !== undefined && sf2.attrib === attrName) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  static compare(lhs: any, rhsUnknown: any, cmp: FilterComp): boolean {\n    if (isAnyMissing(lhs)) {\n      return false;\n    }\n\n    if (cmp === FilterComp.PRESENT) {\n      return true;\n    }\n\n    const rhs = typeof rhsUnknown === 'string' ? rhsUnknown.trim() : rhsUnknown;\n\n    if (typeof lhs === 'boolean') {\n      switch (cmp) {\n        case FilterComp.EQ:\n        case FilterComp.GTE:\n        case FilterComp.LTE:\n          return lhs === (rhs === 'true');\n        default:\n          throw new Error('Unsupported comparison operator: ' + cmp);\n      }\n    }\n\n    if (typeof lhs === 'number') {\n      switch (cmp) {\n        case FilterComp.EQ:\n          return lhs === Number(rhs);\n        case FilterComp.GTE:\n          return lhs >= Number(rhs);\n        case FilterComp.LTE:\n          return lhs <= Number(rhs);\n        default:\n          throw new Error('Unsupported comparison operator: ' + cmp);\n      }\n    }\n\n    if (lhs instanceof SemVerImpl) {\n      switch (cmp) {\n        case FilterComp.EQ:\n          return equal(lhs.toString(), rhs.toString());\n        case FilterComp.NOT:\n          return !equal(lhs.toString(), rhs.toString());\n        case FilterComp.GTE:\n          return gte(lhs.toString(), rhs.toString());\n        case FilterComp.LTE:\n          return lte(lhs.toString(), rhs.toString());\n        default:\n          throw new Error('Unsupported comparison operator: ' + cmp);\n      }\n    }\n\n    if (typeof lhs === 'string') {\n      switch (cmp) {\n        case FilterComp.EQ:\n          return lhs === rhs;\n        case FilterComp.NOT:\n          return lhs !== rhs;\n        default:\n          throw new Error('Unsupported comparison operator: ' + cmp);\n      }\n    }\n\n    if (Array.isArray(lhs)) {\n      for (let a of lhs) {\n        if (CapabilitySet.compare(a, rhsUnknown, cmp)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n\n  private static indexCapability(index: CapabilityIndex, cap: BundleCapability, capValue: any): void {\n    let caps: Set<BundleCapability> = new Set<BundleCapability>();\n    const prevVal: Set<BundleCapability> = index[capValue];\n    if (!prevVal) {\n      index[capValue] = caps;\n    }\n    if (isAllPresent(prevVal)) {\n      caps = prevVal;\n    }\n    caps.add(cap);\n  }\n\n  private static deindexCapability(index: CapabilityIndex, cap: BundleCapability, value: any): void {\n    let caps: Set<BundleCapability> = index[value];\n\n    if (isAllPresent(caps)) {\n      caps.delete(cap);\n      if (caps.size === 0) {\n        delete index[value];\n      }\n    }\n  }\n\n  private static matchMandatoryCapSet(caps: Set<Capability>, sf: Filter): Set<Capability> {\n    for (const cap of caps) {\n      if (!CapabilitySet.matchMandatory(cap, sf)) {\n        caps.delete(cap);\n      }\n    }\n    return caps;\n  }\n\n  private matchCapSet(caps: Set<Capability>, sf: Filter): Set<Capability> {\n    let matches: Set<Capability> = new Set<Capability>();\n\n    if (sf.comp === FilterComp.MATCH_ALL) {\n      caps.forEach((c) => matches.add(c));\n    } else if (sf.comp === FilterComp.AND) {\n      const sfs: Array<Filter> = sf.filters;\n      for (let i = 0; caps.size > 0 && i < sfs.length; i++) {\n        matches = this.matchCapSet(caps, sfs[i]);\n        caps = matches;\n      }\n    } else if (sf.comp === FilterComp.OR) {\n      const sfs: Array<Filter> = sf.filters;\n      for (let i = 0; i < sfs.length; i++) {\n        this.matchCapSet(caps, sfs[i]).forEach((c) => matches.add(c));\n      }\n    } else if (sf.comp === FilterComp.NOT) {\n      caps.forEach((c) => matches.add(c));\n      const sfs: Array<Filter> = sf.filters;\n      for (let i = 0; i < sfs.length; i++) {\n        const ms = this.matchCapSet(caps, sfs[i]);\n        ms.forEach((c) => matches.delete(c));\n      }\n    } else {\n      const index: Record<any, Set<BundleCapability>> = this.indices[sf.attrib];\n      if (sf.comp === FilterComp.EQ && isAllPresent(index)) {\n        const existingCaps: Set<BundleCapability> = index[sf.attrib];\n        if (isAllPresent(existingCaps)) {\n          existingCaps.forEach((c) => matches.add(c));\n          if (caps !== this.capSet) {\n            caps.forEach((c) => {\n              if (!matches.has(c)) {\n                matches.delete(c);\n              }\n            });\n          }\n        }\n      } else {\n        for (const cap of caps) {\n          const lhs: any = cap.getAttributes()[sf.attrib];\n          if (isAllPresent(lhs)) {\n            if (CapabilitySet.compare(lhs, sf.value, sf.comp)) {\n              matches.add(cap);\n            }\n          }\n        }\n      }\n    }\n\n    return matches;\n  }\n\n  private static matchesInternal(cap: Capability, sf?: Filter): boolean {\n    let matched = true;\n\n    if (isAnyMissing(sf)) {\n      matched = false;\n    } else if (sf.comp === FilterComp.MATCH_ALL) {\n      matched = true;\n    } else if (sf.comp === FilterComp.AND) {\n      const sfs = sf.filters as Filter[];\n      for (let i = 0; matched && i < sfs.length; i++) {\n        matched = CapabilitySet.matchesInternal(cap, sfs[i]);\n      }\n    } else if (sf.comp === FilterComp.OR) {\n      matched = false;\n      const sfs = sf.filters as Filter[];\n      for (let i = 0; !matched && i < sfs.length; i++) {\n        matched = CapabilitySet.matchesInternal(cap, sfs[i]);\n      }\n    } else if (sf.comp === FilterComp.NOT) {\n      const sfs = sf.filters as Filter[];\n      for (let i = 0; i < sfs.length; i++) {\n        matched = !CapabilitySet.matchesInternal(cap, sfs[i]);\n      }\n    } else {\n      matched = false;\n      const lhs = cap.getAttributes()[sf.attrib];\n      if (lhs !== null && lhs !== undefined) {\n        matched = CapabilitySet.compare(lhs, sf.value, sf.comp);\n      }\n    }\n\n    return matched;\n  }\n}\n","import { RESOLUTION_DIRECTIVE, RESOLUTION_OPTIONAL } from '@pandino/pandino-api';\nimport { CapabilitySet } from '../capability-set/capability-set';\nimport Filter from '../../filter/filter';\nimport { BundleRevision } from '../bundle-revision';\nimport { BundleCapability } from './bundle-capability';\nimport { BundleRequirement } from './bundle-requirement';\n\nexport class BundleRequirementImpl implements BundleRequirement {\n  private readonly revision: BundleRevision;\n  private readonly namespace: string;\n  private readonly filter?: Filter;\n  private readonly optional: boolean;\n  private readonly dirs: Record<string, string> = {};\n  private readonly attrs: Record<string, any> = {};\n\n  constructor(\n    revision: BundleRevision,\n    namespace: string,\n    dirs: Record<string, string> = {},\n    attrs: Record<string, any> = {},\n    filter?: Filter,\n  ) {\n    this.revision = revision;\n    this.namespace = namespace;\n    this.dirs = dirs;\n    this.attrs = attrs;\n    this.filter = filter || Filter.convert(this.attrs);\n    this.optional =\n      this.dirs.hasOwnProperty(RESOLUTION_DIRECTIVE) && this.dirs[RESOLUTION_DIRECTIVE] === RESOLUTION_OPTIONAL;\n  }\n\n  getAttributes(): Record<string, any> {\n    return this.attrs;\n  }\n\n  getDirectives(): Record<string, string> {\n    return this.dirs;\n  }\n\n  getNamespace(): string {\n    return this.namespace;\n  }\n\n  getResource(): BundleRevision {\n    return this.revision;\n  }\n\n  getRevision(): BundleRevision {\n    return this.revision;\n  }\n\n  matches(capability: BundleCapability): boolean {\n    return CapabilitySet.matches(capability, this.getFilter());\n  }\n\n  isOptional(): boolean {\n    return this.optional;\n  }\n\n  getFilter?(): Filter {\n    return this.filter;\n  }\n\n  toString(): string {\n    return '[' + this.revision + '] ' + this.namespace + '; ' + this.getFilter()?.toString();\n  }\n}\n","import {\n  ActivationPolicy,\n  BundleConfigMap,\n  ACTIVATION_LAZY,\n  BUNDLE_ACTIVATIONPOLICY,\n  BUNDLE_COPYRIGHT,\n  BUNDLE_DESCRIPTION,\n  BUNDLE_MANIFESTVERSION,\n  BUNDLE_NAMESPACE,\n  BUNDLE_SYMBOLICNAME,\n  BUNDLE_VERSION,\n  BUNDLE_VERSION_ATTRIBUTE,\n  CAPABILITY_COPYRIGHT_ATTRIBUTE,\n  CAPABILITY_DESCRIPTION_ATTRIBUTE,\n  CAPABILITY_SINGLETON_DIRECTIVE,\n  CAPABILITY_TYPE_ATTRIBUTE,\n  CAPABILITY_VERSION_ATTRIBUTE,\n  EXCLUDE_DIRECTIVE,\n  FILTER_DIRECTIVE,\n  FRAGMENT_HOST,\n  IDENTITY_NAMESPACE,\n  INCLUDE_DIRECTIVE,\n  PROVIDE_CAPABILITY,\n  REQUIRE_BUNDLE,\n  REQUIRE_CAPABILITY,\n  SINGLETON_DIRECTIVE,\n  TYPE_BUNDLE,\n  TYPE_FRAGMENT,\n  BundleManifestHeaders,\n  SemVer,\n} from '@pandino/pandino-api';\nimport { BundleCapabilityImpl } from '../../wiring/bundle-capability-impl';\nimport { ParsedHeaderClause } from './parsed-header-clause';\nimport { BundleRequirementImpl } from '../../wiring/bundle-requirement-impl';\nimport Filter, { FilterComp } from '../../../filter/filter';\nimport { isAnyMissing } from '../../../utils/helpers';\nimport { ManifestParser } from './manifest-parser';\nimport { BundleRequirement } from '../../wiring/bundle-requirement';\nimport { BundleCapability } from '../../wiring/bundle-capability';\nimport { BundleRevision } from '../../bundle-revision';\nimport { SemVerImpl } from '../../../utils/semver-impl';\n\nexport class ManifestParserImpl implements ManifestParser {\n  private readonly configMap: BundleConfigMap;\n  private readonly headerMap: Record<string, any>;\n  private readonly requirements: BundleRequirement[] = [];\n  private readonly capabilities: BundleCapability[] = [];\n  private readonly bundleSymbolicName: string;\n  private readonly bundleVersion: SemVer;\n  private activationIncludeDir: string;\n  private activationExcludeDir: string;\n  private activationPolicy: ActivationPolicy = 'EAGER_ACTIVATION';\n\n  static readonly EMPTY_VERSION = new SemVerImpl('0.0.0');\n\n  constructor(configMap: BundleConfigMap, owner: BundleRevision, headerMap: BundleManifestHeaders) {\n    this.configMap = configMap;\n    this.headerMap = headerMap;\n\n    const capList: Array<BundleCapabilityImpl> = [];\n\n    // Parse bundle version.\n    this.bundleVersion = ManifestParserImpl.EMPTY_VERSION;\n    if (headerMap[BUNDLE_VERSION] !== null && headerMap[BUNDLE_VERSION] !== undefined) {\n      try {\n        this.bundleVersion = new SemVerImpl(headerMap[BUNDLE_VERSION]);\n      } catch (ex) {\n        if (this.getManifestVersion() === '2') {\n          throw ex;\n        }\n        this.bundleVersion = ManifestParserImpl.EMPTY_VERSION;\n      }\n    }\n\n    // Parse bundle symbolic name.\n    const bundleCap: BundleCapabilityImpl = ManifestParserImpl.parseBundleSymbolicName(owner, this.headerMap);\n    if (bundleCap) {\n      this.bundleSymbolicName = bundleCap.getAttributes()[BUNDLE_NAMESPACE];\n\n      if (!headerMap[FRAGMENT_HOST]) {\n        capList.push(bundleCap);\n      }\n\n      capList.push(ManifestParserImpl.addIdentityCapability(owner, headerMap, bundleCap));\n    }\n\n    // Verify that bundle symbolic name is specified.\n    if (this.getManifestVersion() === '2' && !this.bundleSymbolicName) {\n      throw new Error('R4 bundle manifests must include bundle symbolic name.');\n    }\n\n    // Parse Require-Bundle\n    let rbClauses: Array<ParsedHeaderClause> = ManifestParserImpl.parseStandardHeader(headerMap[REQUIRE_BUNDLE]);\n    rbClauses = ManifestParserImpl.normalizeRequireClauses(rbClauses, this.getManifestVersion());\n    const rbReqs: Array<BundleRequirementImpl> = ManifestParserImpl.convertRequires(rbClauses, owner);\n\n    // Parse Require-Capability.\n    const requireCaps: Array<BundleRequirement> = [];\n    if (Array.isArray(headerMap[REQUIRE_CAPABILITY])) {\n      for (const part of headerMap[REQUIRE_CAPABILITY]) {\n        requireCaps.push(...ManifestParserImpl.getRequiredClauses(part.trim(), owner));\n      }\n    } else if (typeof headerMap[REQUIRE_CAPABILITY] === 'string') {\n      requireCaps.push(\n        ...ManifestParserImpl.getRequiredClauses((headerMap[REQUIRE_CAPABILITY] as string).trim(), owner),\n      );\n    }\n\n    // Parse Provide-Capability.\n    const provideCaps: Array<BundleCapability> = [];\n    if (Array.isArray(headerMap[PROVIDE_CAPABILITY])) {\n      for (const part of headerMap[PROVIDE_CAPABILITY]) {\n        provideCaps.push(...ManifestParserImpl.getProviderClauses(part.trim(), owner));\n      }\n    } else if (typeof headerMap[PROVIDE_CAPABILITY] === 'string') {\n      provideCaps.push(\n        ...ManifestParserImpl.getProviderClauses((headerMap[PROVIDE_CAPABILITY] as string).trim(), owner),\n      );\n    }\n\n    // Combine all requirements.\n    this.requirements = [];\n    this.requirements.push(...rbReqs);\n    this.requirements.push(...requireCaps);\n\n    // Combine all capabilities.\n    this.capabilities = [];\n    this.capabilities.push(...capList);\n    this.capabilities.push(...provideCaps);\n\n    // Parse activation policy.\n    this.parseActivationPolicy(headerMap);\n  }\n\n  private static getProviderClauses(part: string, owner: BundleRevision): Array<BundleCapability> {\n    let provideClauses: Array<ParsedHeaderClause> = ManifestParserImpl.parseStandardHeader(part);\n    provideClauses = ManifestParserImpl.normalizeCapabilityClauses(provideClauses);\n    return ManifestParserImpl.convertProvideCapabilities(provideClauses, owner);\n  }\n\n  private static getRequiredClauses(part: string, owner: BundleRevision): Array<BundleRequirement> {\n    let provideClauses: Array<ParsedHeaderClause> = ManifestParserImpl.parseStandardHeader(part);\n    provideClauses = ManifestParserImpl.normalizeCapabilityClauses(provideClauses);\n    return ManifestParserImpl.convertRequireCapabilities(provideClauses, owner);\n  }\n\n  getActivationIncludeDirective(): string {\n    return this.activationIncludeDir;\n  }\n  getActivationExcludeDirective(): string {\n    return this.activationExcludeDir;\n  }\n\n  getActivationPolicy(): ActivationPolicy {\n    return this.activationPolicy;\n  }\n\n  getSymbolicName(): string {\n    return this.bundleSymbolicName;\n  }\n\n  getBundleVersion(): SemVer {\n    return this.bundleVersion;\n  }\n\n  getName(path: string): string {\n    const idx = path.lastIndexOf('/');\n    return idx > -1 ? path.substring(idx) : path;\n  }\n\n  getCapabilities(): BundleCapability[] {\n    return this.capabilities;\n  }\n\n  getRequirements(): BundleRequirement[] {\n    return this.requirements;\n  }\n\n  static parseDelimitedString(value: string, delim: string, trim = true): string[] {\n    if (isAnyMissing(value)) {\n      value = '';\n    }\n\n    const list: string[] = [];\n\n    const CHAR = 1;\n    const DELIMITER = 2;\n    const STARTQUOTE = 4;\n    const ENDQUOTE = 8;\n\n    let sb = '';\n\n    let expecting = CHAR | DELIMITER | STARTQUOTE;\n\n    let isEscaped = false;\n    for (let i = 0; i < value.length; i++) {\n      const c = value.charAt(i);\n\n      const isDelimiter = delim.indexOf(c) >= 0;\n\n      if (!isEscaped && c == '\\\\') {\n        isEscaped = true;\n        continue;\n      }\n\n      if (isEscaped) {\n        sb += c;\n      } else if (isDelimiter && (expecting & DELIMITER) > 0) {\n        if (trim) {\n          list.push(sb.toString().trim());\n        } else {\n          list.push(sb.toString());\n        }\n        sb = '';\n        expecting = CHAR | DELIMITER | STARTQUOTE;\n      } else if (c == '\"' && (expecting & STARTQUOTE) > 0) {\n        sb += c;\n        expecting = CHAR | ENDQUOTE;\n      } else if (c == '\"' && (expecting & ENDQUOTE) > 0) {\n        sb += c;\n        expecting = CHAR | STARTQUOTE | DELIMITER;\n      } else if ((expecting & CHAR) > 0) {\n        sb += c;\n      } else {\n        throw new Error('Invalid delimited string: ' + value);\n      }\n\n      isEscaped = false;\n    }\n\n    if (sb.length > 0) {\n      if (trim) {\n        list.push(sb.toString().trim());\n      } else {\n        list.push(sb.toString());\n      }\n    }\n\n    return list;\n  }\n\n  getManifestVersion(): string {\n    const manifestVersion = ManifestParserImpl.getManifestVersion(this.headerMap);\n    return isAnyMissing(manifestVersion) ? '1' : manifestVersion;\n  }\n\n  private static getManifestVersion(headerMap: Record<string, any>): string {\n    const manifestVersion = headerMap[BUNDLE_MANIFESTVERSION] as string;\n    return isAnyMissing(manifestVersion) ? null : manifestVersion.trim();\n  }\n\n  private static parseBundleSymbolicName(\n    owner: BundleRevision,\n    headerMap: Record<string, any>,\n  ): BundleCapabilityImpl | undefined {\n    const clauses: Array<ParsedHeaderClause> = this.normalizeCapabilityClauses(\n      this.parseStandardHeader(headerMap[BUNDLE_SYMBOLICNAME]),\n    );\n    if (clauses.length > 0) {\n      if (clauses.length > 1) {\n        throw new Error('Cannot have multiple symbolic names: ' + headerMap[BUNDLE_SYMBOLICNAME]);\n      } else if (clauses[0].paths.length > 1) {\n        throw new Error('Cannot have multiple symbolic names: ' + headerMap[BUNDLE_SYMBOLICNAME]);\n      } else if (clauses[0].attrs.hasOwnProperty(BUNDLE_VERSION)) {\n        throw new Error('Cannot have a bundle version: ' + headerMap[BUNDLE_VERSION]);\n      }\n\n      // Get bundle version.\n      let bundleVersion = this.EMPTY_VERSION;\n      if (headerMap[BUNDLE_VERSION] !== null && headerMap[BUNDLE_VERSION] !== undefined) {\n        try {\n          bundleVersion = new SemVerImpl(headerMap[BUNDLE_VERSION]);\n        } catch (ex) {\n          let mv: string = this.getManifestVersion(headerMap);\n          if (mv !== null && mv !== undefined) {\n            throw ex;\n          }\n          bundleVersion = this.EMPTY_VERSION;\n        }\n      }\n\n      // Create a require capability and return it.\n      const symName: string = clauses[0].paths[0];\n      clauses[0].attrs[BUNDLE_NAMESPACE] = symName;\n      clauses[0].attrs[BUNDLE_VERSION_ATTRIBUTE] = bundleVersion;\n      return new BundleCapabilityImpl(owner, BUNDLE_NAMESPACE, clauses[0].dirs, clauses[0].attrs);\n    }\n\n    return undefined;\n  }\n\n  private static parseStandardHeader(header: string): ParsedHeaderClause[] {\n    const clauses: ParsedHeaderClause[] = [];\n\n    if (isAnyMissing(header)) {\n      return clauses;\n    }\n\n    if (!header.match(/[,;:=]/)) {\n      const clause = new ParsedHeaderClause([header], {}, {}, {});\n      clauses.push(clause);\n\n      return clauses;\n    }\n\n    const semiColons = header.split(';');\n\n    let clause: ParsedHeaderClause;\n    let dirs: Record<string, string> = {};\n    let attrs: Record<string, any> = {};\n    let types: Record<string, string> = {};\n\n    semiColons.forEach((value, index) => {\n      const trimValue = value.trim();\n\n      if (index === 0 && !trimValue.match(/[:=]/)) {\n        clause = new ParsedHeaderClause([trimValue], dirs, attrs, types);\n      }\n\n      const isDirective = trimValue.includes(':=');\n      const isAttribute = trimValue.includes('=');\n\n      if (isDirective) {\n        const [dirKey, dirValue] = trimValue.split(':=');\n\n        dirs[dirKey] = dirValue.trim().replace(/\"|\\\\\"/g, '').toString();\n      } else if (isAttribute) {\n        const [attrKey, attrValue] = trimValue.split('=');\n        const valueEscaped = attrValue.trim().replace(/\"|\\\\\"/g, '').toString();\n        const isCasted = attrKey.includes(':');\n\n        if (!isCasted) {\n          attrs[attrKey] = valueEscaped;\n        } else {\n          const [attrKeyTyped, attrType] = attrKey.split(':');\n          types[attrKeyTyped] = attrType;\n\n          if (attrType === 'number') {\n            attrs[attrKeyTyped] = Number(valueEscaped);\n          } else if (attrType === 'boolean') {\n            attrs[attrKeyTyped] = valueEscaped === 'true';\n          } else if (attrType === 'SemVer') {\n            attrs[attrKeyTyped] = new SemVerImpl(valueEscaped);\n          } else if (attrType.startsWith('Array')) {\n            attrs[attrKeyTyped] = valueEscaped;\n          } else {\n            attrs[attrKeyTyped] = valueEscaped;\n          }\n        }\n      }\n    });\n\n    clauses.push(clause);\n\n    return clauses;\n  }\n\n  private static normalizeCapabilityClauses(clauses: ParsedHeaderClause[]): ParsedHeaderClause[] {\n    for (const clause of clauses) {\n      for (const [key, type] of Object.entries(clause.types)) {\n        if (type !== 'string') {\n          if (type === 'number') {\n            clause.attrs[key] = Number(clause.attrs[key].toString().trim());\n          } else if (type === 'SemVer') {\n            clause.attrs[key] = new SemVerImpl(clause.attrs[key].toString().trim());\n          } else if (type.startsWith('Array')) {\n            let startIdx = type.indexOf('<');\n            let endIdx = type.indexOf('>');\n            if ((startIdx > 0 && endIdx <= startIdx) || (startIdx < 0 && endIdx > 0)) {\n              throw new Error(\"Invalid Provide-Capability attribute list type for '\" + key + \"' : \" + type);\n            }\n\n            let listType = 'string';\n            if (endIdx > startIdx) {\n              listType = type.substring(startIdx + 1, endIdx).trim();\n            }\n\n            const tokens: Array<string> = ManifestParserImpl.parseDelimitedString(\n              clause.attrs[key].toString().trim(),\n              ',',\n              false,\n            );\n            const values: Array<any> = [];\n            for (let token of tokens) {\n              if (listType === 'string') {\n                values.push(token);\n              } else if (listType === 'number') {\n                values.push(Number(token.trim()));\n              } else if (listType === 'SemVer') {\n                values.push(new SemVerImpl(token.trim()));\n              } else {\n                throw new Error(\"Unknown Provide-Capability attribute list type for '\" + key + \"' : \" + type);\n              }\n            }\n            clause.attrs[key] = values;\n          } else {\n            throw new Error(\"Unknown Provide-Capability attribute type for '\" + key + \"' : \" + type);\n          }\n        }\n      }\n    }\n\n    return clauses;\n  }\n\n  private static addIdentityCapability(\n    owner: BundleRevision,\n    headerMap: BundleConfigMap,\n    bundleCap: BundleCapabilityImpl,\n  ): BundleCapabilityImpl {\n    const attrs: BundleConfigMap = { ...bundleCap.getAttributes() };\n\n    attrs[IDENTITY_NAMESPACE] = bundleCap.getAttributes()[BUNDLE_NAMESPACE];\n    attrs[CAPABILITY_TYPE_ATTRIBUTE] = !headerMap[FRAGMENT_HOST] ? TYPE_BUNDLE : TYPE_FRAGMENT;\n    attrs[CAPABILITY_VERSION_ATTRIBUTE] = bundleCap.getAttributes()[BUNDLE_VERSION_ATTRIBUTE];\n\n    if (headerMap[BUNDLE_COPYRIGHT]) {\n      attrs[CAPABILITY_COPYRIGHT_ATTRIBUTE] = headerMap[BUNDLE_COPYRIGHT];\n    }\n\n    if (headerMap[BUNDLE_DESCRIPTION]) {\n      attrs[CAPABILITY_DESCRIPTION_ATTRIBUTE] = headerMap[BUNDLE_DESCRIPTION];\n    }\n\n    let dirs: Record<string, any>;\n    if (bundleCap.getDirectives()[SINGLETON_DIRECTIVE]) {\n      dirs = { [CAPABILITY_SINGLETON_DIRECTIVE]: bundleCap.getDirectives()[SINGLETON_DIRECTIVE] };\n    } else {\n      dirs = {};\n    }\n    return new BundleCapabilityImpl(owner, IDENTITY_NAMESPACE, dirs, attrs);\n  }\n\n  private static normalizeRequireClauses(clauses: ParsedHeaderClause[], mv: string): ParsedHeaderClause[] {\n    if (mv !== '2') {\n      clauses.length = 0;\n    } else {\n      for (const clause of clauses) {\n        let value = clause.attrs[BUNDLE_VERSION_ATTRIBUTE];\n        if (value !== null && value !== undefined) {\n          clause.attrs[BUNDLE_VERSION_ATTRIBUTE] = new SemVerImpl(value.toString());\n        }\n      }\n    }\n\n    return clauses;\n  }\n\n  private static convertRequires(clauses: ParsedHeaderClause[], owner: BundleRevision): BundleRequirementImpl[] {\n    const reqList: Array<BundleRequirementImpl> = [];\n    for (const clause of clauses) {\n      for (const path of clause.paths) {\n        const attrs: Record<string, any> = clause.attrs;\n        const newAttrs: Record<string, any> = {\n          [BUNDLE_NAMESPACE]: path,\n          ...attrs,\n          [BUNDLE_NAMESPACE]: path, // ensure it's not overwritten\n        };\n        const sf: Filter = Filter.convert(newAttrs);\n        const dirs: Record<string, string> = clause.dirs;\n        const newDirs: Record<string, string> = {\n          ...dirs,\n          FILTER_DIRECTIVE: sf.toString(),\n        };\n\n        reqList.push(new BundleRequirementImpl(owner, BUNDLE_NAMESPACE, newDirs, newAttrs));\n      }\n    }\n\n    return reqList;\n  }\n\n  private static convertRequireCapabilities(clauses: ParsedHeaderClause[], owner: BundleRevision): BundleRequirement[] {\n    const reqList: BundleRequirement[] = [];\n    for (const clause of clauses) {\n      try {\n        let filterStr: string = clause.dirs[FILTER_DIRECTIVE];\n        const sf: Filter = !!filterStr\n          ? Filter.parse(filterStr.trim().replace(/\"|\\\\\"/g, '').toString())\n          : new Filter(null, FilterComp.MATCH_ALL, null, []);\n        for (const path of clause.paths) {\n          if (path.startsWith('pandino.wiring.')) {\n            throw new Error(\"Manifest cannot use Require-Capability for '\" + path + \"' namespace.\");\n          }\n\n          reqList.push(new BundleRequirementImpl(owner, path, clause.dirs, clause.attrs, sf));\n        }\n      } catch (ex) {\n        throw new Error('Error creating requirement: ' + ex);\n      }\n    }\n\n    return reqList;\n  }\n\n  private static convertProvideCapabilities(clauses: ParsedHeaderClause[], owner: BundleRevision): BundleCapability[] {\n    const capList: Array<BundleCapability> = [];\n    for (const clause of clauses) {\n      for (const path of clause.paths) {\n        if (path.startsWith('pandino.wiring.')) {\n          throw new Error(\"Manifest cannot use Provide-Capability for '\" + path + \"' namespace.\");\n        }\n\n        capList.push(new BundleCapabilityImpl(owner, path, clause.dirs, clause.attrs));\n      }\n    }\n\n    return capList;\n  }\n\n  private parseActivationPolicy(headerMap: Record<string, any>): void {\n    this.activationPolicy = 'EAGER_ACTIVATION';\n\n    const clauses: Array<ParsedHeaderClause> = ManifestParserImpl.parseStandardHeader(\n      headerMap[BUNDLE_ACTIVATIONPOLICY],\n    );\n\n    if (clauses.length > 0) {\n      for (const path of clauses[0].paths) {\n        if (path === ACTIVATION_LAZY) {\n          this.activationPolicy = 'LAZY_ACTIVATION';\n          for (const [key, value] of Object.entries(clauses[0].dirs)) {\n            if (key.toLowerCase() === INCLUDE_DIRECTIVE.toLowerCase()) {\n              this.activationIncludeDir = value;\n            } else if (key.toLowerCase() === EXCLUDE_DIRECTIVE.toLowerCase()) {\n              this.activationExcludeDir = value;\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n","import { ActivationPolicy, Bundle, BundleManifestHeaders, SemVer } from '@pandino/pandino-api';\nimport { BundleImpl } from './bundle-impl';\nimport { ManifestParserImpl } from './util/manifest-parser/manifest-parser-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { Requirement } from './resource/requirement';\nimport { ManifestParser } from './util/manifest-parser/manifest-parser';\nimport { Capability } from './resource/capability';\nimport { BundleWiring } from './bundle-wiring';\nimport { BundleRevision } from './bundle-revision';\nimport { Resource } from './resource/resource';\nimport { BundleCapability } from './wiring/bundle-capability';\nimport { BundleRequirement } from './wiring/bundle-requirement';\n\nexport class BundleRevisionImpl implements BundleRevision, Resource {\n  private readonly id: string;\n  private readonly headerMap: Record<string, any>;\n  private readonly manifestVersion: string;\n  private readonly symbolicName: string;\n  private readonly version: SemVer;\n  private readonly declaredCaps: Array<BundleCapability> = [];\n  private readonly declaredReqs: Array<BundleRequirement> = [];\n\n  private readonly bundle: BundleImpl;\n  private readonly declaredActivationPolicy: ActivationPolicy;\n  private wiring?: BundleWiring;\n\n  constructor(bundle: BundleImpl, id: string, headerMap?: BundleManifestHeaders) {\n    this.bundle = bundle;\n    this.id = id;\n    this.headerMap = headerMap;\n\n    const mp: ManifestParser = new ManifestParserImpl(bundle.getFramework().getConfig(), this, headerMap);\n\n    this.manifestVersion = mp.getManifestVersion();\n    this.version = mp.getBundleVersion();\n    this.declaredCaps = mp.getCapabilities();\n    this.declaredReqs = mp.getRequirements();\n    this.declaredActivationPolicy = mp.getActivationPolicy();\n    this.symbolicName = mp.getSymbolicName();\n  }\n\n  getDeclaredActivationPolicy(): ActivationPolicy {\n    return this.declaredActivationPolicy;\n  }\n\n  equals(other: any): boolean {\n    if (isAnyMissing(other) || !(other instanceof BundleRevisionImpl)) {\n      return false;\n    }\n    return this.getSymbolicName() === other.getSymbolicName() && this.getVersion().compare(other.getVersion()) === 0;\n  }\n\n  getBundle(): Bundle {\n    return this.bundle;\n  }\n\n  getCapabilities(namespace?: string): Capability[] {\n    let result = this.declaredCaps;\n    if (!isAnyMissing(namespace)) {\n      result = this.declaredCaps.filter((cap) => cap.getNamespace() === namespace);\n    }\n    return result;\n  }\n\n  getDeclaredCapabilities(namespace?: string): BundleCapability[] {\n    let result = this.declaredCaps;\n    if (!isAnyMissing(namespace)) {\n      result = this.declaredCaps.filter((cap) => cap.getNamespace() === namespace);\n    }\n    return result;\n  }\n\n  getDeclaredRequirements(namespace?: string): BundleRequirement[] {\n    let result = this.declaredReqs;\n    if (isAllPresent(namespace)) {\n      result = this.declaredReqs.filter((req) => req.getNamespace() === namespace);\n    }\n    return result;\n  }\n\n  getRequirements(namespace?: string): Requirement[] {\n    return this.getDeclaredRequirements(namespace);\n  }\n\n  getSymbolicName(): string {\n    return this.symbolicName;\n  }\n\n  getVersion(): SemVer {\n    return this.version;\n  }\n\n  getWiring(): BundleWiring | undefined {\n    return this.wiring;\n  }\n\n  getHeaders(): Record<string, any> {\n    return { ...this.headerMap };\n  }\n\n  getManifestVersion(): string {\n    return this.manifestVersion;\n  }\n\n  getId(): string {\n    return this.id;\n  }\n\n  resolve(wiring?: BundleWiring): void {\n    this.wiring = wiring;\n  }\n\n  toString(): string {\n    return this.bundle + ' (R ' + this.id + ')';\n  }\n}\n","import {\n  Bundle,\n  BundleActivator,\n  BundleContext,\n  BundleManifestHeaders,\n  BundleState,\n  Logger,\n  BUNDLE_ACTIVATOR,\n  ServiceReference,\n  SemVer,\n} from '@pandino/pandino-api';\nimport { Pandino } from '../../pandino';\nimport { BundleRevisionImpl } from './bundle-revision-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { BundleRevision } from './bundle-revision';\nimport { SemVerImpl } from '../utils/semver-impl';\nimport { equal } from '../semver-lite/src';\n\nexport class BundleImpl implements Bundle {\n  private readonly id: number;\n  private readonly manifestLocation: string;\n  private readonly deploymentRoot?: string;\n  private readonly headers: BundleManifestHeaders;\n  private readonly pandino?: Pandino;\n  private readonly installingBundle?: Bundle;\n  private readonly useDeclaredActivationPolicy: boolean;\n  private activator: BundleActivator;\n  private context: BundleContext;\n  private state: BundleState;\n  private readonly revisions: BundleRevisionImpl[] = [];\n  private currentRevision: BundleRevisionImpl;\n  protected readonly logger: Logger;\n\n  constructor(\n    logger: Logger,\n    id: number,\n    headers: BundleManifestHeaders,\n    manifestLocation: string,\n    deploymentRoot?: string,\n    pandino?: Pandino,\n    installingBundle?: Bundle,\n  ) {\n    this.logger = logger;\n    this.id = id;\n    this.deploymentRoot = deploymentRoot;\n    this.manifestLocation = manifestLocation;\n    this.useDeclaredActivationPolicy = false;\n    this.state = 'INSTALLED';\n    this.headers = headers;\n    this.pandino = pandino;\n    this.installingBundle = installingBundle;\n    if (\n      isAllPresent(headers[BUNDLE_ACTIVATOR]) &&\n      typeof (headers[BUNDLE_ACTIVATOR] as BundleActivator).start === 'function'\n    ) {\n      this.activator = headers[BUNDLE_ACTIVATOR] as BundleActivator;\n    }\n    if (isAllPresent(pandino)) {\n      const revision = this.createRevision();\n      this.addRevision(revision);\n    }\n  }\n\n  getRegisteredServices(): ServiceReference<any>[] {\n    return this.getFramework().getBundleRegisteredServices(this);\n  }\n\n  getServicesInUse(): ServiceReference<any>[] {\n    throw new Error('Method not implemented.');\n  }\n\n  getBundleId(): number {\n    return this.id;\n  }\n\n  getBundleContext(): BundleContext {\n    return this.context;\n  }\n\n  setBundleContext(context: BundleContext): void {\n    this.context = context;\n  }\n\n  getHeaders(): BundleManifestHeaders {\n    return this.headers;\n  }\n\n  getState(): BundleState {\n    return this.state;\n  }\n\n  setState(state: BundleState): void {\n    this.state = state;\n  }\n\n  getSymbolicName(): string {\n    return this.getCurrentRevision().getSymbolicName();\n  }\n\n  getVersion(): SemVer {\n    return this.getCurrentRevision().getVersion();\n  }\n\n  async start(options?: BundleState): Promise<void> {\n    await this.getFramework().startBundle(this);\n  }\n\n  async stop(options?: BundleState): Promise<void> {\n    await this.getFramework().stopBundle(this);\n  }\n\n  async uninstall(): Promise<void> {\n    return this.getFramework().uninstallBundle(this);\n  }\n\n  async update(headers: BundleManifestHeaders, bundle?: Bundle): Promise<void> {\n    await this.getFramework().updateBundle(this, headers, bundle);\n  }\n\n  getUniqueIdentifier(): string {\n    return this.getSymbolicName() + '-' + this.getVersion().toString();\n  }\n\n  getActivator(): BundleActivator {\n    return this.activator;\n  }\n\n  setActivator(activator: BundleActivator): void {\n    this.activator = activator;\n  }\n\n  getDeploymentRoot(): string | undefined {\n    return this.deploymentRoot;\n  }\n\n  revise(headers: BundleManifestHeaders): void {\n    const updatedRevision = this.createRevision(headers);\n    this.addRevision(updatedRevision);\n  }\n\n  async refresh(): Promise<void> {\n    const current = this.getCurrentRevision();\n\n    if (this.isRemovalPending()) {\n      this.closeRevisions();\n    } else {\n      this.getFramework().getResolver().removeRevision(current);\n      current.resolve(null);\n    }\n\n    this.revisions.length = 0;\n    this.addRevision(current);\n    this.state = 'INSTALLED';\n  }\n\n  private createRevision(headers?: BundleManifestHeaders): BundleRevisionImpl {\n    const revision = new BundleRevisionImpl(\n      this,\n      this.getBundleId() + '.' + this.revisions.length,\n      headers || this.headers,\n    );\n\n    let bundleVersion = revision.getVersion();\n    bundleVersion = isAnyMissing(bundleVersion) ? new SemVerImpl('0.0.0') : bundleVersion;\n    const symName = revision.getSymbolicName();\n\n    const collisionCandidates: Array<Bundle> = [];\n    const bundles = this.getFramework().getBundles();\n    for (let i = 0; Array.isArray(bundles) && i < bundles.length; i++) {\n      const id = (bundles[i] as BundleImpl).getBundleId();\n      if (id !== this.getBundleId()) {\n        if (symName === bundles[i].getSymbolicName() && equal(bundleVersion, bundles[i].getVersion())) {\n          collisionCandidates.push(bundles[i]);\n        }\n      }\n    }\n    if (collisionCandidates.length && isAllPresent(this.installingBundle)) {\n      throw new Error('Bundle symbolic name and version are not unique: ' + symName + ':' + bundleVersion);\n    }\n\n    return revision;\n  }\n\n  private closeRevisions(): void {\n    for (const br of this.revisions) {\n      this.getFramework().getResolver().removeRevision(br);\n    }\n  }\n\n  isRemovalPending(): boolean {\n    return this.state === 'UNINSTALLED' || this.revisions.length > 1;\n  }\n\n  addRevision(revision: BundleRevisionImpl): void {\n    this.revisions.unshift(revision);\n    this.currentRevision = revision;\n\n    this.getFramework().getResolver().addRevision(revision);\n  }\n\n  getFramework(): Pandino {\n    return this.pandino;\n  }\n\n  getCurrentRevision(): BundleRevisionImpl {\n    return this.currentRevision;\n  }\n\n  getRevisions(): BundleRevision[] {\n    return this.revisions;\n  }\n\n  getLocation(): string {\n    return this.manifestLocation;\n  }\n\n  toString(): string {\n    return `${this.getSymbolicName()}: ${this.getVersion().toString()}`;\n  }\n}\n","import {\n  Bundle,\n  BundleContext,\n  BundleListener,\n  ServiceListener,\n  FilterApi,\n  FrameworkListener,\n} from '@pandino/pandino-api';\n\nexport class ListenerInfo {\n  private readonly bundle: Bundle;\n  private readonly context: BundleContext;\n  private readonly listener: ServiceListener | BundleListener | FrameworkListener;\n  private readonly filter: FilterApi;\n\n  constructor(\n    info?: ListenerInfo,\n    bundle?: Bundle,\n    context?: BundleContext,\n    listener?: ServiceListener | BundleListener | FrameworkListener,\n    filter?: FilterApi,\n  ) {\n    if (info) {\n      this.bundle = info.bundle;\n      this.context = info.context;\n      this.listener = info.listener;\n      this.filter = info.filter;\n    } else {\n      this.bundle = bundle;\n      this.context = context;\n      this.listener = listener;\n      this.filter = filter;\n    }\n  }\n\n  public getBundle(): Bundle {\n    return this.bundle;\n  }\n\n  public getBundleContext(): BundleContext {\n    return this.context;\n  }\n\n  public getListener(): ServiceListener | BundleListener | FrameworkListener {\n    return this.listener;\n  }\n\n  public getParsedFilter(): FilterApi {\n    return this.filter;\n  }\n\n  public getFilter(): string | undefined {\n    if (!!this.filter) {\n      return this.filter.toString();\n    }\n    return undefined;\n  }\n}\n","import { ServiceEvent, ServiceEventType, ServiceReference, SERVICE_ID } from '@pandino/pandino-api';\n\nexport class ServiceEventImpl implements ServiceEvent {\n  constructor(private readonly type: ServiceEventType, private readonly reference: ServiceReference<any>) {}\n\n  getServiceReference(): ServiceReference<any> {\n    return this.reference;\n  }\n\n  getType(): ServiceEventType {\n    return this.type;\n  }\n\n  toString(): string {\n    return `Service: ${this.reference.getProperty(SERVICE_ID)} changed state to: ${this.type}.`;\n  }\n}\n","import {\n  BundleContext,\n  BundleEvent,\n  BundleListener,\n  ServiceEvent,\n  ServiceListener,\n  Logger,\n  FilterApi,\n  FrameworkEvent,\n  FrameworkListener,\n  Bundle,\n  BundleState,\n} from '@pandino/pandino-api';\nimport { ListenerInfo } from './util/listener-info';\nimport { BundleImpl } from './bundle-impl';\nimport { BundleEventImpl } from './bundle-event-impl';\nimport { FrameworkEventImpl } from './framework-event-impl';\nimport { ServiceEventImpl } from './service-event-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { CapabilitySet } from './capability-set/capability-set';\nimport { Capability } from './resource/capability';\nimport Filter from '../filter/filter';\n\nexport type ListenerType = 'BUNDLE' | 'FRAMEWORK' | 'SERVICE';\n\nexport class EventDispatcher {\n  private readonly logger: Logger;\n  private svcListeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>();\n  private bndListeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>();\n  private fwkListeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>();\n\n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n\n  fireServiceEvent(event: ServiceEvent, oldProps: Record<string, any>): void {\n    const listeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(\n      this.svcListeners.entries(),\n    );\n\n    EventDispatcher.fireEventImmediately('SERVICE', listeners, event, oldProps);\n  }\n\n  fireFrameworkEvent(event: FrameworkEvent, source: BundleImpl): void {\n    const listeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(\n      this.fwkListeners.entries(),\n    );\n\n    EventDispatcher.fireEventImmediately('FRAMEWORK', listeners, event, source);\n  }\n\n  fireBundleEvent(event: BundleEvent, source?: BundleImpl): void {\n    const listeners: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(\n      this.bndListeners.entries(),\n    );\n\n    EventDispatcher.fireEventImmediately('BUNDLE', listeners, event, source);\n  }\n\n  private static fireEventImmediately(\n    type: ListenerType,\n    listeners: Map<BundleContext, Array<ListenerInfo>>,\n    event: any,\n    oldProps?: Record<string, any>,\n  ): void {\n    for (let [ctx, lstnrs] of listeners.entries()) {\n      for (let info of lstnrs) {\n        const bundle = info.getBundle();\n        const listener = info.getListener();\n        const filter: FilterApi = info.getParsedFilter();\n\n        switch (type) {\n          case 'FRAMEWORK':\n            EventDispatcher.invokeFrameworkListenerCallback(bundle, listener as FrameworkListener, event);\n            break;\n          case 'BUNDLE':\n            EventDispatcher.invokeBundleListenerCallback(bundle, listener as BundleListener, event);\n            break;\n          case 'SERVICE':\n            EventDispatcher.invokeServiceListenerCallback(bundle, listener as ServiceListener, event, filter, oldProps);\n            break;\n          default:\n            throw new Error(`Unhandled event type: ${type}!`);\n        }\n      }\n    }\n  }\n\n  private static invokeServiceListenerCallback(\n    bundle: Bundle,\n    listener: ServiceListener,\n    event: ServiceEventImpl,\n    filter?: FilterApi,\n    oldProps?: Record<string, any>,\n  ): void {\n    const validBundleStateTypes: BundleState[] = ['STARTING', 'STOPPING', 'ACTIVE'];\n    if (!validBundleStateTypes.includes(bundle.getState())) {\n      return;\n    }\n\n    let matched =\n      isAnyMissing(filter) ||\n      CapabilitySet.matches(event.getServiceReference() as unknown as Capability, filter as Filter);\n\n    if (matched) {\n      listener.serviceChanged(event);\n    } else if (event.getType() == 'MODIFIED') {\n      if (!!filter && filter.match(oldProps)) {\n        let se = new ServiceEventImpl('MODIFIED_ENDMATCH', event.getServiceReference());\n        if (listener.isSync) {\n          listener.serviceChanged(se);\n        } else {\n          setTimeout(() => listener.serviceChanged(se), 0);\n        }\n      }\n    }\n  }\n\n  private static invokeBundleListenerCallback(bundle: Bundle, listener: BundleListener, event: BundleEventImpl): void {\n    const validSyncEventBundleStateTypes: BundleState[] = ['STARTING', 'STOPPING', 'ACTIVE'];\n    if (validSyncEventBundleStateTypes.includes(bundle.getState())) {\n      if (listener.isSync) {\n        listener.bundleChanged(event);\n      } else {\n        setTimeout(() => listener.bundleChanged(event), 0);\n      }\n    }\n  }\n\n  private static invokeFrameworkListenerCallback(\n    bundle: Bundle,\n    listener: FrameworkListener,\n    event: FrameworkEventImpl,\n  ): void {\n    const validBundleStateTypes: BundleState[] = ['STARTING', 'ACTIVE'];\n    if (validBundleStateTypes.includes(bundle.getState())) {\n      if (listener.isSync) {\n        listener.frameworkEvent(event);\n      } else {\n        setTimeout(() => listener.frameworkEvent(event), 0);\n      }\n    }\n  }\n\n  addListener?(bc: BundleContext, type: ListenerType, listener: any, filter?: FilterApi): FilterApi | undefined {\n    if (!listener) {\n      throw new Error('Listener is missing');\n    }\n\n    const oldFilter = this.updateListener(bc, type, listener, filter);\n\n    if (oldFilter) {\n      return oldFilter;\n    }\n\n    try {\n      bc.getBundle();\n    } catch (ex) {\n      // Bundle context is no longer valid, so just return.\n      return undefined;\n    }\n\n    let listeners: Map<BundleContext, Array<ListenerInfo>> = null;\n\n    if (type === 'FRAMEWORK') {\n      listeners = this.fwkListeners;\n    } else if (type === 'BUNDLE') {\n      listeners = this.bndListeners;\n    } else if (type === 'SERVICE') {\n      listeners = this.svcListeners;\n    } else {\n      throw new Error('Unknown listener: ' + type);\n    }\n\n    const info: ListenerInfo = new ListenerInfo(null, bc.getBundle(), bc, listener, filter);\n    listeners = EventDispatcher.addListenerInfo(listeners, info);\n\n    if (type === 'FRAMEWORK') {\n      this.fwkListeners = listeners;\n    } else if (type === 'BUNDLE') {\n      this.bndListeners = listeners;\n    } else if (type === 'SERVICE') {\n      this.svcListeners = listeners;\n    }\n\n    return undefined;\n  }\n\n  removeListener(bc: BundleContext, type: ListenerType, listener: any): void {\n    let listeners: Map<BundleContext, Array<ListenerInfo>> = null;\n\n    if (!listener) {\n      throw new Error('Listener is missing');\n    }\n\n    if (type === 'FRAMEWORK') {\n      listeners = this.fwkListeners;\n    } else if (type === 'BUNDLE') {\n      listeners = this.bndListeners;\n    } else if (type === 'SERVICE') {\n      listeners = this.svcListeners;\n    } else {\n      throw new Error('Unknown listener: ' + type);\n    }\n\n    // Try to find the instance in our list.\n    let idx: number = -1;\n    for (let [bc, infos] of listeners.entries()) {\n      for (let i = 0; i < infos.length; i++) {\n        let info: ListenerInfo = infos[i];\n        if (info.getBundleContext().equals(bc) && info.getListener() === listener) {\n          idx = i;\n          break;\n        }\n      }\n    }\n\n    if (idx >= 0) {\n      listeners = EventDispatcher.removeListenerInfo(listeners, bc, idx);\n    }\n\n    if (type === 'FRAMEWORK') {\n      this.fwkListeners = listeners;\n    } else if (type === 'BUNDLE') {\n      this.bndListeners = listeners;\n    } else if (type === 'SERVICE') {\n      this.svcListeners = listeners;\n    }\n  }\n\n  removeListeners(bc: BundleContext): void {\n    this.fwkListeners = EventDispatcher.removeListenerInfos(this.fwkListeners, bc);\n    this.bndListeners = EventDispatcher.removeListenerInfos(this.bndListeners, bc);\n    this.svcListeners = EventDispatcher.removeListenerInfos(this.svcListeners, bc);\n  }\n\n  private static removeListenerInfos(\n    listeners: Map<BundleContext, Array<ListenerInfo>>,\n    bc: BundleContext,\n  ): Map<BundleContext, Array<ListenerInfo>> {\n    const copy: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(\n      listeners.entries(),\n    );\n    copy.delete(bc);\n    return copy;\n  }\n\n  private static removeListenerInfo(\n    listeners: Map<BundleContext, Array<ListenerInfo>>,\n    bc: BundleContext,\n    idx: number,\n  ): Map<BundleContext, Array<ListenerInfo>> {\n    const copy: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(\n      listeners.entries(),\n    );\n    const infos: Array<ListenerInfo> = [...copy.get(bc)];\n    copy.delete(bc);\n    if (Array.isArray(infos)) {\n      infos.splice(idx, 1);\n      if (infos.length > 0) {\n        copy.set(bc, infos);\n      }\n      return copy;\n    }\n    return listeners;\n  }\n\n  updateListener(bc: BundleContext, type: ListenerType, listener: any, filter?: FilterApi): FilterApi | undefined {\n    if (type === 'SERVICE') {\n      // Verify that the bundle context is still valid.\n      try {\n        bc.getBundle();\n      } catch (err) {\n        return undefined;\n      }\n\n      const infos: Array<ListenerInfo> = this.svcListeners.get(bc);\n      for (let i = 0; isAllPresent(infos) && i < infos.length; i++) {\n        const info: ListenerInfo = infos[i];\n        if (info.getBundleContext().equals(bc) && info.getListener() === listener) {\n          // The spec says to update the filter in this case.\n          const oldFilter = info.getParsedFilter();\n          const newInfo = new ListenerInfo(null, info.getBundle(), info.getBundleContext(), info.getListener(), filter);\n          this.svcListeners = EventDispatcher.updateListenerInfo(this.svcListeners, i, newInfo);\n          return oldFilter;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private static updateListenerInfo(\n    listeners: Map<BundleContext, Array<ListenerInfo>>,\n    idx: number,\n    info: ListenerInfo,\n  ): Map<BundleContext, Array<ListenerInfo>> {\n    let copy: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(listeners);\n    let infos: Array<ListenerInfo> = copy.get(info.getBundleContext());\n    copy.delete(info.getBundleContext());\n    if (isAllPresent(infos)) {\n      infos = [...infos];\n      infos[idx] = info;\n      copy.set(info.getBundleContext(), infos);\n      return copy;\n    }\n    return listeners;\n  }\n\n  private static addListenerInfo(\n    listeners: Map<BundleContext, Array<ListenerInfo>>,\n    info: ListenerInfo,\n  ): Map<BundleContext, Array<ListenerInfo>> {\n    if (!listeners.has(info.getBundleContext())) {\n      listeners.set(info.getBundleContext(), []);\n    }\n    const infos = listeners.get(info.getBundleContext());\n\n    infos.push(info);\n\n    return listeners;\n  }\n\n  // private static updateListenerInfo(\n  //   listeners: Map<BundleContext, Array<ListenerInfo>>,\n  //   idx: number,\n  //   info: ListenerInfo,\n  // ): Map<BundleContext, Array<ListenerInfo>> {\n  //   const copy: Map<BundleContext, Array<ListenerInfo>> = new Map<BundleContext, Array<ListenerInfo>>(listeners.entries());\n  //   let infos: Array<ListenerInfo> = copy.get(info.getBundleContext());\n  //\n  //   copy.delete(info.getBundleContext());\n  //\n  //   if (Array.isArray(infos)) {\n  //     infos = [...infos];\n  //     infos[idx] = info;\n  //     copy.set(info.getBundleContext(), infos);\n  //\n  //     return copy;\n  //   }\n  //\n  //   return listeners;\n  // }\n}\n","import { ServiceObjects, ServiceReference } from '@pandino/pandino-api';\nimport { Pandino } from '../../pandino';\nimport { BundleContextImpl } from './bundle-context-impl';\nimport { isAllPresent } from '../utils/helpers';\n\nexport class ServiceObjectsImpl<S> implements ServiceObjects<S> {\n  private readonly ref: ServiceReference<S>;\n  private readonly context: BundleContextImpl;\n  private readonly pandino: Pandino;\n\n  constructor(ref: ServiceReference<S>, context: BundleContextImpl, pandino: Pandino) {\n    this.ref = ref;\n    this.context = context;\n    this.pandino = pandino;\n  }\n\n  getService(): S | undefined {\n    this.context.checkValidity();\n\n    return this.pandino.getService(this.context.getBundle(), this.ref, true);\n  }\n\n  getServiceReference(): ServiceReference<S> {\n    return this.ref;\n  }\n\n  ungetService(service: S): void {\n    this.context.checkValidity();\n\n    if (isAllPresent(this.ref.getBundle()) && !this.pandino.ungetService(this.ref.getBundle(), this.ref, service)) {\n      throw new Error(`Cannot unget service: ${service}`);\n    }\n  }\n}\n","import { isAnyMissing } from '../utils/helpers';\n\nexport /**\n * Abstract class to track items. If a Tracker is reused (closed then reopened), then a new AbstractTracked object is\n * used. This class acts a map of tracked item -> customized object. Subclasses of this class will act as the listener\n * object for the tracker. This class is used to synchronize access to the tracked items. This is not a public class. It\n * is only for use by the implementation of the Tracker class.\n *\n * @param <S> The tracked item. It is the key.\n * @param <T> The value mapped to the tracked item.\n * @param <R> The reason the tracked item is being tracked or untracked.\n */\nabstract class AbstractTracked<S, T, R> {\n  closed = false;\n  private trackingCount = 0;\n  private tracked: Map<S, T> = new Map<S, T>();\n  private adding: Array<S> = [];\n  private initial: Array<S> = [];\n\n  /**\n   * Call the specific customizer adding method.\n   *\n   * @param item <S> Item to be tracked.\n   * @param related <R> Action related object.\n   * @return <T> Customized object for the tracked item or {@code undefined} if the item is not to be tracked.\n   */\n  abstract customizerAdding(item: S, related?: R): T | undefined;\n\n  /**\n   * Call the specific customizer modified method.\n   *\n   * @param item <S> Tracked item.\n   * @param object <T> Customized object for the tracked item.\n   * @param related <R> Action related object.\n   */\n  abstract customizerModified(item: S, object: T, related?: R): void;\n\n  /**\n   * Call the specific customizer removed method.\n   *\n   * @param item <S> Tracked item.\n   * @param object <T> Customized object for the tracked item.\n   * @param related <R> Action related object.\n   */\n  abstract customizerRemoved(item: S, object: T, related?: R): void;\n\n  setInitial(list: S[] = []): void {\n    for (const item of list) {\n      if (!item) {\n        continue;\n      }\n      this.initial.push(item);\n    }\n  }\n\n  trackInitial(): void {\n    while (true) {\n      let item: S;\n      if (this.closed || this.initial.length === 0) {\n        return;\n      }\n      item = this.initial[0];\n      this.initial.splice(0, 1);\n      if (this.tracked.get(item)) {\n        continue;\n      }\n      if (this.adding.includes(item)) {\n        continue;\n      }\n      this.adding.push(item);\n      this.trackAdding(item, undefined);\n    }\n  }\n\n  close(): void {\n    this.closed = true;\n  }\n\n  track(item: S, related?: R): void {\n    let object: T;\n    if (this.closed) {\n      return;\n    }\n    object = this.tracked.get(item);\n    if (isAnyMissing(object)) {\n      if (this.adding.includes(item)) {\n        return;\n      }\n      this.adding.push(item);\n    } else {\n      this.modified();\n    }\n    if (isAnyMissing(object)) {\n      this.trackAdding(item, related);\n    } else {\n      this.customizerModified(item, object, related);\n    }\n  }\n\n  untrack(item: S, related?: R): void {\n    let object: T;\n    const initialIdx = this.initial.findIndex((i) => i === item);\n    if (initialIdx > -1) {\n      this.initial.splice(initialIdx, 1);\n      return;\n    }\n    const addingIdx = this.adding.findIndex((a) => a === item);\n    if (addingIdx > -1) {\n      this.adding.splice(addingIdx, 1);\n      return;\n    }\n    object = this.tracked.get(item);\n    this.tracked.delete(item);\n    if (isAnyMissing(object)) {\n      return;\n    }\n    this.modified();\n    this.customizerRemoved(item, object, related);\n  }\n\n  size(): number {\n    return this.tracked.size;\n  }\n\n  isEmpty(): boolean {\n    return this.size() === 0;\n  }\n\n  getCustomizedObject(item: S): T {\n    return this.tracked.get(item);\n  }\n\n  copyKeys(list: S[]): S[] {\n    return [...list, ...Array.from(this.tracked.keys())];\n  }\n\n  modified(): void {\n    this.trackingCount++;\n  }\n\n  getTrackingCount(): number {\n    return this.trackingCount;\n  }\n\n  private trackAdding(item: S, related?: R): void {\n    let object: T;\n    let becameUntracked = false;\n    try {\n      object = this.customizerAdding(item, related);\n    } finally {\n      const idx = this.adding.findIndex((a) => a === item);\n      if (idx > -1 && !this.closed) {\n        this.adding.splice(idx, 1);\n        if (object) {\n          this.tracked.set(item, object);\n          this.modified();\n        }\n      } else {\n        becameUntracked = true;\n      }\n    }\n\n    if (becameUntracked && object) {\n      this.customizerRemoved(item, object, related);\n    }\n  }\n}\n","import {\n  Bundle,\n  BundleContext,\n  BundleEvent,\n  BundleListener,\n  BundleState,\n  BundleTracker,\n  BundleTrackerCustomizer,\n} from '@pandino/pandino-api';\nimport { AbstractTracked } from './abstract-tracked';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\n\nexport class BundleTrackerImpl<T> implements BundleTracker<T> {\n  readonly customizer: BundleTrackerCustomizer<T>;\n  private readonly context: BundleContext;\n  private readonly trackedStates: BundleState[] = [];\n  private tracked: Tracked<T>;\n\n  constructor(context: BundleContext, trackedStates: BundleState[], customizer?: BundleTrackerCustomizer<T>) {\n    this.context = context;\n    this.trackedStates = trackedStates;\n    this.customizer = customizer || this;\n  }\n\n  open(): void {\n    if (isAllPresent(this.tracked)) {\n      return;\n    }\n\n    const t: Tracked<T> = new Tracked(this);\n\n    this.context.addBundleListener(t);\n\n    const bundles = this.context.getBundles();\n\n    if (bundles && bundles.length) {\n      const length = bundles.length;\n      for (let i = 0; i < length; i++) {\n        const state = bundles[i].getState();\n        if (this.getTrackedStates().includes(state)) {\n          /* undefined out bundles whose states are not interesting */\n          bundles[i] = undefined;\n        }\n      }\n      /* set tracked with the initial bundles */\n      t.setInitial(bundles);\n    }\n\n    this.tracked = t;\n\n    t.trackInitial();\n  }\n\n  close(): void {\n    const outgoing: Tracked<T> = this.tracked;\n    let bundles: Bundle[];\n\n    if (isAnyMissing(outgoing)) {\n      return;\n    }\n\n    outgoing.close();\n    bundles = this.getBundles();\n\n    this.tracked = undefined;\n\n    try {\n      this.context.removeBundleListener(outgoing);\n    } catch (_) {\n      /* In case the context was stopped. */\n    }\n\n    if (Array.isArray(bundles)) {\n      for (const bundle of bundles) {\n        outgoing.untrack(bundle, undefined);\n      }\n    }\n  }\n\n  addingBundle(bundle: Bundle, event: BundleEvent): T {\n    return bundle as unknown as T;\n  }\n\n  modifiedBundle(bundle: Bundle, event: BundleEvent, object: T): void {\n    /* do nothing */\n  }\n\n  removedBundle(bundle: Bundle, event: BundleEvent, object: T): void {\n    /* do nothing */\n  }\n\n  getBundles(): Bundle[] {\n    if (isAnyMissing(this.tracked)) {\n      return [];\n    }\n    if (this.tracked.isEmpty()) {\n      return [];\n    }\n    return this.tracked.copyKeys([]);\n  }\n\n  getObject(bundle: Bundle): T | undefined {\n    if (isAnyMissing(this.tracked)) {\n      return undefined;\n    }\n    return this.tracked.getCustomizedObject(bundle);\n  }\n\n  remove(bundle: Bundle): void {\n    if (isAnyMissing(this.tracked)) {\n      return;\n    }\n    this.tracked.untrack(bundle, undefined);\n  }\n\n  size(): number {\n    if (isAnyMissing(this.tracked)) {\n      return 0;\n    }\n    return this.tracked.size();\n  }\n\n  getTrackingCount(): number {\n    if (isAnyMissing(this.tracked)) {\n      return -1;\n    }\n    return this.tracked.getTrackingCount();\n  }\n\n  isEmpty(): boolean {\n    if (isAnyMissing(this.tracked)) {\n      return true;\n    }\n    return this.tracked.isEmpty();\n  }\n\n  getTrackedStates(): BundleState[] {\n    return this.trackedStates;\n  }\n}\n\nclass Tracked<T> extends AbstractTracked<Bundle, T, BundleEvent> implements BundleListener {\n  isSync = true;\n\n  private tracker: BundleTracker<T>;\n\n  constructor(tracker: BundleTracker<T>) {\n    super();\n    this.tracker = tracker;\n  }\n\n  customizerAdding(item: Bundle, related: BundleEvent | undefined): T | undefined {\n    return (this.tracker as BundleTrackerImpl<T>).customizer.addingBundle(item, related);\n  }\n\n  customizerModified(item: Bundle, object: T, related: BundleEvent | undefined): void {\n    (this.tracker as BundleTrackerImpl<T>).customizer.modifiedBundle(item, related, object);\n  }\n\n  customizerRemoved(item: Bundle, object: T, related: BundleEvent | undefined): void {\n    (this.tracker as BundleTrackerImpl<T>).customizer.removedBundle(item, related, object);\n  }\n\n  bundleChanged(event: BundleEvent): void {\n    if (this.closed) {\n      return;\n    }\n    const bundle = event.getBundle();\n    const state = bundle.getState();\n\n    if ((this.tracker as BundleTrackerImpl<T>).getTrackedStates().includes(state)) {\n      this.track(bundle, event);\n      /*\n       * If the customizer throws an unchecked exception, it is safe\n       * to let it propagate\n       */\n    } else {\n      this.untrack(bundle, event);\n      /*\n       * If the customizer throws an unchecked exception, it is safe\n       * to let it propagate\n       */\n    }\n  }\n}\n","import {\n  BundleContext,\n  FilterApi,\n  OBJECTCLASS,\n  SERVICE_ID,\n  SERVICE_RANKING,\n  ServiceEvent,\n  ServiceListener,\n  ServiceReference,\n  ServiceTracker,\n  ServiceTrackerCustomizer,\n} from '@pandino/pandino-api';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { AbstractTracked } from './abstract-tracked';\n\nexport class ServiceTrackerImpl<S, T> implements ServiceTracker<S, T> {\n  readonly customizer: ServiceTrackerCustomizer<S, T>;\n  protected readonly context: BundleContext;\n  protected readonly filter: FilterApi;\n  private readonly listenerFilter: string;\n  private readonly identifier?: string;\n  private tracked: Tracked<S, T>;\n  private cachedReference: ServiceReference<S>;\n  private cachedService: T;\n\n  constructor(\n    context: BundleContext,\n    identifierOrFilter: string | FilterApi,\n    customizer?: ServiceTrackerCustomizer<S, T>,\n  ) {\n    this.context = context;\n    this.customizer = customizer || this;\n    this.listenerFilter =\n      typeof identifierOrFilter === 'string' ? `(${OBJECTCLASS}=${identifierOrFilter})` : identifierOrFilter.toString();\n    this.identifier = typeof identifierOrFilter === 'string' ? identifierOrFilter : undefined;\n    this.filter =\n      typeof identifierOrFilter === 'string' ? context.createFilter(this.listenerFilter) : identifierOrFilter;\n  }\n\n  open(): void {\n    let t: Tracked<S, T>;\n\n    if (isAllPresent(this.tracked)) {\n      return;\n    }\n\n    t = new AllTracked(this);\n\n    this.context.addServiceListener(t, this.listenerFilter);\n\n    let references: Array<ServiceReference<S>> = [];\n\n    if (isAllPresent(this.identifier)) {\n      references = this.getInitialReferences(this.identifier);\n    } else {\n      references = this.getInitialReferences(undefined, this.listenerFilter);\n    }\n\n    t.setInitial(references);\n\n    this.tracked = t;\n\n    t.trackInitial();\n  }\n\n  close(): void {\n    const outgoing: Tracked<S, T> = this.tracked;\n    let references: Array<ServiceReference<S>>;\n\n    if (isAnyMissing(outgoing)) {\n      return;\n    }\n\n    outgoing.close();\n    references = this.getServiceReferences();\n\n    this.tracked = undefined;\n\n    try {\n      this.context.removeServiceListener(outgoing);\n    } catch (_) {\n      /* In case the context was stopped. */\n    }\n\n    this.modified();\n\n    if (isAllPresent(references)) {\n      for (const reference of references) {\n        outgoing.untrack(reference, undefined);\n      }\n    }\n  }\n\n  getServiceReferences(): Array<ServiceReference<S>> {\n    let t: Tracked<S, T> = this.tracked;\n    if (isAnyMissing(t)) {\n      return [];\n    }\n    if (t.isEmpty()) {\n      return [];\n    }\n\n    let result: Array<ServiceReference<S>> = [];\n    return t.copyKeys(result);\n  }\n\n  addingService(reference: ServiceReference<S>): T {\n    return this.context.getService<T>(reference);\n  }\n\n  modifiedService(reference: ServiceReference<S>, service: T): void {\n    /* do nothing */\n  }\n\n  removedService(reference: ServiceReference<S>, service: T): void {\n    try {\n      // If a Bundle is in a STOPPING state, unget will fail\n      this.context.ungetService(reference);\n    } catch (_) {}\n  }\n\n  getService(): T | undefined {\n    let service: T = this.cachedService;\n    if (isAllPresent(service)) {\n      return service;\n    }\n    let reference: ServiceReference<S> = this.getServiceReference();\n    if (isAnyMissing(reference)) {\n      return undefined;\n    }\n    return (this.cachedService = this.getServiceForReference(reference));\n  }\n\n  getServiceReference(): ServiceReference<S> | undefined {\n    const reference: ServiceReference<S> = this.cachedReference;\n    if (isAllPresent(reference)) {\n      return reference;\n    }\n    const references: Array<ServiceReference<S>> = this.getServiceReferences();\n    const length = isAnyMissing(references) ? 0 : references.length;\n    if (length === 0) {\n      return undefined;\n    }\n    let index = 0;\n    if (length > 1) {\n      const rankings: number[] = [];\n      let count = 0;\n      let maxRanking = Number.MIN_VALUE;\n      for (let i = 0; i < length; i++) {\n        const property = references[i].getProperty(SERVICE_RANKING);\n        const ranking: number = typeof property === 'number' ? Number(property) : 0;\n        rankings[i] = ranking;\n        if (ranking > maxRanking) {\n          index = i;\n          maxRanking = ranking;\n          count = 1;\n        } else {\n          if (ranking === maxRanking) {\n            count++;\n          }\n        }\n      }\n      if (count > 1) {\n        let minId = Number.MAX_VALUE;\n        for (let i = 0; i < length; i++) {\n          if (rankings[i] == maxRanking) {\n            const id: number = Number(references[i].getProperty(SERVICE_ID));\n            if (id < minId) {\n              index = i;\n              minId = id;\n            }\n          }\n        }\n      }\n    }\n    return (this.cachedReference = references[index]);\n  }\n\n  getServiceForReference(reference: ServiceReference<S>): T | undefined {\n    let t: Tracked<S, T> = this.tracked;\n    if (isAnyMissing(t)) {\n      return undefined;\n    }\n    return t.getCustomizedObject(reference);\n  }\n\n  getServices(): T[] {\n    let t: Tracked<S, T> = this.tracked;\n    if (isAnyMissing(t)) {\n      return [];\n    }\n    let references: ServiceReference<S>[] = this.getServiceReferences();\n    let length = isAllPresent(references) ? references.length : 0;\n    if (length === 0) {\n      return [];\n    }\n    const objects: T[] = [];\n    for (let i = 0; i < length; i++) {\n      objects[i] = this.getServiceForReference(references[i]);\n    }\n    return objects;\n  }\n\n  modified(): void {\n    this.cachedReference = undefined;\n    this.cachedService = undefined;\n  }\n\n  remove(reference: ServiceReference<S>): void {\n    let t: Tracked<S, T> = this.tracked;\n    if (isAnyMissing(t)) {\n      return;\n    }\n    t.untrack(reference, undefined);\n  }\n\n  size(): number {\n    const t: Tracked<S, T> = this.tracked;\n    if (isAnyMissing(t)) {\n      return 0;\n    }\n\n    return t.size();\n  }\n\n  getTrackingCount(): number {\n    const t: Tracked<S, T> = this.tracked;\n\n    if (isAnyMissing(t)) {\n      return -1;\n    }\n\n    return t.getTrackingCount();\n  }\n\n  isEmpty(): boolean {\n    const t: Tracked<S, T> = this.tracked;\n\n    if (isAnyMissing(t)) {\n      return true;\n    }\n\n    return t.isEmpty();\n  }\n\n  private getInitialReferences(identifier?: string, filterString?: string): Array<ServiceReference<S>> {\n    if (isAnyMissing(identifier) && isAnyMissing(filterString)) {\n      throw new Error('Either the parameter \"identifier\" or \"filterString\" must be provided!');\n    }\n    return this.context.getAllServiceReferences(identifier, filterString);\n  }\n}\n\nclass Tracked<S, T> extends AbstractTracked<ServiceReference<S>, T, ServiceEvent> implements ServiceListener {\n  isSync = true;\n  private tracker: ServiceTrackerImpl<S, T>;\n\n  constructor(tracker: ServiceTrackerImpl<S, T>) {\n    super();\n    this.tracker = tracker;\n  }\n\n  serviceChanged(event: ServiceEvent): void {\n    if (this.closed) {\n      return;\n    }\n    const reference: ServiceReference<S> = event.getServiceReference();\n\n    switch (event.getType()) {\n      case 'REGISTERED':\n      case 'MODIFIED':\n        this.track(reference, event);\n        break;\n      case 'MODIFIED_ENDMATCH':\n      case 'UNREGISTERING':\n        this.untrack(reference, event);\n        break;\n    }\n  }\n\n  modified(): void {\n    super.modified();\n    this.tracker.modified();\n  }\n\n  customizerAdding(item: ServiceReference<S>, related?: ServiceEvent): T {\n    return this.tracker.customizer.addingService(item);\n  }\n\n  customizerModified(item: ServiceReference<S>, object: T, related?: ServiceEvent): void {\n    this.tracker.customizer.modifiedService(item, object);\n  }\n\n  customizerRemoved(item: ServiceReference<S>, object: T, related?: ServiceEvent): void {\n    this.tracker.customizer.removedService(item, object);\n  }\n}\n\nclass AllTracked<S, T> extends Tracked<S, T> implements ServiceListener {\n  constructor(tracker: ServiceTrackerImpl<S, T>) {\n    super(tracker);\n  }\n}\n","import {\n  Bundle,\n  BundleContext,\n  BundleListener,\n  BundleManifestHeaders,\n  FrameworkListener,\n  FilterApi,\n  Logger,\n  BUNDLE_SYMBOLICNAME,\n  BUNDLE_VERSION,\n  ServiceListener,\n  ServiceReference,\n  ServiceProperties,\n  ServiceRegistration,\n  ServiceFactory,\n  ServiceObjects,\n  BundleState,\n  BundleTrackerCustomizer,\n  BundleTracker,\n  BundleEvent,\n  ServiceTrackerCustomizer,\n  ServiceTracker,\n} from '@pandino/pandino-api';\nimport { Pandino } from '../../pandino';\nimport Filter from '../filter/filter';\nimport { BundleImpl } from './bundle-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { ServiceReferenceImpl } from './service-reference-impl';\nimport { ServiceObjectsImpl } from './service-objects-impl';\nimport { BundleTrackerImpl } from './bundle-tracker-impl';\nimport { ServiceTrackerImpl } from './service-tracker-impl';\n\nexport class BundleContextImpl implements BundleContext {\n  private valid = true;\n  private bundleTrackers: BundleTracker<any>[] = [];\n  private serviceTrackers: ServiceTracker<any, any>[] = [];\n\n  constructor(\n    private readonly logger: Logger,\n    private readonly bundle: BundleImpl,\n    private readonly pandino: Pandino,\n  ) {}\n\n  addBundleListener(listener: BundleListener): void {\n    this.checkValidity();\n\n    this.pandino.addBundleListener(this.bundle, listener);\n  }\n\n  removeBundleListener(listener: BundleListener): void {\n    this.checkValidity();\n\n    this.pandino.removeBundleListener(this.bundle, listener);\n  }\n\n  addFrameworkListener(listener: FrameworkListener): void {\n    this.checkValidity();\n\n    this.pandino.addFrameworkListener(this.bundle, listener);\n  }\n\n  removeFrameworkListener(listener: FrameworkListener): void {\n    this.checkValidity();\n\n    this.pandino.removeFrameworkListener(this.bundle, listener);\n  }\n\n  createFilter(filter: string): FilterApi {\n    this.checkValidity();\n\n    return Filter.parse(filter);\n  }\n\n  getBundle(id?: number): Bundle {\n    this.checkValidity();\n\n    if (isAllPresent(id)) {\n      return this.pandino.getBundle(id);\n    }\n\n    return this.bundle;\n  }\n\n  getBundles(): Bundle[] {\n    this.checkValidity();\n\n    return this.pandino.getBundles(this);\n  }\n\n  getProperty(key: string): string {\n    this.checkValidity();\n\n    return this.pandino.getProperty(key);\n  }\n\n  async installBundle(locationOrHeaders: string | BundleManifestHeaders): Promise<Bundle> {\n    if (typeof locationOrHeaders === 'string') {\n      this.logger.debug(`Installing Bundle from location: ${locationOrHeaders}`);\n    } else {\n      this.logger.debug(\n        `Installing Bundle: ${locationOrHeaders[BUNDLE_SYMBOLICNAME]}: ${locationOrHeaders[BUNDLE_VERSION]}`,\n      );\n    }\n    this.checkValidity();\n\n    return this.pandino.installBundle(this.bundle, locationOrHeaders);\n  }\n\n  addServiceListener(listener: ServiceListener, filter?: string): void {\n    this.checkValidity();\n    this.pandino.addServiceListener(this.bundle, listener, filter);\n  }\n\n  getService<S>(reference: ServiceReference<S>): S {\n    this.checkValidity();\n\n    if (isAnyMissing(reference)) {\n      throw new Error('Specified service reference must be defined.');\n    }\n\n    return this.pandino.getService(this.bundle, reference, false);\n  }\n\n  getServiceReference<S>(identifier: string): ServiceReference<S> | undefined {\n    this.checkValidity();\n    try {\n      const refs = this.getServiceReferences(identifier, null);\n      return BundleContextImpl.getBestServiceReference(refs);\n    } catch (ex) {\n      this.logger.error('BundleContextImpl: ' + ex);\n    }\n    return undefined;\n  }\n\n  getAllServiceReferences(identifier?: string, filter?: string): Array<ServiceReference<any>> {\n    this.checkValidity();\n\n    return this.pandino.getAllowedServiceReferences(this.bundle, identifier, filter, false);\n  }\n\n  getServiceReferences<S>(identifier?: string, filter?: string): ServiceReference<S>[] {\n    this.checkValidity();\n\n    return this.pandino.getAllowedServiceReferences(this.bundle, identifier, filter, true);\n  }\n\n  registerService<S>(\n    identifiers: string[] | string,\n    service: S | ServiceFactory<S>,\n    properties?: ServiceProperties,\n  ): ServiceRegistration<S> {\n    this.checkValidity();\n    return this.pandino.registerService(this, identifiers, service, properties || {});\n  }\n\n  removeServiceListener(listener: ServiceListener): void {\n    this.checkValidity();\n    this.pandino.removeServiceListener(this.bundle, listener);\n  }\n\n  ungetService<S>(reference: ServiceReference<S>): boolean {\n    this.checkValidity();\n\n    if (isAnyMissing(reference)) {\n      throw new Error('Specified service reference cannot be missing.');\n    }\n\n    return this.pandino.ungetService(this.bundle, reference, null);\n  }\n\n  getServiceObjects<S>(reference: ServiceReference<S>): ServiceObjects<S> | undefined {\n    this.checkValidity();\n\n    const reg = (reference as ServiceReferenceImpl).getRegistration();\n    if (reg.isValid()) {\n      return new ServiceObjectsImpl<S>(reference, this, this.pandino);\n    }\n    return undefined;\n  }\n\n  isValid(): boolean {\n    return this.valid;\n  }\n\n  invalidate(): void {\n    this.valid = false;\n  }\n\n  checkValidity(): void {\n    if (this.valid) {\n      switch (this.bundle.getState()) {\n        case 'ACTIVE':\n        case 'STARTING':\n        case 'STOPPING':\n          return;\n      }\n    }\n\n    throw new Error('Invalid BundleContext.');\n  }\n\n  equals(other: any): boolean {\n    if (isAnyMissing(other) || !(other instanceof BundleContextImpl)) {\n      return false;\n    }\n    if (\n      this.getBundle().getSymbolicName() === other.getBundle().getSymbolicName() &&\n      this.getBundle().getVersion().toString() === other.getBundle().getVersion().toString()\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  trackBundle<T>(trackedStates: BundleState[], customizer: Partial<BundleTrackerCustomizer<T>>): BundleTracker<T> {\n    this.checkValidity();\n\n    const self = this;\n\n    const tracker = new (class extends BundleTrackerImpl<T> {\n      constructor() {\n        super(self, trackedStates);\n      }\n\n      addingBundle(bundle: Bundle, event: BundleEvent): T {\n        return customizer.addingBundle ? customizer.addingBundle(bundle, event) : super.addingBundle(bundle, event);\n      }\n\n      modifiedBundle(bundle: Bundle, event: BundleEvent, object: T) {\n        customizer.modifiedBundle\n          ? customizer.modifiedBundle(bundle, event, object)\n          : super.modifiedBundle(bundle, event, object);\n      }\n\n      removedBundle(bundle: Bundle, event: BundleEvent, object: T) {\n        customizer.removedBundle\n          ? customizer.removedBundle(bundle, event, object)\n          : super.removedBundle(bundle, event, object);\n      }\n    })();\n\n    this.bundleTrackers.push(tracker);\n\n    return tracker;\n  }\n\n  trackService<S, T>(\n    identifierOrFilter: string | FilterApi,\n    customizer: Partial<ServiceTrackerCustomizer<S, T>>,\n  ): ServiceTracker<S, T> {\n    this.checkValidity();\n\n    const self = this;\n\n    const tracker = new (class extends ServiceTrackerImpl<S, T> {\n      constructor() {\n        super(self, identifierOrFilter);\n      }\n\n      addingService(reference: ServiceReference<S>): T {\n        return customizer.addingService ? customizer.addingService(reference) : super.addingService(reference);\n      }\n\n      modifiedService(reference: ServiceReference<S>, service: T) {\n        customizer.modifiedService\n          ? customizer.modifiedService(reference, service)\n          : super.modifiedService(reference, service);\n      }\n\n      removedService(reference: ServiceReference<S>, service: T) {\n        customizer.removedService\n          ? customizer.removedService(reference, service)\n          : super.removedService(reference, service);\n      }\n    })();\n\n    this.serviceTrackers.push(tracker);\n\n    return tracker;\n  }\n\n  closeTrackers(): void {\n    for (const tracker of this.bundleTrackers) {\n      try {\n        tracker.close();\n      } catch (_) {}\n    }\n\n    for (const tracker of this.serviceTrackers) {\n      try {\n        tracker.close();\n      } catch (_) {}\n    }\n\n    this.bundleTrackers = [];\n    this.serviceTrackers = [];\n  }\n\n  private static getBestServiceReference(refs: ServiceReference<any>[]): ServiceReference<any> | undefined {\n    if (isAnyMissing(refs)) {\n      return undefined;\n    }\n\n    if (refs.length === 1) {\n      return refs[0];\n    }\n\n    let bestRef: ServiceReference<any> = refs[0];\n    for (let i = 1; i < refs.length; i++) {\n      if (bestRef.compareTo(refs[i]) < 0) {\n        bestRef = refs[i];\n      }\n    }\n\n    return bestRef;\n  }\n}\n","import { Bundle, BundleEvent, BundleEventType, FrameworkEventType } from '@pandino/pandino-api';\n\nexport class BundleEventImpl implements BundleEvent {\n  constructor(\n    private readonly bundle: Bundle,\n    private readonly type: BundleEventType | FrameworkEventType,\n    private readonly origin?: Bundle,\n  ) {}\n\n  getBundle(): Bundle {\n    return this.bundle;\n  }\n\n  getOrigin(): Bundle {\n    return this.origin;\n  }\n\n  getType(): BundleEventType | FrameworkEventType {\n    return this.type;\n  }\n\n  toString(): string {\n    return `${this.bundle.getUniqueIdentifier()} changed state to: ${this.type}.`;\n  }\n}\n","import { BundleRevision } from '../bundle-revision';\nimport { BundleCapability } from './bundle-capability';\nimport { BundleWire } from './bundle-wire';\nimport { BundleRequirement } from './bundle-requirement';\nimport { isAnyMissing } from '../../utils/helpers';\n\nexport class BundleWireImpl implements BundleWire {\n  private readonly requirer: BundleRevision;\n  private readonly req: BundleRequirement;\n  private readonly provider: BundleRevision;\n  private readonly cap: BundleCapability;\n\n  constructor(requirer: BundleRevision, req: BundleRequirement, provider: BundleRevision, cap: BundleCapability) {\n    this.requirer = requirer;\n    this.req = req;\n    this.provider = provider;\n    this.cap = cap;\n  }\n\n  equals(other: any): boolean {\n    if (isAnyMissing(other) || !(other instanceof BundleWireImpl)) {\n      return false;\n    }\n    return this.getRequirement() === other.getRequirement() && this.getCapability() === other.getCapability();\n  }\n\n  public getRequirer(): BundleRevision {\n    return this.requirer;\n  }\n\n  public getRequirement(): BundleRequirement {\n    return this.req;\n  }\n\n  public getProvider(): BundleRevision {\n    return this.provider;\n  }\n\n  public getCapability(): BundleCapability {\n    return this.cap;\n  }\n\n  public toString(): string {\n    return this.req + ' -> ' + '[' + this.provider + ']';\n  }\n}\n","import {\n  Bundle,\n  EFFECTIVE_DIRECTIVE,\n  EFFECTIVE_RESOLVE,\n  HOST_NAMESPACE,\n  PACKAGE_NAMESPACE,\n  RESOLUTION_DIRECTIVE,\n} from '@pandino/pandino-api';\nimport { BundleRevisionImpl } from './bundle-revision-impl';\nimport { StatefulResolver } from './stateful-resolver';\nimport { isAnyMissing, isAllPresent } from '../utils/helpers';\nimport { BundleImpl } from './bundle-impl';\nimport { Requirement } from './resource/requirement';\nimport { Capability } from './resource/capability';\nimport { BundleWiring } from './bundle-wiring';\nimport { BundleRevision } from './bundle-revision';\nimport { BundleCapability } from './wiring/bundle-capability';\nimport { BundleWire } from './wiring/bundle-wire';\nimport { BundleRequirement } from './wiring/bundle-requirement';\n\nexport class BundleWiringImpl implements BundleWiring {\n  private readonly configMap: Record<string, any> = {};\n  private readonly resolver: StatefulResolver;\n  private readonly revision: BundleRevisionImpl;\n  private readonly wires: Array<BundleWire> = [];\n  private readonly resolvedCaps: Array<BundleCapability> = [];\n  private readonly resolvedReqs: Array<BundleRequirement> = [];\n  private isDisposed = false;\n\n  constructor(\n    configMap: Record<string, any>,\n    resolver: StatefulResolver,\n    revision: BundleRevisionImpl,\n    wires: Array<BundleWire> = [],\n  ) {\n    this.configMap = configMap;\n    this.resolver = resolver;\n    this.revision = revision;\n    this.wires = [...wires];\n\n    const reqList: Array<BundleRequirement> = [];\n\n    for (const bw of wires) {\n      if (bw.getRequirement().getNamespace() !== HOST_NAMESPACE || !reqList.includes(bw.getRequirement())) {\n        reqList.push(bw.getRequirement());\n      }\n    }\n\n    for (const req of this.revision.getDeclaredRequirements(null)) {\n      if (req.getNamespace() === PACKAGE_NAMESPACE) {\n        const resolution: string = req.getDirectives()[RESOLUTION_DIRECTIVE];\n        if (isAllPresent(resolution) && resolution === 'dynamic') {\n          reqList.push(req);\n        }\n      }\n    }\n\n    this.resolvedReqs = [...reqList];\n\n    const capList: Array<BundleCapability> = [];\n\n    for (const cap of this.revision.getDeclaredCapabilities(null)) {\n      if (cap.getNamespace() !== PACKAGE_NAMESPACE) {\n        let effective: string = cap.getDirectives()[EFFECTIVE_DIRECTIVE];\n        if (isAnyMissing(effective) || effective === EFFECTIVE_RESOLVE) {\n          capList.push(cap);\n        }\n      }\n    }\n\n    this.resolvedCaps = [...capList];\n  }\n\n  dispose(): void {\n    this.isDisposed = true;\n  }\n\n  getBundle(): Bundle {\n    return this.revision.getBundle();\n  }\n\n  isCurrent(): boolean {\n    const bundle = this.getBundle();\n    const current: BundleRevision =\n      bundle.getState() === 'UNINSTALLED' ? null : (bundle as BundleImpl).getCurrentRevision();\n    return isAllPresent(current) && current.getWiring() === this;\n  }\n\n  isInUse(): boolean {\n    return !this.isDisposed;\n  }\n\n  getResourceCapabilities(namespace: string): Capability[] {\n    return this.getCapabilities(namespace);\n  }\n\n  getCapabilities(namespace: string): BundleCapability[] {\n    if (this.isInUse()) {\n      let result: Array<BundleCapability> = this.resolvedCaps;\n      if (isAllPresent(namespace)) {\n        result = [];\n        for (const cap of this.resolvedCaps) {\n          if (cap.getNamespace() === namespace) {\n            result.push(cap);\n          }\n        }\n      }\n      return result;\n    }\n    return [];\n  }\n\n  getProvidedWires(namespace: string): BundleWire[] {\n    throw new Error('Method not yet implemented!');\n  }\n\n  getRequiredWires(namespace: string): BundleWire[] {\n    if (this.isInUse()) {\n      let result: Array<BundleWire> = [...this.wires];\n      if (isAllPresent(namespace)) {\n        result = this.wires.filter((bw) => bw.getRequirement().getNamespace() === namespace);\n      }\n      return result;\n    }\n    return [];\n  }\n\n  getRequirements(namespace: string): BundleRequirement[] {\n    if (this.isInUse()) {\n      let searchReqs: Array<BundleRequirement> = this.resolvedReqs;\n      let result: Array<BundleRequirement> = this.resolvedReqs;\n\n      if (isAllPresent(namespace)) {\n        result = [];\n        for (const req of searchReqs) {\n          if (req.getNamespace() === namespace) {\n            result.push(req);\n          }\n        }\n      }\n      return result;\n    }\n    return [];\n  }\n\n  getResource(): BundleRevision {\n    return this.revision;\n  }\n\n  getResourceRequirements(namespace: string): Requirement[] {\n    return this.getRequirements(namespace);\n  }\n\n  getRevision(): BundleRevision {\n    return this.revision;\n  }\n\n  toString(): string {\n    return this.revision.getBundle().toString();\n  }\n}\n","import { BundleState, Logger, SYSTEM_BUNDLE_SYMBOLICNAME } from '@pandino/pandino-api';\nimport { Pandino } from '../../pandino';\nimport { CapabilitySet } from './capability-set/capability-set';\nimport { BundleRevisionImpl } from './bundle-revision-impl';\nimport { BundleRequirementImpl } from './wiring/bundle-requirement-impl';\nimport { isAnyMissing } from '../utils/helpers';\nimport { BundleWireImpl } from './wiring/bundle-wire-impl';\nimport { BundleWiringImpl } from './bundle-wiring-impl';\nimport { BundleImpl } from './bundle-impl';\nimport { BundleWiring } from './bundle-wiring';\nimport { BundleRevision } from './bundle-revision';\nimport { ServiceRegistry } from './service-registry';\nimport { BundleCapability } from './wiring/bundle-capability';\nimport { BundleWire } from './wiring/bundle-wire';\n\nexport class StatefulResolver {\n  private readonly pandino: Pandino;\n  private readonly revisions: Array<BundleRevision> = [];\n  private readonly registry: ServiceRegistry;\n  private readonly logger: Logger;\n\n  constructor(logger: Logger, pandino: Pandino, registry: ServiceRegistry) {\n    this.logger = logger;\n    this.pandino = pandino;\n    this.registry = registry;\n  }\n\n  async resolveOne(revision: BundleRevision): Promise<void> {\n    if (['ACTIVE'].includes(revision.getBundle().getState())) {\n      return;\n    }\n\n    const bundleWiring = this.resolve(revision as BundleRevisionImpl);\n    if (bundleWiring) {\n      this.logger.debug(\n        `Bundle Wiring created for Revision: ${revision.getSymbolicName()}: ${revision.getVersion().toString()}`,\n      );\n\n      const bundle = bundleWiring.getRevision().getBundle();\n      this.pandino.fireBundleEvent('RESOLVED', bundle);\n\n      try {\n        await this.pandino.startBundle(bundle as BundleImpl);\n        await this.resolveRemaining();\n      } catch (err) {\n        this.logger.error(err);\n      }\n    } else {\n      this.logger.debug(\n        `No Wiring found for Revision: ${revision.getSymbolicName()}: ${revision.getVersion().toString()}`,\n      );\n    }\n  }\n\n  async resolveRemaining(): Promise<void> {\n    const unresolvedRevs = this.revisions.filter((r) => isAnyMissing(r.getWiring()));\n    const revsToReRun = unresolvedRevs.filter((r) => {\n      const wires = StatefulResolver.getResolvableWires(r, this.getEligibleCapabilities());\n      return r.getSymbolicName() !== SYSTEM_BUNDLE_SYMBOLICNAME && StatefulResolver.canBundleBeResolved(r, wires);\n    });\n    for (const rev of revsToReRun) {\n      await this.resolveOne(rev);\n    }\n  }\n\n  getActiveRequirers(bundle: BundleImpl): BundleImpl[] {\n    const bundles: BundleImpl[] = [];\n    // rev.getWiring().getRequiredWires(null)\n    const wirings = this.revisions\n      .filter((rev) => !!rev.getWiring())\n      .map((rev) => rev.getWiring())\n      .filter((wiring) => wiring.isInUse());\n    for (const wiring of wirings) {\n      const wire = wiring\n        .getRequiredWires(null)\n        .find((wire: BundleWire) => wire.getProvider().equals(bundle.getCurrentRevision()));\n      if (wire) {\n        bundles.push(wire.getRequirer().getBundle() as BundleImpl);\n      }\n    }\n    return bundles;\n  }\n\n  /**\n   * Currently in the resolving process, we only take ACTIVE Bundles into consideration. Given we are expecting all\n   * Bundles to have at least a start() being called from A {@link BundleActivator}.\n   */\n  private getEligibleCapabilities(): BundleCapability[] {\n    const caps: BundleCapability[] = [];\n    const activeRevisions: BundleRevision[] = this.revisions.filter((rev) => rev.getBundle().getState() === 'ACTIVE');\n    for (const rev of activeRevisions) {\n      caps.push(...rev.getDeclaredCapabilities(null));\n    }\n    return caps;\n  }\n\n  private resolve(rev: BundleRevisionImpl): BundleWiring | undefined {\n    const wiring = this.createWiringForRevision(rev);\n\n    rev.resolve(wiring);\n    return wiring;\n  }\n\n  private static canBundleBeResolved(rev: BundleRevision, wires: Array<BundleWire>): boolean {\n    const validStates: BundleState[] = ['INSTALLED', 'STARTING'];\n    if (!validStates.includes(rev.getBundle().getState())) {\n      return false;\n    }\n    const requirements = rev.getDeclaredRequirements(null);\n    const reqs = requirements.map((r) => r.getNamespace());\n    const wireCaps = wires.map((w) => w.getCapability().getNamespace());\n\n    return requirements.length === 0 || reqs.every((r) => wireCaps.includes(r));\n  }\n\n  static getResolvableWires(rev: BundleRevision, allProvidedCapabilities: BundleCapability[]): Array<BundleWire> {\n    const requirements = rev.getDeclaredRequirements(null);\n    const wires: Array<BundleWire> = [];\n    for (const req of requirements) {\n      const filter = (req as BundleRequirementImpl).getFilter();\n      const providedCap = allProvidedCapabilities.find(\n        (p) => p.getNamespace() === req.getNamespace() && CapabilitySet.matches(p, filter),\n      );\n      if (providedCap) {\n        const wire = new BundleWireImpl(req.getResource(), req, providedCap?.getResource(), providedCap);\n        wires.push(wire);\n      }\n    }\n    return wires;\n  }\n\n  createWiringForRevision(revision: BundleRevision): BundleWiring | undefined {\n    const wires = StatefulResolver.getResolvableWires(revision, this.getEligibleCapabilities());\n\n    if (StatefulResolver.canBundleBeResolved(revision, wires)) {\n      const impl = revision as BundleRevisionImpl;\n      return new BundleWiringImpl(impl.getHeaders(), this, impl, wires);\n    }\n  }\n\n  addRevision(br: BundleRevision): void {\n    this.removeRevision(br);\n    this.revisions.push(br);\n  }\n\n  removeRevision(br: BundleRevision): void {\n    const idx = this.revisions.findIndex((r) => r.equals(br));\n    if (idx > 0) {\n      this.revisions.splice(idx, 1);\n    }\n  }\n}\n","import {\n  Bundle,\n  ServiceProperties,\n  ServiceReference,\n  SERVICE_DEFAULT_RANK,\n  SERVICE_ID,\n  SERVICE_RANKING,\n  PACKAGE_NAMESPACE,\n  OBJECTCLASS,\n} from '@pandino/pandino-api';\nimport { ServiceRegistrationImpl } from './service-registration-impl';\nimport { BundleCapabilityImpl } from './wiring/bundle-capability-impl';\nimport { BundleImpl } from './bundle-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { BundleRevision } from './bundle-revision';\nimport { BundleCapability } from './wiring/bundle-capability';\nimport { BundleWire } from './wiring/bundle-wire';\n\nexport const PACKAGE_SEPARATOR = '.';\n\nexport class ServiceReferenceImpl extends BundleCapabilityImpl implements ServiceReference<any> {\n  private readonly reg: ServiceRegistrationImpl;\n  private readonly bundle: Bundle;\n\n  constructor(reg: ServiceRegistrationImpl, bundle: Bundle) {\n    super(null, null, {}, {});\n    this.reg = reg;\n    this.bundle = bundle;\n  }\n\n  compareTo(other: ServiceReference<any>): number {\n    const id: number = Number(this.getProperty(SERVICE_ID));\n    const otherId: number = Number(other.getProperty(SERVICE_ID));\n\n    if (id === otherId) {\n      return 0;\n    }\n\n    const rankObj: number = Number(this.getProperty(SERVICE_RANKING));\n    const otherRankObj: number = Number(other.getProperty(SERVICE_RANKING));\n\n    const rank = !rankObj ? SERVICE_DEFAULT_RANK : rankObj;\n    const otherRank = !otherRankObj ? SERVICE_DEFAULT_RANK : otherRankObj;\n\n    if (rank - otherRank < 0) {\n      return -1;\n    } else if (rank - otherRank > 0) {\n      return 1;\n    }\n\n    // If ranks are equal, then sort by service id in descending order.\n    return otherId - id;\n  }\n\n  getRegistration(): ServiceRegistrationImpl {\n    return this.reg;\n  }\n\n  getRevision(): BundleRevision {\n    throw new Error('Not supported yet.');\n  }\n\n  getNamespace(): string {\n    return 'service-reference';\n  }\n\n  getDirectives(): Record<string, string> {\n    return {};\n  }\n\n  getAttributes(): Record<string, any> {\n    return {\n      ...this.getRegistration().getProperties(),\n    };\n  }\n\n  getUses(): string[] {\n    return [];\n  }\n\n  getBundle(): Bundle {\n    if (this.reg.isValid()) {\n      return this.bundle;\n    }\n  }\n\n  getProperties(): ServiceProperties {\n    return this.reg.getProperties();\n  }\n\n  getProperty(key: string): any {\n    return this.reg.getProperty(key);\n  }\n\n  getPropertyKeys(): Array<string> {\n    return this.reg.getPropertyKeys();\n  }\n\n  getUsingBundles(): Bundle[] {\n    return this.reg.getUsingBundles(this);\n  }\n\n  isAssignableTo(bundle: Bundle, className: string): boolean {\n    if (bundle === this.bundle) {\n      return true;\n    }\n\n    let allow: boolean;\n    const pkgName = ServiceReferenceImpl.getClassPackage(className);\n\n    const requesterRevision = (bundle as BundleImpl).getCurrentRevision();\n    const requesterWire = ServiceReferenceImpl.getWire(requesterRevision, pkgName);\n    const requesterCap = ServiceReferenceImpl.getPackageCapability(requesterRevision, pkgName);\n\n    const providerRevision = (this.bundle as BundleImpl).getCurrentRevision();\n    const providerWire = ServiceReferenceImpl.getWire(providerRevision, pkgName);\n    const providerCap = ServiceReferenceImpl.getPackageCapability(providerRevision, pkgName);\n\n    if (isAnyMissing(requesterWire) && isAnyMissing(providerWire)) {\n      allow = true;\n    } else if (isAnyMissing(requesterWire) && isAllPresent(providerWire)) {\n      if (isAllPresent(requesterCap)) {\n        allow = providerRevision.getWiring().getRevision().equals(requesterRevision);\n      } else {\n        allow = true;\n      }\n    } else if (requesterWire != null && providerWire == null) {\n      if (isAllPresent(providerCap)) {\n        allow = requesterWire.getProvider().equals(providerRevision);\n      } else {\n        allow = true;\n      }\n    } else {\n      allow = providerWire.getProvider().equals(requesterWire.getProvider());\n    }\n\n    return allow;\n  }\n\n  hasObjectClass(objectClass: string): boolean {\n    const classOrArray = this.getProperty(OBJECTCLASS);\n    return Array.isArray(classOrArray) ? classOrArray.includes(objectClass) : classOrArray === objectClass;\n  }\n\n  private static getClassName(className?: string): string {\n    if (isAnyMissing(className)) {\n      return '';\n    }\n    return className.substring(className.lastIndexOf(PACKAGE_SEPARATOR), className.length - 1);\n  }\n\n  private static getClassPackage(className?: string): string {\n    if (isAnyMissing(className)) {\n      return '';\n    }\n    return className.substring(0, className.lastIndexOf(PACKAGE_SEPARATOR));\n  }\n\n  private static getWire(br: BundleRevision, name: string): BundleWire | undefined {\n    if (isAllPresent(br.getWiring())) {\n      const wires = br.getWiring().getRequiredWires(null);\n      if (isAllPresent(wires)) {\n        for (const w of wires) {\n          if (\n            w.getCapability().getNamespace() === PACKAGE_NAMESPACE &&\n            w.getCapability().getAttributes()[PACKAGE_NAMESPACE] === name\n          ) {\n            return w;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private static getPackageCapability(br: BundleRevision, name: string): BundleCapability | undefined {\n    if (isAllPresent(br.getWiring())) {\n      const capabilities = br.getWiring().getCapabilities(null);\n      if (isAllPresent(capabilities)) {\n        for (const c of capabilities) {\n          if (c.getNamespace() === PACKAGE_NAMESPACE && c.getAttributes()[PACKAGE_NAMESPACE] === name) {\n            return c;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n}\n","import {\n  Bundle,\n  ServiceProperties,\n  ServiceReference,\n  ServiceRegistration,\n  OBJECTCLASS,\n  SCOPE_SINGLETON,\n  SERVICE_BUNDLEID,\n  SERVICE_ID,\n  SERVICE_SCOPE,\n  SCOPE_BUNDLE,\n  SCOPE_PROTOTYPE,\n  ServiceFactory,\n} from '@pandino/pandino-api';\nimport { ServiceReferenceImpl } from './service-reference-impl';\nimport { isAllPresent } from '../utils/helpers';\nimport { ServiceRegistry } from './service-registry';\nimport { ServiceRegistryImpl } from './service-registry-impl';\n\nexport class ServiceRegistrationImpl implements ServiceRegistration<any> {\n  private readonly registry: ServiceRegistry;\n  private readonly bundle: Bundle;\n  private readonly classes: string | string[];\n  private readonly serviceId: number;\n  private svcObj: any;\n  private factory?: ServiceFactory<any>;\n  private propMap?: ServiceProperties;\n  private readonly ref: ServiceReferenceImpl;\n  private isUnregistering = false;\n\n  constructor(\n    registry: ServiceRegistry,\n    bundle: Bundle,\n    classNames: string | string[],\n    serviceId: number,\n    svcObj: any,\n    dict?: ServiceProperties,\n  ) {\n    this.registry = registry;\n    this.bundle = bundle;\n    this.classes = classNames;\n    this.serviceId = serviceId;\n    this.svcObj = svcObj;\n    this.factory = isAllPresent((this.svcObj as ServiceFactory<any>).factoryType) ? this.svcObj : undefined;\n    this.propMap = dict;\n\n    this.initializeProperties(dict);\n\n    this.ref = new ServiceReferenceImpl(this, bundle);\n  }\n\n  isValid(): boolean {\n    return isAllPresent(this.svcObj);\n  }\n\n  invalidate(): void {\n    this.svcObj = null;\n  }\n\n  getUsingBundles(ref: ServiceReference<any>): Array<Bundle> {\n    return this.registry.getUsingBundles(ref);\n  }\n\n  getService(acqBundle?: Bundle): any {\n    if (this.factory) {\n      return this.getFactoryUnchecked(acqBundle);\n    }\n    return this.svcObj;\n  }\n\n  ungetService(relBundle: Bundle, svcObj: any) {\n    if (this.factory) {\n      try {\n        this.ungetFactoryUnchecked(relBundle, svcObj);\n      } catch (e) {\n        (this.registry as ServiceRegistryImpl)\n          .getLogger()\n          .error('ServiceRegistrationImpl: Error ungetting service.', e);\n      }\n    }\n  }\n\n  getReference(): ServiceReference<any> {\n    if (!this.isValid()) {\n      throw new Error('The service registration is no longer valid for class(es): ' + JSON.stringify(this.classes));\n    }\n    return this.ref;\n  }\n\n  setProperties(properties: ServiceProperties): void {\n    let oldProps: ServiceProperties;\n    if (!this.isValid()) {\n      throw new Error('The service registration is no longer valid for class(es): ' + JSON.stringify(this.classes));\n    }\n    oldProps = this.propMap;\n    this.initializeProperties(properties);\n    this.registry.servicePropertiesModified(this, { ...oldProps });\n  }\n\n  unregister(): void {\n    if (!this.isValid() || this.isUnregistering) {\n      throw new Error('Service already unregistered.');\n    }\n    this.isUnregistering = true;\n    // TODO: re-introduce\n    this.registry.unregisterService(this.bundle, this);\n    this.svcObj = null;\n    this.factory = null;\n  }\n\n  getProperty(key: string): any {\n    return this.propMap[key];\n  }\n\n  getProperties(): ServiceProperties {\n    return this.propMap;\n  }\n\n  getPropertyKeys(): Array<string> {\n    return Object.keys(this.propMap || {});\n  }\n\n  private getFactoryUnchecked(bundle?: Bundle): any {\n    return this.factory.getService(bundle, this);\n  }\n\n  private ungetFactoryUnchecked(bundle: Bundle, svcObj: any): void {\n    this.factory.ungetService(bundle, this, svcObj);\n  }\n\n  private initializeProperties(dict: Record<string, any>): void {\n    const props: Record<string, any> = {};\n    if (isAllPresent(dict)) {\n      Object.assign(props, { ...dict });\n    }\n\n    props[OBJECTCLASS] = this.classes;\n    props[SERVICE_ID] = this.serviceId;\n    props[SERVICE_BUNDLEID] = this.bundle.getBundleId();\n\n    if (this.factory) {\n      props[SERVICE_SCOPE] = this.factory.factoryType === 'prototype' ? SCOPE_PROTOTYPE : SCOPE_BUNDLE;\n    } else {\n      props[SERVICE_SCOPE] = SCOPE_SINGLETON;\n    }\n\n    this.propMap = props;\n  }\n}\n","import { ServiceReference } from '@pandino/pandino-api';\nimport { UsageCount } from './usage-count';\n\nexport class UsageCountImpl implements UsageCount {\n  private readonly ref: ServiceReference<any>;\n  private service?: any;\n  private count = 0;\n  private serviceObjectsCount = 0;\n  private readonly isProto: boolean;\n\n  constructor(ref: ServiceReference<any>, isPrototype = false) {\n    this.ref = ref;\n    this.isProto = isPrototype;\n  }\n\n  getReference(): ServiceReference<any> {\n    return this.ref;\n  }\n\n  getCount(): number {\n    return this.count;\n  }\n\n  getServiceObjectsCount(): number {\n    return this.serviceObjectsCount;\n  }\n\n  incrementToPositiveValue(): number {\n    if (this.count + 1 < 1) {\n      return (this.count = 1);\n    }\n    this.count++;\n    return this.count;\n  }\n\n  incrementServiceObjectsCountToPositiveValue(): number {\n    if (this.serviceObjectsCount <= 0) {\n      return (this.serviceObjectsCount = 1);\n    }\n    this.serviceObjectsCount++;\n    return this.serviceObjectsCount;\n  }\n\n  incrementAndGet(): number {\n    return ++this.count;\n  }\n\n  decrementAndGet(): number {\n    return --this.count;\n  }\n\n  serviceObjectsDecrementAndGet(): number {\n    return --this.serviceObjectsCount;\n  }\n\n  getService(): any {\n    return this.service;\n  }\n\n  setService(service: any): void {\n    this.service = service;\n  }\n\n  isPrototype(): boolean {\n    return this.isProto;\n  }\n}\n","import {\n  Bundle,\n  FilterApi,\n  Logger,\n  OBJECTCLASS,\n  SCOPE_PROTOTYPE,\n  SERVICE_ID,\n  SERVICE_SCOPE,\n  ServiceProperties,\n  ServiceReference,\n  ServiceRegistration,\n} from '@pandino/pandino-api';\nimport { ServiceRegistrationImpl } from './service-registration-impl';\nimport { isAllPresent, isAnyMissing } from '../utils/helpers';\nimport { ServiceEventImpl } from './service-event-impl';\nimport { ServiceReferenceImpl } from './service-reference-impl';\nimport Filter, { FilterComp } from '../filter/filter';\nimport { CapabilitySet } from './capability-set/capability-set';\nimport { BundleCapabilityImpl } from './wiring/bundle-capability-impl';\nimport { UsageCountImpl } from './usage-count-impl';\nimport { ServiceRegistryCallbacks } from './service-registry-callbacks';\nimport { Capability } from './resource/capability';\nimport { ServiceRegistry } from './service-registry';\nimport { UsageCount } from './usage-count';\n\nexport class ServiceRegistryImpl implements ServiceRegistry {\n  private readonly logger: Logger;\n  private readonly callbacks: ServiceRegistryCallbacks;\n  private readonly regsMap: Map<Bundle, Array<ServiceRegistration<any>>> = new Map<\n    Bundle,\n    Array<ServiceRegistration<any>>\n  >();\n  private readonly regCapSet: CapabilitySet = new CapabilitySet([OBJECTCLASS]);\n  private readonly inUseMap: Map<Bundle, UsageCount[]> = new Map<Bundle, UsageCount[]>();\n  private currentServiceId = 0;\n\n  constructor(logger: Logger, callbacks: ServiceRegistryCallbacks) {\n    this.logger = logger;\n    this.callbacks = callbacks;\n  }\n\n  getRegisteredServices(bundle: Bundle): ServiceReference<any>[] {\n    const regs: Array<ServiceRegistration<any>> = this.regsMap.get(bundle);\n    if (isAllPresent(regs)) {\n      const refs: Array<ServiceReference<any>> = [];\n      for (const reg of regs) {\n        try {\n          refs.push(reg.getReference());\n        } catch (ex) {\n          // Don't include the reference as it is not valid anymore\n        }\n      }\n      return refs;\n    }\n    return [];\n  }\n\n  getService<S>(bundle: Bundle, ref: ServiceReference<S>, isServiceObjects = false): S | undefined {\n    const isPrototype = isServiceObjects && ref.getProperty(SERVICE_SCOPE) === SCOPE_PROTOTYPE;\n    let usage: UsageCount;\n    let svcObj: any;\n\n    const reg = (ref as ServiceReferenceImpl).getRegistration();\n\n    try {\n      if (reg.isValid()) {\n        // Get the usage count, or create a new one. If this is a prototype, then we'll always create a new one.\n        usage = this.obtainUsageCount(bundle, ref, undefined, isPrototype);\n\n        usage.incrementToPositiveValue();\n        svcObj = usage.getService();\n\n        if (isAnyMissing(svcObj)) {\n          svcObj = reg.getService(bundle);\n          usage.setService(svcObj);\n        }\n\n        if (isServiceObjects) {\n          usage.incrementServiceObjectsCountToPositiveValue();\n        }\n\n        if (isAllPresent(usage) && isPrototype) {\n          const existingUsage = this.obtainUsageCount(bundle, ref, svcObj);\n          if (existingUsage && existingUsage !== usage) {\n            this.flushUsageCount(bundle, ref, usage);\n            usage = existingUsage;\n            usage.incrementToPositiveValue();\n            if (isServiceObjects) {\n              usage.incrementServiceObjectsCountToPositiveValue();\n            }\n          }\n        }\n      }\n    } finally {\n      if (!reg.isValid() || isAnyMissing(svcObj)) {\n        this.flushUsageCount(bundle, ref, usage);\n      }\n    }\n\n    return svcObj as S;\n  }\n\n  servicePropertiesModified(reg: ServiceRegistration<any>, oldProps: ServiceProperties): void {\n    if (isAllPresent(this.callbacks)) {\n      this.callbacks.serviceChanged(new ServiceEventImpl('MODIFIED', reg.getReference()), oldProps);\n    }\n  }\n\n  getServiceReferences(identifier?: string, filter?: FilterApi): Array<Capability> {\n    let filterEffective: Filter = filter as Filter;\n    if (isAnyMissing(identifier) && isAnyMissing(filter)) {\n      filterEffective = new Filter(null, FilterComp.MATCH_ALL, null);\n    } else if (isAllPresent(identifier) && isAnyMissing(filter)) {\n      filterEffective = new Filter(OBJECTCLASS, FilterComp.EQ, identifier);\n    } else if (isAllPresent(identifier) && isAllPresent(filter)) {\n      const filters: Array<Filter> = [];\n      filters.push(new Filter(OBJECTCLASS, FilterComp.EQ, identifier));\n      filters.push(filter as Filter);\n      filterEffective = new Filter(null, FilterComp.AND, null, filters);\n    }\n\n    return Array.from(this.regCapSet.match(filterEffective, false));\n  }\n\n  getUsingBundles(ref: ServiceReference<any>): Bundle[] {\n    let bundles: Bundle[] = [];\n    for (const bundle of this.inUseMap.keys()) {\n      const usages = this.inUseMap.get(bundle);\n      for (const usage of usages) {\n        if (usage.getReference().compareTo(ref) === 0 && usage.getCount() > 0) {\n          if (isAnyMissing(bundles)) {\n            bundles = [bundle];\n          } else {\n            bundles.push(bundle);\n          }\n        }\n      }\n    }\n    return bundles;\n  }\n\n  registerService(\n    bundle: Bundle,\n    classNames: string | string[],\n    svcObj: any,\n    dict?: ServiceProperties,\n  ): ServiceRegistration<any> {\n    const reg = new ServiceRegistrationImpl(this, bundle, classNames, ++this.currentServiceId, svcObj, dict);\n\n    if (!this.regsMap.has(bundle)) {\n      this.regsMap.set(bundle, []);\n    }\n\n    const regs = this.regsMap.get(bundle);\n\n    // TODO: implement check if same service gets registered or not!\n    if (!regs.find((r) => r.getReference().getProperty(SERVICE_ID) === reg.getReference().getProperty(SERVICE_ID))) {\n      regs.push(reg);\n    } else {\n      this.logger.warn(`Service already registered, skipping! (${reg.getReference().getProperty(SERVICE_ID)})`);\n    }\n    this.regCapSet.addCapability(reg.getReference() as unknown as BundleCapabilityImpl);\n\n    return reg;\n  }\n\n  unregisterService<S>(bundle: Bundle, reg: ServiceRegistration<S>): void {\n    const regs: Array<ServiceRegistration<any>> = this.regsMap.get(bundle);\n    if (isAllPresent(regs)) {\n      const remIdx = regs.findIndex((r) => r === reg);\n      if (remIdx > -1) {\n        regs.splice(remIdx, 1);\n      }\n    }\n\n    this.regCapSet.removeCapability(reg.getReference() as unknown as BundleCapabilityImpl);\n\n    if (isAllPresent(this.callbacks)) {\n      this.callbacks.serviceChanged(new ServiceEventImpl('UNREGISTERING', reg.getReference()), null);\n    }\n\n    const ref = reg.getReference();\n    this.ungetServicesByRef(ref);\n\n    (reg as ServiceRegistrationImpl).invalidate();\n\n    this.ungetServicesByRef(ref);\n\n    for (const bundle of this.inUseMap.keys()) {\n      this.flushUsageCount(bundle, ref);\n    }\n  }\n\n  ungetService(bundle: Bundle, ref: ServiceReference<any>, svcObj: any): boolean {\n    const reg: ServiceRegistrationImpl = (ref as ServiceReferenceImpl).getRegistration();\n\n    try {\n      const usage = this.obtainUsageCount(bundle, ref, svcObj);\n\n      if (isAnyMissing(usage)) {\n        return false;\n      }\n\n      if (isAllPresent(svcObj)) {\n        if (usage.decrementAndGet() < 0) {\n          return false;\n        }\n      }\n\n      const count = usage.decrementAndGet();\n      try {\n        if (count <= 0) {\n          const svc = usage.getService();\n\n          if (isAllPresent(svc)) {\n            usage.setService(null);\n            if (usage.getCount() <= 0) {\n              // Temporarily increase the usage again so that the service factory still sees the usage in the unget\n              usage.incrementToPositiveValue();\n              try {\n                // Remove reference from usages array.\n                reg.ungetService(bundle, svc);\n              } finally {\n                // now we can decrease the usage again\n                usage.decrementAndGet();\n              }\n            }\n          }\n        }\n\n        return usage.getCount() >= 0;\n      } finally {\n        if (!reg.isValid()) {\n          usage.setService(null);\n        }\n\n        if (!reg.isValid() || (count <= 0 && isAllPresent(svcObj))) {\n          this.flushUsageCount(bundle, ref, usage);\n        }\n      }\n    } finally {\n      // no-nop\n    }\n  }\n\n  /**\n   * Utility method to flush the specified bundle's usage count for the specified service reference. This should be\n   * called to completely remove the associated usage count object for the specified service reference. If the goal is\n   * to simply decrement the usage, then get the usage count and decrement its counter. This method will also remove\n   * the specified bundle from the \"in use\" map if it has no more usage counts after removing the usage count for the\n   * specified service reference.\n   **/\n  private flushUsageCount(bundle: Bundle, ref: ServiceReference<any>, uc?: UsageCount): void {\n    const usages: UsageCount[] = this.inUseMap.get(bundle) || [];\n    let processUsage = true;\n\n    while (processUsage === true) {\n      const usageIdx = usages.findIndex(\n        (usage) => (isAnyMissing(uc) && usage.getReference().compareTo(ref) === 0) || uc === usage,\n      );\n\n      if (usageIdx > -1) {\n        usages.splice(usageIdx, 1);\n      } else {\n        processUsage = false;\n      }\n    }\n\n    if (usages.length === 0) {\n      this.inUseMap.delete(bundle);\n    }\n  }\n\n  /**\n   * Obtain a UsageCount object, by looking for an existing one or creating a new one (if possible). This method tries\n   * to find a UsageCount object in the {@code inUseMap}. If one is found then this is returned, otherwise a UsageCount\n   * object will be created, but this can only be done if the {@code isPrototype} parameter is not {@code undefined}.\n   * If {@code isPrototype} is {@code TRUE} then a new UsageCount object will always be created.\n   */\n  obtainUsageCount(\n    bundle: Bundle,\n    ref: ServiceReference<any>,\n    svcObj: any,\n    isPrototype = false,\n  ): UsageCount | undefined {\n    let usage: UsageCount = null;\n\n    const usages: UsageCount[] = this.inUseMap.get(bundle);\n\n    if (isPrototype === false && isAllPresent(usages)) {\n      for (const usage of usages) {\n        if (\n          usage.getReference().compareTo(ref) === 0 &&\n          ((isAnyMissing(svcObj) && !usage.isPrototype()) || usage.getService() === svcObj)\n        ) {\n          return usage;\n        }\n      }\n    }\n\n    // if (isAnyMissing(isPrototype)) {\n    //   return undefined;\n    // }\n\n    usage = new UsageCountImpl(ref, isPrototype);\n\n    if (isAnyMissing(usages)) {\n      const newUsages: UsageCount[] = [usage];\n      this.inUseMap.set(bundle, newUsages);\n    } else {\n      usages.push(usage);\n    }\n    return usage;\n  }\n\n  unregisterServices(bundle: Bundle): void {\n    const regs: Array<ServiceRegistration<any>> = this.regsMap.get(bundle);\n    this.regsMap.delete(bundle);\n\n    if (isAllPresent(regs)) {\n      for (const reg of regs) {\n        if ((reg as ServiceRegistrationImpl).isValid()) {\n          try {\n            reg.unregister();\n          } catch (ex) {\n            // Ignore exception if the service has already been unregistered\n          }\n        }\n      }\n    }\n  }\n\n  ungetServices(bundle: Bundle): void {\n    const usages: UsageCount[] = this.inUseMap.get(bundle);\n    if (isAnyMissing(usages)) {\n      return;\n    }\n\n    for (const usage of usages) {\n      // Keep ungetting until all usage count is zero.\n      while (this.ungetService(bundle, usage.getReference(), usage.isPrototype() ? usage.getService() : null)) {\n        // Empty loop body.\n      }\n    }\n  }\n\n  private ungetServicesByRef(ref: ServiceReference<any>): void {\n    const clients: Bundle[] = this.getUsingBundles(ref);\n    for (const client of clients) {\n      const usages: UsageCount[] = this.inUseMap.get(client);\n      for (const usage of usages) {\n        if (usage.getReference().compareTo(ref) === 0) {\n          this.ungetService(client, ref, usage.isPrototype() ? usage.getService() : null);\n        }\n      }\n    }\n  }\n\n  getLogger(): Logger {\n    return this.logger;\n  }\n\n  getInUseMap(bundle: Bundle): UsageCount[] {\n    return this.inUseMap.get(bundle);\n  }\n}\n","import { FrameworkEvent, FrameworkEventType, Bundle } from '@pandino/pandino-api';\n\nexport class FrameworkEventImpl implements FrameworkEvent {\n  constructor(\n    private readonly type: FrameworkEventType,\n    private readonly bundle?: Bundle,\n    private readonly error?: Error,\n  ) {}\n\n  getBundle(): Bundle {\n    return this.bundle;\n  }\n\n  getType(): FrameworkEventType {\n    return this.type;\n  }\n\n  getError(): Error {\n    return this.error;\n  }\n\n  toString(): string {\n    return `${this.bundle.getUniqueIdentifier()} changed state to: ${this.type}.`;\n  }\n}\n","import { Logger, LogLevel } from '@pandino/pandino-api';\n\n/* istanbul ignore file */\nexport class ConsoleLogger implements Logger {\n  constructor(private level: LogLevel = LogLevel.DEBUG) {}\n\n  debug(...data: any[]): void {\n    if (this.level - LogLevel.DEBUG >= 0) {\n      console.debug(new Date().toISOString(), '[DEBUG]', ...data);\n    }\n  }\n\n  error(...data: any[]): void {\n    if (this.level - LogLevel.ERROR >= 0) {\n      console.error(new Date().toISOString(), '[ERROR]', ...data);\n    }\n  }\n\n  info(...data: any[]): void {\n    if (this.level - LogLevel.INFO >= 0) {\n      console.info(new Date().toISOString(), '[INFO]', ...data);\n    }\n  }\n\n  log(...data: any[]): void {\n    if (this.level - LogLevel.LOG >= 0) {\n      console.log(new Date().toISOString(), '[LOG]', ...data);\n    }\n  }\n\n  trace(...data: any[]): void {\n    if (this.level - LogLevel.TRACE >= 0) {\n      console.trace(new Date().toISOString(), '[TRACE]', ...data);\n    }\n  }\n\n  warn(...data: any[]): void {\n    if (this.level - LogLevel.WARN >= 0) {\n      console.warn(new Date().toISOString(), '[WARN]', ...data);\n    }\n  }\n\n  setLogLevel(level: LogLevel): void {\n    this.level = level;\n  }\n}\n","import { ManifestFetcher } from '@pandino/pandino-api';\n\n/* istanbul ignore file */\nexport class VoidFetcher implements ManifestFetcher {\n  fetch(deploymentRoot: string, uri: string): Promise<any> {\n    return Promise.reject(`Will not fetch ${uri}! Please provide explicit Fetcher for Pandino!`);\n  }\n}\n","import { BundleImporter, ImporterReturns } from '@pandino/pandino-api';\n\n/* istanbul ignore file */\nexport class VoidImporter implements BundleImporter {\n  import(activatorLocation: string, manifestLocation: string, deploymentRoot?: string): Promise<ImporterReturns> {\n    return Promise.reject(`Will not import ${activatorLocation}! Please provide explicit Importer for Pandino!`);\n  }\n}\n","import { FilterApi, FilterParser } from '@pandino/pandino-api';\n\nimport Filter from './filter';\n\nexport class FilterParserImpl implements FilterParser {\n  parse(filter: string): FilterApi {\n    return Filter.parse(filter);\n  }\n}\n","import { SemVer, SemverFactory } from '@pandino/pandino-api';\nimport { SemVerImpl } from './semver-impl';\n\nexport class SemverFactoryImpl implements SemverFactory {\n  build(version: string): SemVer {\n    return new SemVerImpl(version);\n  }\n}\n","import {\n  Bundle,\n  BundleImporter,\n  FrameworkEventType,\n  FrameworkListener,\n  BundleActivator,\n  BundleContext,\n  BundleEventType,\n  BundleListener,\n  BundleManifestHeaders,\n  ServiceEvent,\n  ServiceProperties,\n  BundleState,\n  Logger,\n  ManifestFetcher,\n  BUNDLE_ACTIVATOR,\n  BUNDLE_NAME,\n  BUNDLE_SYMBOLICNAME,\n  BUNDLE_VERSION,\n  SYSTEMBUNDLE_ACTIVATORS_PROP,\n  LOG_LOGGER_PROP,\n  LOG_LEVEL_PROP,\n  LogLevel,\n  ServiceListener,\n  FilterApi,\n  ServiceReference,\n  ServiceRegistration,\n  OBJECTCLASS,\n  SYSTEM_BUNDLE_SYMBOLICNAME,\n  PANDINO_BUNDLE_IMPORTER_PROP,\n  PANDINO_MANIFEST_FETCHER_PROP,\n  FRAMEWORK_LOGGER,\n  DEPLOYMENT_ROOT_PROP,\n  FRAMEWORK_MANIFEST_FETCHER,\n  FRAMEWORK_BUNDLE_IMPORTER,\n  SYSTEM_BUNDLE_LOCATION,\n  FRAMEWORK_FILTER_PARSER,\n  FrameworkConfigMap,\n  ServiceFactory,\n  SemVer,\n  FRAMEWORK_SEMVER_FACTORY,\n} from '@pandino/pandino-api';\nimport { BundleImpl } from './lib/framework/bundle-impl';\nimport { EventDispatcher } from './lib/framework/event-dispatcher';\nimport { BundleContextImpl } from './lib/framework/bundle-context-impl';\nimport { BundleEventImpl } from './lib/framework/bundle-event-impl';\nimport { isAllPresent, isAnyMissing } from './lib/utils/helpers';\nimport { StatefulResolver } from './lib/framework/stateful-resolver';\nimport { ServiceRegistryImpl } from './lib/framework/service-registry-impl';\nimport { FrameworkEventImpl } from './lib/framework/framework-event-impl';\nimport { ConsoleLogger } from './lib/utils/console-logger';\nimport Filter from './lib/filter/filter';\nimport { ServiceEventImpl } from './lib/framework/service-event-impl';\nimport { BundleRevisionImpl } from './lib/framework/bundle-revision-impl';\nimport { VoidFetcher } from './lib/utils/void-fetcher';\nimport { VoidImporter } from './lib/utils/void-importer';\nimport { Framework } from './lib/framework/framework';\nimport { ServiceRegistry } from './lib/framework/service-registry';\nimport { ServiceRegistryCallbacks } from './lib/framework/service-registry-callbacks';\nimport { FilterParserImpl } from './lib/filter/filter-parser';\nimport { SemVerImpl } from './lib/utils/semver-impl';\nimport { SemverFactoryImpl } from './lib/utils/semver-factory';\n\nexport class Pandino extends BundleImpl implements Framework {\n  private readonly fetcher: ManifestFetcher;\n  private readonly importer: BundleImporter;\n  private readonly configMap: Map<string, any> = new Map<string, any>();\n  private readonly bundles: Bundle[] = [];\n  private readonly activatorsList: BundleActivator[] = [];\n  private readonly dispatcher: EventDispatcher;\n  private readonly resolver: StatefulResolver;\n  private readonly registry: ServiceRegistry;\n  private nextId = 1;\n\n  constructor(configMap: FrameworkConfigMap) {\n    const deploymentRoot: string | undefined = configMap[DEPLOYMENT_ROOT_PROP];\n    const logger: Logger = isAllPresent(configMap[LOG_LOGGER_PROP]) ? configMap[LOG_LOGGER_PROP] : new ConsoleLogger();\n    const fetcher: ManifestFetcher = isAllPresent(configMap[PANDINO_MANIFEST_FETCHER_PROP])\n      ? configMap[PANDINO_MANIFEST_FETCHER_PROP]\n      : new VoidFetcher();\n    const importer: BundleImporter = isAllPresent(configMap[PANDINO_BUNDLE_IMPORTER_PROP])\n      ? configMap[PANDINO_BUNDLE_IMPORTER_PROP]\n      : new VoidImporter();\n    logger.setLogLevel(configMap[LOG_LEVEL_PROP] || LogLevel.LOG);\n\n    super(\n      logger,\n      0,\n      {\n        [BUNDLE_SYMBOLICNAME]: SYSTEM_BUNDLE_SYMBOLICNAME,\n        [BUNDLE_VERSION]: '0.1.0',\n        [BUNDLE_NAME]: 'Pandino Framework',\n      },\n      '',\n      deploymentRoot,\n    );\n\n    this.fetcher = fetcher;\n    this.importer = importer;\n    Object.keys(configMap).forEach((configKey) => {\n      this.configMap.set(configKey, configMap[configKey]);\n    });\n    if (deploymentRoot) {\n      this.configMap.set(DEPLOYMENT_ROOT_PROP, deploymentRoot);\n    }\n    this.activatorsList = this.configMap.get(SYSTEMBUNDLE_ACTIVATORS_PROP) || [];\n    this.registry = new ServiceRegistryImpl(\n      this.logger,\n      ((pandino) =>\n        new (class implements ServiceRegistryCallbacks {\n          serviceChanged(event: ServiceEvent, oldProps: ServiceProperties): void {\n            pandino.fireServiceEvent(event, oldProps);\n          }\n        })())(this),\n    );\n    this.resolver = new StatefulResolver(this.logger, this, this.registry);\n    this.dispatcher = new EventDispatcher(this.logger);\n    const rev = new BundleRevisionImpl(this, '0', {\n      [BUNDLE_SYMBOLICNAME]: SYSTEM_BUNDLE_SYMBOLICNAME,\n      [BUNDLE_VERSION]: '0.1.0',\n      [BUNDLE_NAME]: 'Pandino Framework',\n    });\n    this.addRevision(rev);\n  }\n\n  getBundleId(): number {\n    return 0;\n  }\n\n  getFramework(): Pandino {\n    return this;\n  }\n\n  getSymbolicName(): string {\n    return this.getHeaders()[BUNDLE_SYMBOLICNAME];\n  }\n\n  getVersion(): SemVer {\n    return new SemVerImpl(this.getHeaders()[BUNDLE_VERSION]);\n  }\n\n  async start(): Promise<void> {\n    try {\n      if (this.getState() === 'INSTALLED') {\n        await this.init();\n      }\n      if (this.getState() === 'STARTING') {\n        this.getBundleContext().registerService(FRAMEWORK_LOGGER, this.logger);\n        this.getBundleContext().registerService(FRAMEWORK_MANIFEST_FETCHER, this.fetcher);\n        this.getBundleContext().registerService(FRAMEWORK_BUNDLE_IMPORTER, this.importer);\n        this.getBundleContext().registerService(FRAMEWORK_FILTER_PARSER, new FilterParserImpl());\n        this.getBundleContext().registerService(FRAMEWORK_SEMVER_FACTORY, new SemverFactoryImpl());\n        this.setBundleStateAndNotify(this, 'ACTIVE');\n      }\n    } catch (err) {\n      this.logger.error(err);\n    }\n\n    this.fireBundleEvent('STARTED', this);\n    this.fireFrameworkEvent('STARTED', this);\n  }\n\n  async init(...listeners: FrameworkListener[]): Promise<void> {\n    try {\n      if (this.getState() === 'INSTALLED') {\n        this.setBundleContext(new BundleContextImpl(this.logger, this, this));\n        this.setState('STARTING');\n        for (const listener of listeners) {\n          this.addFrameworkListener(this, listener);\n        }\n        // try {\n        //   await this.getActivator().start(this.getBundleContext());\n        // } catch (ex) {\n        //   throw new Error('Unable to start system bundle.');\n        // }\n      }\n    } catch (err) {\n      await this.stopBundle(this);\n\n      this.setState('INSTALLED');\n    }\n  }\n\n  async installBundle(origin: Bundle, locationOrHeaders: string | BundleManifestHeaders): Promise<Bundle> {\n    if (this.getState() === 'STOPPING' || this.getState() === 'UNINSTALLED') {\n      throw new Error('The framework has been shutdown.');\n    }\n\n    const resolvedHeaders: BundleManifestHeaders =\n      typeof locationOrHeaders === 'string'\n        ? await this.fetcher.fetch(locationOrHeaders, this.getDeploymentRoot())\n        : locationOrHeaders;\n    let bundle: BundleImpl;\n    let existing: Bundle = this.isBundlePresent(resolvedHeaders);\n\n    if (!existing) {\n      const id = this.getNextId();\n      // FIXME: this could cause issues for loading JS via explicit Header spec!\n      const manifestLocation = typeof locationOrHeaders === 'string' ? locationOrHeaders : '';\n      bundle = new BundleImpl(\n        this.logger,\n        id,\n        resolvedHeaders,\n        manifestLocation,\n        this.getDeploymentRoot(),\n        this,\n        origin,\n      );\n      this.bundles.push(bundle);\n      this.fireBundleEvent('INSTALLED', bundle, origin);\n      this.logger.info(`Installed Bundle: ${resolvedHeaders[BUNDLE_SYMBOLICNAME]}: ${resolvedHeaders[BUNDLE_VERSION]}`);\n      await this.resolver.resolveOne(bundle.getCurrentRevision());\n      return bundle;\n    } else {\n      try {\n        await this.updateBundle(existing as BundleImpl, resolvedHeaders, origin);\n        await this.resolver.resolveOne((existing as BundleImpl).getCurrentRevision());\n        return existing;\n      } catch (err) {\n        this.logger.error(err);\n      }\n    }\n  }\n\n  async updateBundle(bundle: BundleImpl, headers: BundleManifestHeaders, origin: Bundle): Promise<Bundle> {\n    if (bundle.getState() === 'STARTING' || bundle.getState() === 'STOPPING') {\n      throw new Error(\n        'Bundle ' + bundle.getUniqueIdentifier() + ' cannot be updated, since it is either STARTING or STOPPING.',\n      );\n    }\n    let rethrow: Error;\n    const oldState: BundleState = bundle.getState();\n\n    if (oldState === 'ACTIVE') {\n      await this.stopBundle(bundle);\n    }\n\n    try {\n      bundle.revise(headers);\n    } catch (ex) {\n      this.logger.error('Unable to update the bundle.', ex);\n      rethrow = ex;\n    }\n\n    if (isAnyMissing(rethrow)) {\n      this.setBundleStateAndNotify(bundle, 'INSTALLED');\n      this.fireBundleEvent('UNRESOLVED', bundle, origin);\n      this.fireBundleEvent('UPDATED', bundle, origin);\n    }\n\n    if (oldState === 'ACTIVE') {\n      await this.startBundle(bundle);\n    }\n\n    return bundle;\n  }\n\n  async startBundle(bundle: BundleImpl): Promise<void> {\n    this.logger.info(`Starting Bundle: ${bundle.getSymbolicName()}: ${bundle.getVersion()}`);\n    let rethrow: Error;\n    const validStates: BundleState[] = ['INSTALLED'];\n    if (!validStates.includes(bundle.getState())) {\n      throw new Error(\n        `Cannot start ${bundle.getUniqueIdentifier()}, because it\\'s not in any of the valid states: ${validStates.join(\n          ', ',\n        )}.`,\n      );\n    }\n\n    bundle.setBundleContext(new BundleContextImpl(this.logger, bundle, this));\n    this.setBundleStateAndNotify(bundle, 'STARTING');\n\n    try {\n      const revision = bundle.getCurrentRevision();\n      if (isAllPresent(revision.getWiring()) || this.resolver.createWiringForRevision(revision)) {\n        await this.activateBundle(bundle, false);\n      }\n    } catch (ex) {\n      rethrow = ex;\n      this.logger.error(`Error while starting Bundle: ${bundle.getSymbolicName()}: ${bundle.getVersion()}`, ex);\n    }\n\n    if (bundle.getState() === 'ACTIVE') {\n      this.fireBundleEvent('STARTED', bundle);\n      this.logger.info(`Started Bundle: ${bundle.getSymbolicName()}: ${bundle.getVersion()}`);\n      await this.resolver.resolveRemaining();\n    } else {\n      bundle.setState('INSTALLED');\n      this.fireBundleEvent('STOPPED', bundle);\n      if (rethrow) {\n        throw rethrow;\n      }\n    }\n  }\n\n  async activateBundle(bundle: BundleImpl, fireEvent: boolean): Promise<void> {\n    this.logger.info(`Activating Bundle: ${bundle.getSymbolicName()}: ${bundle.getVersion()}`);\n    if (bundle.getState() === 'ACTIVE') {\n      return;\n    }\n\n    let rethrow: Error = null;\n    try {\n      const activator = await this.createBundleActivator(bundle);\n      bundle.setActivator(activator);\n    } catch (th) {\n      rethrow = th;\n    }\n\n    try {\n      this.fireBundleEvent('STARTING', bundle);\n\n      if (isAllPresent(rethrow)) {\n        throw rethrow;\n      }\n\n      if (isAllPresent(bundle.getActivator())) {\n        await bundle.getActivator().start(bundle.getBundleContext());\n      }\n\n      this.setBundleStateAndNotify(bundle, 'ACTIVE');\n      if (fireEvent) {\n        this.fireBundleEvent('STARTED', bundle);\n      }\n    } catch (th) {\n      this.logger.error(th);\n      this.fireBundleEvent('STOPPING', bundle);\n\n      this.setBundleStateAndNotify(bundle, 'INSTALLED');\n\n      bundle.setActivator(null);\n\n      const bci: BundleContextImpl = bundle.getBundleContext() as BundleContextImpl;\n      bci.invalidate();\n      bci.closeTrackers();\n      bundle.setBundleContext(null);\n\n      this.registry.unregisterServices(bundle);\n      this.registry.ungetServices(bundle);\n      this.dispatcher.removeListeners(bci);\n\n      // Rethrow all other exceptions as a BundleException.\n      throw new Error('Activator start error in bundle ' + bundle + ': ' + th);\n    }\n  }\n\n  async stopBundle(bundle: BundleImpl): Promise<void> {\n    try {\n      let error: Error;\n      let wasActive = false;\n\n      switch (bundle.getState()) {\n        case 'UNINSTALLED':\n          throw new Error('Cannot stop an uninstalled bundle.');\n        case 'STARTING':\n        case 'STOPPING':\n          throw new Error('Stopping a starting or stopping bundle is currently not supported.');\n        case 'INSTALLED':\n          return;\n        case 'ACTIVE':\n          wasActive = true;\n          break;\n      }\n\n      this.logger.info(`Stopping Bundle: ${bundle.getUniqueIdentifier()}...`);\n      bundle.setState('STOPPING');\n      this.fireBundleEvent('STOPPING', bundle);\n\n      if (wasActive || bundle.getBundleId() === 0) {\n        try {\n          if (typeof bundle.getActivator()?.stop === 'function') {\n            await bundle.getActivator().stop(bundle.getBundleContext());\n          }\n        } catch (err) {\n          error = err;\n        }\n      }\n\n      if (bundle.getBundleId() !== 0) {\n        bundle.setActivator(null);\n        const bci: BundleContextImpl = bundle.getBundleContext() as BundleContextImpl;\n        bci.invalidate();\n        bci.closeTrackers();\n        bundle.setBundleContext(null);\n\n        // Unregister any services offered by this bundle.\n        this.registry.unregisterServices(bundle);\n\n        // Release any services being used by this bundle.\n        this.registry.ungetServices(bundle);\n\n        // The spec says that we must remove all event listeners for a bundle when it is stopped.\n        this.dispatcher.removeListeners(bci);\n\n        // tear down wires where bundle was a requirement for others\n        bundle.getCurrentRevision().resolve(undefined);\n\n        bundle.setState('INSTALLED');\n      }\n\n      if (!!error) {\n        throw new Error('Activator stop error in bundle ' + bundle + ': ' + error);\n      }\n    } finally {\n    }\n\n    for (const requirer of this.resolver.getActiveRequirers(bundle)) {\n      await this.stopBundle(requirer);\n    }\n\n    this.logger.info(`Stopped Bundle: ${bundle.getUniqueIdentifier()}...`);\n    this.fireBundleEvent('STOPPED', bundle);\n  }\n\n  getBundle(id: number): Bundle {\n    return this.bundles.find((b) => b.getBundleId() === id);\n  }\n\n  isBundlePresent(headers: BundleManifestHeaders): Bundle | undefined {\n    return this.bundles.find((b) => b.getSymbolicName() === headers[BUNDLE_SYMBOLICNAME]);\n  }\n\n  fireBundleEvent(type: BundleEventType, bundle: Bundle, origin?: Bundle): void {\n    this.dispatcher.fireBundleEvent(new BundleEventImpl(bundle, type, origin), this);\n  }\n\n  fireFrameworkEvent(type: FrameworkEventType, bundle: Bundle, error?: Error): void {\n    this.dispatcher.fireFrameworkEvent(new FrameworkEventImpl(type, bundle, error), this);\n  }\n\n  getProperty(key: string): string {\n    return this.configMap.get(key);\n  }\n\n  getBundles(bc?: BundleContext): Bundle[] {\n    return [...this.bundles];\n  }\n\n  addBundleListener(bundle: BundleImpl, l: BundleListener): void {\n    this.dispatcher.addListener(bundle.getBundleContext(), 'BUNDLE', l, null);\n  }\n\n  removeBundleListener(bundle: BundleImpl, l: BundleListener): void {\n    this.dispatcher.removeListener(bundle.getBundleContext(), 'BUNDLE', l);\n  }\n\n  addServiceListener(bundle: BundleImpl, listener: ServiceListener, filter?: string): void {\n    const newFilter: FilterApi = isAnyMissing(filter) ? null : Filter.parse(filter);\n\n    this.dispatcher.addListener(bundle.getBundleContext(), 'SERVICE', listener, newFilter);\n  }\n\n  removeServiceListener(bundle: BundleImpl, l: ServiceListener): void {\n    this.dispatcher.removeListener(bundle.getBundleContext(), 'SERVICE', l);\n  }\n\n  addFrameworkListener(bundle: BundleImpl, l: FrameworkListener): void {\n    this.dispatcher.addListener(bundle.getBundleContext(), 'FRAMEWORK', l, null);\n  }\n\n  removeFrameworkListener(bundle: BundleImpl, l: FrameworkListener): void {\n    this.dispatcher.removeListener(bundle.getBundleContext(), 'FRAMEWORK', l);\n  }\n\n  getConfig(): Record<string, any> {\n    return this.configMap;\n  }\n\n  getActivatorsList(): BundleActivator[] {\n    return this.activatorsList;\n  }\n\n  fireServiceEvent(event: ServiceEvent, oldProps: Record<string, any>): void {\n    this.dispatcher.fireServiceEvent(event, oldProps);\n  }\n\n  setBundleStateAndNotify(bundle: BundleImpl, state: BundleState): void {\n    bundle.setState(state);\n  }\n\n  getResolver(): StatefulResolver {\n    return this.resolver;\n  }\n\n  async uninstallBundle(bundle: BundleImpl): Promise<void> {\n    this.logger.info(`Uninstalling Bundle: ${bundle.getUniqueIdentifier()}...`);\n    const desiredStates: BundleState[] = ['INSTALLED', 'STARTING', 'ACTIVE', 'STOPPING'];\n\n    if (!desiredStates.includes(bundle.getState())) {\n      if (bundle.getState() === 'UNINSTALLED') {\n        throw new Error('Cannot uninstall an uninstalled bundle.');\n      } else {\n        throw new Error(\n          `Bundle ${bundle.getUniqueIdentifier()} cannot be uninstalled because it is in an undesired state: ${bundle.getState()}`,\n        );\n      }\n    }\n\n    if (bundle.getState() === 'STARTING' || bundle.getState() === 'STOPPING') {\n      throw new Error(\n        'Bundle ' + bundle.getUniqueIdentifier() + ' cannot be uninstalled, since it is either STARTING or STOPPING.',\n      );\n    }\n\n    let errored = null;\n\n    if (bundle.getState() === 'ACTIVE') {\n      try {\n        await this.stopBundle(bundle);\n      } catch (err) {\n        this.logger.error(`Error stopping bundle: ${bundle.getUniqueIdentifier()}`, err);\n        this.fireFrameworkEvent('ERROR', bundle, err);\n        errored = err;\n      }\n    }\n\n    this.fireBundleEvent('UNRESOLVED', bundle);\n    if (!errored) {\n      bundle.setState('UNINSTALLED');\n      this.fireBundleEvent('UNINSTALLED', bundle);\n      this.logger.info(`Uninstalled bundle: ${bundle.getUniqueIdentifier()}`);\n    }\n  }\n\n  getAllowedServiceReferences(\n    bundle: BundleImpl,\n    className?: string,\n    expr?: string,\n    checkAssignable = false,\n  ): ServiceReference<any>[] {\n    const refs: ServiceReference<any>[] = this.getServiceReferences(bundle, className, expr, checkAssignable);\n\n    return isAnyMissing(refs) ? [] : [...refs];\n  }\n\n  private getServiceReferences(\n    bundle: BundleImpl,\n    className?: string,\n    expr?: string,\n    checkAssignable = false,\n  ): ServiceReference<any>[] {\n    let filter: FilterApi = null;\n    if (isAllPresent(expr)) {\n      filter = Filter.parse(expr);\n    }\n\n    const refList = this.registry.getServiceReferences(className, filter) as unknown as ServiceReference<any>[];\n    const effectiveRefList: ServiceReference<any>[] = [];\n\n    if (checkAssignable) {\n      for (const ref of refList) {\n        if (Pandino.isServiceAssignable(bundle, ref)) {\n          effectiveRefList.push(ref);\n        }\n      }\n    }\n\n    if (effectiveRefList.length > 0) {\n      return effectiveRefList;\n    }\n\n    return [];\n  }\n\n  private getNextId(): number {\n    const n = this.nextId;\n    this.nextId++;\n    return n;\n  }\n\n  private async createBundleActivator(impl: BundleImpl): Promise<BundleActivator> {\n    let activator: BundleActivator = null;\n    let headerMap: BundleManifestHeaders = impl.getHeaders();\n    let activatorDefinition = headerMap[BUNDLE_ACTIVATOR];\n    if (isAnyMissing(activatorDefinition)) {\n      throw new Error('Missing mandatory Bundle Activator!');\n    } else if (typeof activatorDefinition === 'string') {\n      this.logger.debug(`Attempting to load Activator from: ${activatorDefinition}`);\n      let activatorInstance: any;\n      try {\n        activatorInstance = (\n          await this.importer.import(activatorDefinition, this.getLocation(), this.getDeploymentRoot())\n        ).default;\n      } catch (ex) {\n        throw new Error('Not found: ' + activatorDefinition + ': ' + ex);\n      }\n      activator =\n        typeof activatorInstance === 'function' ? (new activatorInstance() as BundleActivator) : activatorInstance;\n    } else {\n      return impl.getActivator();\n    }\n\n    return activator;\n  }\n\n  private static isServiceAssignable(requester: Bundle, ref: ServiceReference<any>): boolean {\n    let allow = true;\n    const objectClass: string[] | string = ref.getProperty(OBJECTCLASS);\n\n    if (Array.isArray(objectClass)) {\n      for (let classIdx = 0; allow && classIdx < objectClass.length; classIdx++) {\n        if (!ref.isAssignableTo(requester, objectClass[classIdx])) {\n          allow = false;\n        }\n      }\n    } else {\n      if (!ref.isAssignableTo(requester, objectClass)) {\n        allow = false;\n      }\n    }\n\n    return allow;\n  }\n\n  getService<S>(bundle: Bundle, ref: ServiceReference<S>, isServiceObjects: boolean): S | undefined {\n    try {\n      return this.registry.getService(bundle, ref, isServiceObjects);\n    } catch (ex) {\n      this.fireFrameworkEvent('ERROR', bundle, ex);\n    }\n\n    return undefined;\n  }\n\n  ungetService(bundle: Bundle, ref: ServiceReference<any>, srvObj: any): boolean {\n    return this.registry.ungetService(bundle, ref, srvObj);\n  }\n\n  registerService<S>(\n    context: BundleContextImpl,\n    identifier: string[] | string,\n    svcObj: S | ServiceFactory<S>,\n    dict: Record<any, any>,\n  ): ServiceRegistration<S> {\n    let reg = this.registry.registerService(context.getBundle(), identifier, svcObj, dict);\n\n    this.fireServiceEvent(new ServiceEventImpl('REGISTERED', reg.getReference()), {});\n\n    return reg;\n  }\n\n  getLocation(): string {\n    return SYSTEM_BUNDLE_LOCATION;\n  }\n\n  getBundleRegisteredServices(bundle: BundleImpl): ServiceReference<any>[] {\n    if (bundle.getState() === 'UNINSTALLED') {\n      throw new Error('The bundle is uninstalled.');\n    }\n\n    return this.registry.getRegisteredServices(bundle);\n  }\n}\n"],"names":["BUNDLE_NAMESPACE","LogLevel","isAnyMissing","parameters","param","isAllPresent","BundleCapabilityImpl","revision","namespace","dirs","attrs","uses","mandatory","Set","constructor","this","value","split","map","i","trim","u","push","names","ManifestParserImpl","parseDelimitedString","name","hasOwnProperty","Error","add","equals","other","getVersion","compare","getNamespace","getAttributes","getDirectives","getResource","getRevision","isAttributeMandatory","size","has","getUses","toString","stringifyAttributes","Object","keys","key","join","ParsedHeaderClause","paths","types","peg$SyntaxError","message","expected","found","location","captureStackTrace","child","parent","ctor","prototype","peg$subclass","replaceMap","Map","inverseMap","FilterComp","Filter","attrib","comp","filters","type","static","Attribute","input","undefined","MATCH_ALL","newInput","original","replaceVal","entries","replace","RegExp","originalFilter","peg$result","options","arguments","length","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","filter","peg$c1","peg$c2","peg$c3","description","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","AND","peg$c9","peg$c10","peg$c11","OR","peg$c12","peg$c13","peg$c14","NOT","peg$c15","attr","attribute","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","present","peg$c27","EQ","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","opts","shift","peg$c34","peg$c35","oid","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","char","String","fromCharCode","peg$c50","parseInt","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$currPos","peg$posDetailsCache","line","column","seenCR","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","peg$computePosDetails","pos","p","ch","details","charAt","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","end","peg$fail","peg$buildException","sort","a","b","splice","cleanupExpected","expectedDesc","foundDesc","expectedDescs","Array","slice","s","hex","charCodeAt","toUpperCase","stringEscape","buildMessage","s0","s1","s2","peg$parsefilter","peg$parseFILL","peg$parseitem","s3","s4","s5","s6","peg$parsefiltercomp","peg$parseand","peg$parseor","peg$parsenot","peg$parsefilterlist","peg$parsesubstring","peg$parsesimple","peg$parsepresent","peg$parseAttributeDescription","peg$parsefiltertype","peg$parsevalue","peg$parseequal","peg$parseapprox","peg$parsegreater","peg$parseless","substr","s7","peg$parseany","substring","peg$parseAttributeValue","peg$parseAttributeType","peg$parseoptions","peg$parseLDAP_OID","peg$parseALPHA","peg$parseAttrTypeChars","peg$parseDIGIT","peg$parseoption","peg$parseEscapedCharacter","test","peg$parseASCII_VALUE","peg$parseHEX_CHAR","peg$parseSPACE","peg$parseTAB","peg$parseSEP","peg$parse","recursiveReplace","f","_","parse","match","data","attrv","_match","matchString","matchLTE","matchGTE","simplify","_indent","indent","level","id_char","_i","isNaN","indent_char","repeat","c","escapeChars","indexOf","chars","out","tmp","isArray","some","cv","toLowerCase","unescape","matchSubstring","pattern","m","$1","regex","GroupAnd","GroupOr","GroupNot","Group","super","id_str","id_str2","nl","item","every","raw","equalTo","escape","endsWith","startsWith","contains","approx","APPROX","lte","LTE","gte","GTE","rv","l","MAX_SAFE_INTEGER","Number","REGEX_FULL_VERSION","REGEX_NUMERIC","SemverVersion","rawVersion","major","minor","patch","prereleaseArray","prerelease","build","mainVersion","version","TypeError","matches","_isThrowVersionNumericError","id","num","versionNumber","versionName","_isNumeric","numeric","_padNumber","fill","mainVersionToNumeric","digit","numericStr","needCompareBuildVersion","otherSemver","result","compareMainVersion","comparePreReleaseVersion","compareBuildVersion","compareNumeric","compareIdentifiers","aIsNumeric","bIsNumeric","equal","SemVerImpl","neq","CapabilitySet","indices","capSet","indexProps","indexProp","sf","obeyMandatory","matchCapSet","matchMandatoryCapSet","addCapability","cap","index","o","indexCapability","removeCapability","hadCap","delete","eValue","deindexCapability","matchesInternal","matchMandatory","matchMandatoryAttribute","attrName","list","sf2","lhs","rhsUnknown","cmp","PRESENT","rhs","capValue","caps","prevVal","forEach","sfs","existingCaps","matched","BundleRequirementImpl","optional","convert","capability","getFilter","isOptional","configMap","headerMap","requirements","capabilities","bundleSymbolicName","bundleVersion","activationIncludeDir","activationExcludeDir","activationPolicy","owner","capList","EMPTY_VERSION","ex","getManifestVersion","bundleCap","parseBundleSymbolicName","addIdentityCapability","rbClauses","parseStandardHeader","normalizeRequireClauses","rbReqs","convertRequires","requireCaps","part","getRequiredClauses","provideCaps","getProviderClauses","parseActivationPolicy","provideClauses","normalizeCapabilityClauses","convertProvideCapabilities","convertRequireCapabilities","getActivationIncludeDirective","getActivationExcludeDirective","getActivationPolicy","getSymbolicName","getBundleVersion","getName","path","idx","lastIndexOf","getCapabilities","getRequirements","delim","sb","expecting","CHAR","isEscaped","isDelimiter","manifestVersion","clauses","mv","symName","header","clause","semiColons","trimValue","isDirective","includes","isAttribute","dirKey","dirValue","attrKey","attrValue","valueEscaped","attrKeyTyped","attrType","startIdx","endIdx","listType","tokens","values","token","singleton","reqList","newAttrs","newDirs","FILTER_DIRECTIVE","filterStr","BundleRevisionImpl","symbolicName","declaredCaps","declaredReqs","bundle","declaredActivationPolicy","wiring","mp","getFramework","getConfig","getDeclaredActivationPolicy","getBundle","getDeclaredCapabilities","getDeclaredRequirements","req","getWiring","getHeaders","getId","resolve","BundleImpl","manifestLocation","deploymentRoot","headers","pandino","installingBundle","useDeclaredActivationPolicy","activator","context","state","revisions","currentRevision","logger","createRevision","addRevision","getRegisteredServices","getBundleRegisteredServices","getServicesInUse","getBundleId","getBundleContext","setBundleContext","getState","setState","getCurrentRevision","async","startBundle","stopBundle","uninstallBundle","updateBundle","getUniqueIdentifier","getActivator","setActivator","getDeploymentRoot","revise","updatedRevision","current","isRemovalPending","closeRevisions","getResolver","removeRevision","collisionCandidates","bundles","getBundles","br","unshift","getRevisions","getLocation","ListenerInfo","listener","info","getListener","getParsedFilter","ServiceEventImpl","reference","getServiceReference","getType","getProperty","EventDispatcher","svcListeners","bndListeners","fwkListeners","fireServiceEvent","event","oldProps","listeners","fireEventImmediately","fireFrameworkEvent","source","fireBundleEvent","ctx","lstnrs","invokeFrameworkListenerCallback","invokeBundleListenerCallback","invokeServiceListenerCallback","serviceChanged","se","isSync","setTimeout","bundleChanged","frameworkEvent","addListener","bc","oldFilter","updateListener","addListenerInfo","removeListener","infos","removeListenerInfo","removeListeners","removeListenerInfos","copy","get","set","err","newInfo","updateListenerInfo","ServiceObjectsImpl","ref","getService","checkValidity","ungetService","service","AbstractTracked","closed","trackingCount","tracked","adding","initial","setInitial","trackInitial","trackAdding","close","track","related","object","modified","customizerModified","untrack","initialIdx","findIndex","addingIdx","customizerRemoved","isEmpty","getCustomizedObject","copyKeys","from","getTrackingCount","becameUntracked","customizerAdding","Tracked","tracker","customizer","addingBundle","modifiedBundle","removedBundle","getTrackedStates","addingService","modifiedService","removedService","AllTracked","BundleContextImpl","valid","bundleTrackers","serviceTrackers","addBundleListener","removeBundleListener","addFrameworkListener","removeFrameworkListener","createFilter","locationOrHeaders","debug","installBundle","addServiceListener","identifier","refs","getServiceReferences","getBestServiceReference","error","getAllServiceReferences","getAllowedServiceReferences","registerService","identifiers","properties","removeServiceListener","getServiceObjects","getRegistration","isValid","invalidate","trackBundle","trackedStates","self","open","t","outgoing","getObject","remove","trackService","identifierOrFilter","listenerFilter","cachedReference","cachedService","references","getInitialReferences","getServiceForReference","rankings","count","maxRanking","MIN_VALUE","property","ranking","minId","MAX_VALUE","getServices","objects","filterString","closeTrackers","bestRef","compareTo","BundleEventImpl","origin","getOrigin","BundleWireImpl","requirer","provider","getRequirement","getCapability","getRequirer","getProvider","BundleWiringImpl","resolver","wires","resolvedCaps","resolvedReqs","isDisposed","bw","resolution","effective","dispose","isCurrent","isInUse","getResourceCapabilities","getProvidedWires","getRequiredWires","searchReqs","getResourceRequirements","StatefulResolver","registry","bundleWiring","resolveRemaining","revsToReRun","r","getResolvableWires","getEligibleCapabilities","canBundleBeResolved","rev","resolveOne","getActiveRequirers","wirings","wire","find","activeRevisions","createWiringForRevision","reqs","wireCaps","w","allProvidedCapabilities","providedCap","impl","ServiceReferenceImpl","reg","otherId","rankObj","otherRankObj","rank","otherRank","getProperties","getPropertyKeys","getUsingBundles","isAssignableTo","className","allow","pkgName","getClassPackage","requesterRevision","requesterWire","getWire","requesterCap","getPackageCapability","providerRevision","providerWire","providerCap","hasObjectClass","objectClass","classOrArray","ServiceRegistrationImpl","classes","serviceId","svcObj","factory","propMap","isUnregistering","classNames","dict","factoryType","initializeProperties","acqBundle","getFactoryUnchecked","relBundle","ungetFactoryUnchecked","e","getLogger","getReference","JSON","stringify","setProperties","servicePropertiesModified","unregister","unregisterService","props","assign","UsageCountImpl","serviceObjectsCount","isProto","isPrototype","getCount","getServiceObjectsCount","incrementToPositiveValue","incrementServiceObjectsCountToPositiveValue","incrementAndGet","decrementAndGet","serviceObjectsDecrementAndGet","setService","ServiceRegistryImpl","callbacks","regsMap","regCapSet","inUseMap","currentServiceId","regs","isServiceObjects","usage","obtainUsageCount","existingUsage","flushUsageCount","filterEffective","usages","warn","remIdx","ungetServicesByRef","svc","uc","processUsage","usageIdx","newUsages","unregisterServices","ungetServices","clients","client","getInUseMap","FrameworkEventImpl","getError","ConsoleLogger","DEBUG","console","Date","toISOString","ERROR","INFO","log","LOG","trace","TRACE","WARN","setLogLevel","VoidFetcher","fetch","uri","Promise","reject","VoidImporter","import","activatorLocation","FilterParserImpl","SemverFactoryImpl","Pandino","fetcher","importer","activatorsList","dispatcher","nextId","configKey","init","setBundleStateAndNotify","resolvedHeaders","existing","isBundlePresent","getNextId","rethrow","oldState","validStates","activateBundle","fireEvent","createBundleActivator","th","bci","wasActive","stop","newFilter","getActivatorsList","errored","expr","checkAssignable","refList","effectiveRefList","isServiceAssignable","n","activatorDefinition","activatorInstance","default","requester","classIdx","srvObj"],"mappings":"AAGA,MAKMA,EAAmB,wBAkSzB,IAAIC,EC1SY,SAAAC,KAAgBC,GAC9B,IAAK,MAAMC,KAASD,EAClB,GAAIC,QACF,OAAO,EAGX,OAAO,CACT,CAEgB,SAAAC,KAAgBF,GAC9B,OAAQD,KAAgBC,EAC1B,EDgSA,SAAWF,GACPA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAc,IAAI,GAAK,MAChCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,OACrC,CAPD,CAOGA,IAAaA,EAAW,CAAA,UE5SdK,EACMC,SACAC,UACAC,KAA+B,CAAA,EAC/BC,MAA6B,CAAA,EAC7BC,KAAiB,GACjBC,UAAyB,IAAIC,IAE9CC,YACEP,EACAC,EACAC,EAA+B,CAAE,EACjCC,EAA6B,IAE7BK,KAAKR,SAAWA,EAChBQ,KAAKP,UAAYA,EACjBO,KAAKN,KAAOA,EACZM,KAAKL,MAAQA,EAEb,IAAIM,EAAQD,KAAKN,KAAmB,KACpC,GAAIO,QAAuC,CACzC,MAAML,EAAiBK,EAAMC,MAAM,KAAKC,KAAKC,GAAMA,EAAEC,SACrD,IAAK,MAAMC,KAAKV,EACdI,KAAKJ,KAAKW,KAAKD,EAElB,CAED,IAAIT,EAAyB,IAAIC,IAEjC,GADAG,EAAQD,KAAKN,KAAwB,UACjCO,QAAuC,CACzC,MAAMO,EAAQC,EAAmBC,qBAAqBT,EAAO,KAC7D,IAAK,IAAIU,KAAQH,EAAO,CACtB,IAAIR,KAAKL,MAAMiB,eAAeD,GAG5B,MAAM,IAAIE,MAAM,wBAA0BF,EAAO,qBAFjDd,EAAUiB,IAAIH,EAIjB,CACF,CACDX,KAAKH,UAAYA,CAClB,CAEDkB,OAAOC,GACL,OAAI7B,EAAa6B,IAAYA,aAAiBzB,IAIwB,IAApES,KAAKR,SAASyB,aAAaC,QAAQF,EAAMxB,SAASyB,eAClDjB,KAAKmB,iBAAmBH,EAAMG,eAKjC,CAEDC,gBACE,OAAOpB,KAAKL,KACb,CAED0B,gBACE,OAAOrB,KAAKN,IACb,CAEDyB,eACE,OAAOnB,KAAKP,SACb,CAED6B,cACE,OAAOtB,KAAKR,QACb,CAED+B,cACE,OAAOvB,KAAKR,QACb,CAEDgC,qBAAqBb,GACnB,OAAOX,KAAKH,UAAU4B,KAAO,GAAKzB,KAAKH,UAAU6B,IAAIf,EACtD,CAEDgB,UACE,OAAO3B,KAAKJ,IACb,CAEDgC,WACE,OAAIzC,EAAaa,KAAKR,UACbQ,KAAK6B,sBAEP,IAAM7B,KAAKR,SAAW,KAAOQ,KAAKP,UAAY,KAAOO,KAAK6B,qBAClE,CAEOA,sBAEN,MAAO,GADgBC,OAAOC,KAAK/B,KAAKL,OAAOQ,KAAK6B,GAAQ,GAAGA,KAAOhC,KAAKL,MAAMqC,OAClEC,KAAK,OACrB,QCnGUC,EACKC,MACAzC,KACAC,MACAyC,MAEhBrC,YACEoC,EACAzC,EACAC,EACAyC,GAEApC,KAAKmC,MAAQA,EACbnC,KAAKN,KAAOA,EACZM,KAAKL,MAAQA,EACbK,KAAKoC,MAAQA,CACd,ECJH,SAASC,EAAgBC,EAAcC,EAAeC,EAAYC,GAChEzC,KAAKsC,QAAUA,EACftC,KAAKuC,SAAWA,EAChBvC,KAAKwC,MAAQA,EACbxC,KAAKyC,SAAWA,EAChBzC,KAAKW,KAAO,cAE2B,mBAA5BE,MAAM6B,mBACf7B,MAAM6B,kBAAkB1C,KAAMqC,EAElC,EAnBA,SAAsBM,EAAYC,GAChC,SAASC,IACP7C,KAAKD,YAAc4C,CACpB,CACDE,EAAKC,UAAYF,EAAOE,UAExBH,EAAMG,UAAY,IAAID,CACxB,CAcAE,CAAaV,EAAiBxB,OCZvB,MAAMmC,EAAkC,IAAIC,IAAoB,CACrE,CLyHiB,aKzHJ,aACb,CL2IsB,kBK3IJ,kBAClB,CLmJuB,mBKnJJ,mBACnB,CLgKoB,gBKhKJ,gBAChB,CLqJ0B,sBKrJJ,wBAGXC,EAAkC,IAAID,IAAoB,CACrE,CAAC,YLiHgB,cKhHjB,CAAC,iBLmIqB,mBKlItB,CAAC,kBL2IsB,oBK1IvB,CAAC,eLwJmB,iBKvJpB,CAAC,qBL6IyB,yBMlK5B,IAAYE,GAAZ,SAAYA,GACVA,EAAA,IAAA,IACAA,EAAA,IAAA,IACAA,EAAA,GAAA,IACAA,EAAA,GAAA,IACAA,EAAA,IAAA,KACAA,EAAA,IAAA,KACAA,EAAA,OAAA,KACAA,EAAA,UAAA,IACAA,EAAA,QAAA,IACD,CAVD,CAAYA,IAAAA,EAUX,CAAA,IAEa,MAAOC,EAGAC,OAAuBC,KAAyBrD,MAAmBsD,QAFtEC,KAAY,SAE5BzD,YAAmBsD,EAAuBC,EAAyBrD,EAAmBsD,EAAoB,IAAvFvD,KAAMqD,OAANA,EAAuBrD,KAAIsD,KAAJA,EAAyBtD,KAAKC,MAALA,EAAmBD,KAAOuD,QAAPA,CAA0B,CAEhHE,iBAAiB9C,GACf,OAAO,IAAI+C,EAAU/C,EACtB,CAED8C,aAAaE,GACX,GAAc,QAAVA,EACF,OAAO,IAAIP,OAAOQ,EAAWT,EAAWU,eAAWD,GAGrD,IAAIE,EAAWH,EACf,IAAK,MAAOI,EAAUC,KAAehB,EAAWiB,UAC9CH,EAAWA,EAASI,QAAQ,IAAIC,OAAOJ,EAAU,KAAMC,GAGzD,MAAMI,EFTV,SAAmBT,GACjB,IAwHEU,EAxHEC,EAAUC,UAAUC,OAAS,EAAID,UAAU,GAAK,GAClDE,EAAa,CAAA,EACbC,EAA8B,CAAEC,MAAOC,IACvCC,EAAwBD,GACxBE,EAAS,SAAUC,GACjB,OAAOA,CACT,EACAC,EAAS,SAAUD,GAEjB,OADAA,EAAO9E,MAAQ8E,EAAO9E,MAAMiE,QAAQ,MAAO,IACpCa,CACT,EACAE,EAAS,IACTC,EAAS,CAAE1B,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACrDC,EAAS,IACTC,EAAS,CAAE7B,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACrDG,EAAS,IACTC,EAAS,CAAE/B,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACrDK,EAAS,SAAUjC,GACjB,OAAOH,EAAOqC,IAAIlC,IAEpBmC,EAAS,IACTC,EAAU,CAAEnC,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDS,EAAU,SAAUrC,GAClB,OAAOH,EAAOyC,GAAGtC,IAEnBuC,EAAU,IACVC,EAAU,CAAEvC,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDa,EAAU,SAAUjB,GAClB,OAAO3B,EAAO6C,IAAIlB,EACnB,EACDmB,EAAU,SAAUC,EAAW7C,EAAWrD,GACxC,OAAO,IAAImD,EAAO+C,EAAKC,UAAW9C,EAAMrD,EACzC,EACDoG,EAAU,IACVC,EAAU,CAAE9C,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDoB,EAAU,KACVC,EAAU,CAAEhD,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,QACvDsB,EAAU,KACVC,EAAU,CAAElD,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,QACvDwB,EAAU,KACVC,EAAU,CAAEpD,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,QACvD0B,EAAU,KACVC,EAAU,CAAEtD,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,QACvD4B,EAAU,SAAUZ,GAClB,OAAO/C,EAAOgD,UAAUD,EAAKC,WAAWY,SACzC,EACDC,EAAU,SAAUd,EAAWlG,GAC7B,OAAO,IAAImD,EAAO+C,EAAKC,UAAWjD,EAAW+D,GAAIjH,IAEnDkH,EAAU,IACVC,EAAU,CAAE5D,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDkC,EAAU,CAAE7D,KAAM,QAAS2B,YAAa,yBACxCmC,EAAU,IACVC,EAAU,CAAE/D,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDqC,EAAU,SAAUrB,EAAWsB,GAO7B,OANIA,IACFA,EAAKC,QAELD,GADAA,EAAOA,EAAKC,SACAxH,MAAM,MAEpBiG,EAAK7B,QAAUmD,GAAQ,GAChBtB,CACT,EACAwB,EAAU,CAAEnE,KAAM,QAAS2B,YAAa,kBACxCyC,EAAU,SAAUC,GAClB,MAAO,CACLrE,KAAM,MACN4C,UAAWyB,EAEf,EACAC,EAAU,SAAUnH,GAClB,MAAO,CACL6C,KAAM,YACN4C,UAAWzF,EAEf,EACAoH,EAAU,CAAEvE,KAAM,QAAS2B,YAAa,wBACxC6C,EAAU,IACVC,EAAU,CAAEzE,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtD+C,EAAU,CAAE1E,KAAM,QAAS2B,YAAa,OACxCgD,EAAU,IACVC,EAAU,CAAE5E,KAAM,UAAWvD,MAAO,IAAKkF,YAAa,OACtDkD,EAAU,CAAE7E,KAAM,QAAS2B,YAAa,qBACxCmD,EAAU,CAAE9E,KAAM,QAAS2B,YAAa,oBACxCoD,GAAU,QACVC,GAAU,CAAEhF,KAAM,QAASvD,MAAO,WAAYkF,YAAa,YAC3DsD,GAAU,KACVC,GAAU,CAAElF,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,UACvDwD,GAAU,SAAUC,GAClB,OAAOC,OAAOC,aAAaF,EAC7B,EACAG,GAAU,SAAU9I,GAClB,OAAO+I,SAAS/I,EAAO,GACzB,EACAgJ,GAAU,eACVC,GAAU,CAAE1F,KAAM,QAASvD,MAAO,cAAekF,YAAa,eAC9DgE,GAAU,CAAE3F,KAAM,QAAS2B,YAAa,cACxCiE,GAAU,CAAE5F,KAAM,QAAS2B,YAAa,SACxCkE,GAAU,OACVC,GAAU,CAAE9F,KAAM,QAASvD,MAAO,UAAWkF,YAAa,WAC1DoE,GAAU,CAAE/F,KAAM,QAAS2B,YAAa,OACxCqE,GAAU,QACVC,GAAU,CAAEjG,KAAM,QAASvD,MAAO,UAAWkF,YAAa,WAC1DuE,GAAU,CAAElG,KAAM,QAAS2B,YAAa,SACxCwE,GAAU,SACVC,GAAU,CAAEpG,KAAM,QAASvD,MAAO,QAASkF,YAAa,SACxD0E,GAAU,CAAErG,KAAM,QAAS2B,YAAa,SACxC2E,GAAU,YACVC,GAAU,CAAEvG,KAAM,QAASvD,MAAO,WAAYkF,YAAa,YAC3D6E,GAAU,CAAExG,KAAM,QAAS2B,YAAa,WACxC8E,GAAU,OACVC,GAAU,CAAE1G,KAAM,UAAWvD,MAAO,OAAQkF,YAAa,YACzDgF,GAAU,KACVC,GAAU,CAAE5G,KAAM,UAAWvD,MAAO,KAAMkF,YAAa,SACvDkF,GAAc,EAEdC,GAAsB,CAAC,CAAEC,KAAM,EAAGC,OAAQ,EAAGC,QAAQ,IACrDC,GAAiB,EACjBC,GAA6B,GAC7BC,GAAkB,EAGpB,GAAI,cAAetG,EAAS,CAC1B,KAAMA,EAAQuG,aAAanG,GACzB,MAAM,IAAI7D,MAAM,mCAAqCyD,EAAQuG,UAAY,MAG3EhG,EAAwBH,EAAuBJ,EAAQuG,UACxD,CA4BD,SAASC,GAAsBC,GAC7B,IACEC,EACAC,EAFEC,EAAUZ,GAAoBS,GAIlC,GAAIG,EACF,OAAOA,EAGP,IADAF,EAAID,EAAM,GACFT,GAAoBU,IAC1BA,IAUF,IAPAE,EAAUZ,GAAoBU,GAC9BE,EAAU,CACRX,KAAMW,EAAQX,KACdC,OAAQU,EAAQV,OAChBC,OAAQS,EAAQT,QAGXO,EAAID,GACTE,EAAKtH,EAAMwH,OAAOH,GACP,OAAPC,GACGC,EAAQT,QACXS,EAAQX,OAEVW,EAAQV,OAAS,EACjBU,EAAQT,QAAS,GACD,OAAPQ,GAAsB,WAAPA,GAA0B,WAAPA,GAC3CC,EAAQX,OACRW,EAAQV,OAAS,EACjBU,EAAQT,QAAS,IAEjBS,EAAQV,SACRU,EAAQT,QAAS,GAGnBO,IAIF,OADAV,GAAoBS,GAAOG,EACpBA,CAEV,CAED,SAASE,GAAoBC,EAAeC,GAC1C,IAAIC,EAAkBT,GAAsBO,GAC1CG,EAAgBV,GAAsBQ,GAExC,MAAO,CACL3G,MAAO,CACL8G,OAAQJ,EACRd,KAAMgB,EAAgBhB,KACtBC,OAAQe,EAAgBf,QAE1BkB,IAAK,CACHD,OAAQH,EACRf,KAAMiB,EAAcjB,KACpBC,OAAQgB,EAAchB,QAG3B,CAED,SAASmB,GAASpJ,GACZ8H,GAAcK,KAIdL,GAAcK,KAChBA,GAAiBL,GACjBM,GAAsB,IAGxBA,GAAoBpK,KAAKgC,GAC1B,CAED,SAASqJ,GAAmBtJ,EAAcC,EAAeC,EAAYC,GA2EnE,OALiB,OAAbF,GArEJ,SAAyBA,GACvB,IAAInC,EAAI,EAYR,IAVAmC,EAASsJ,MAAK,SAAUC,EAAQC,GAC9B,OAAID,EAAE3G,YAAc4G,EAAE5G,aACZ,EACC2G,EAAE3G,YAAc4G,EAAE5G,YACpB,EAEA,CAEX,IAEO/E,EAAImC,EAASiC,QACdjC,EAASnC,EAAI,KAAOmC,EAASnC,GAC/BmC,EAASyJ,OAAO5L,EAAG,GAEnBA,GAGL,CAkDC6L,CAAgB1J,GAIX,IAAIF,EAA4B,OAAZC,EAAmBA,EApD9C,SAAsBC,EAAeC,GA4BnC,IACE0J,EACAC,EACA/L,EAHEgM,EAAgB,IAAIC,MAAM9J,EAASiC,QAKvC,IAAKpE,EAAI,EAAGA,EAAImC,EAASiC,OAAQpE,IAC/BgM,EAAchM,GAAKmC,EAASnC,GAAG+E,YAUjC,OAPA+G,EACE3J,EAASiC,OAAS,EACd4H,EAAcE,MAAM,GAAI,GAAGrK,KAAK,MAAQ,OAASmK,EAAc7J,EAASiC,OAAS,GACjF4H,EAAc,GAEpBD,EAAY3J,EAAQ,IAzCpB,SAAsB+J,GACpB,SAASC,EAAIvB,GACX,OAAOA,EAAGwB,WAAW,GAAG7K,SAAS,IAAI8K,aACtC,CAED,OAAOH,EACJrI,QAAQ,MAAO,QACfA,QAAQ,KAAM,OACdA,QAAQ,QAAS,OACjBA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,4BAA4B,SAAU+G,GAC7C,MAAO,OAASuB,EAAIvB,EACtB,IACC/G,QAAQ,yBAAyB,SAAU+G,GAC1C,MAAO,MAAQuB,EAAIvB,EACrB,IACC/G,QAAQ,oBAAoB,SAAU+G,GACrC,MAAO,OAASuB,EAAIvB,EACtB,IACC/G,QAAQ,oBAAoB,SAAU+G,GACrC,MAAO,MAAQuB,EAAIvB,EACrB,GACH,CAgByB0B,CAAanK,GAAS,IAAM,eAE/C,YAAc0J,EAAe,QAAUC,EAAY,SAC3D,CAOuDS,CAAarK,EAAUC,GAAQD,EAAUC,EAAOC,EACzG,CAED,SAASmC,KACP,IAAIiI,EAAIC,EAAIC,EASZ,GAPAF,EAAKxC,GACLyC,EAAKE,KACDF,IAAOrI,IAETqI,EAAKhI,EAAOgI,IAEdD,EAAKC,EACDD,IAAOpI,EAAY,CAIrB,IAHAoI,EAAKxC,GACLyC,EAAK,GACLC,EAAKE,KACEF,IAAOtI,GACZqI,EAAGvM,KAAKwM,GACRA,EAAKE,KAEHH,IAAOrI,GACTsI,EAAKG,KACDH,IAAOtI,GAETqI,EAAK9H,EAAO+H,GACZF,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,EAER,CAED,OAAOoI,CACR,CAED,SAASG,KACP,IAAIH,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAAIC,EAK5B,IAHAT,EAAKxC,GACLyC,EAAK,GACLC,EAAKE,KACEF,IAAOtI,GACZqI,EAAGvM,KAAKwM,GACRA,EAAKE,KAEP,GAAIH,IAAOrI,EAUT,GATsC,KAAlCd,EAAM8I,WAAWpC,KACnB0C,EAAK9H,EACLoF,OAEA0C,EAAKtI,EACmB,IAApBmG,IACFe,GAASzG,IAGT6H,IAAOtI,EAET,GADA0I,EAAKI,KACDJ,IAAO1I,EAUT,GATsC,KAAlCd,EAAM8I,WAAWpC,KACnB+C,EAAKhI,EACLiF,OAEA+C,EAAK3I,EACmB,IAApBmG,IACFe,GAAStG,IAGT+H,IAAO3I,EAAY,CAGrB,IAFA4I,EAAK,GACLC,EAAKL,KACEK,IAAO7I,GACZ4I,EAAG9M,KAAK+M,GACRA,EAAKL,KAEHI,IAAO5I,GAETqI,EAAKhI,EAAOqI,GACZN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,EAER,MACC4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASU,KACP,IAAIV,EAaJ,OAXAA,EAAKW,KACDX,IAAOpI,IACToI,EAAKY,KACDZ,IAAOpI,IACToI,EAAKa,KACDb,IAAOpI,IACToI,EAAKK,QAKJL,CACR,CAED,SAASW,KACP,IAAIX,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAYxB,GAVAR,EAAKxC,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnByC,EAAKxH,EACL+E,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAASpG,IAGTuH,IAAOrI,EAAY,CAGrB,IAFAsI,EAAK,GACLI,EAAKF,KACEE,IAAO1I,GACZsI,EAAGxM,KAAK4M,GACRA,EAAKF,KAEP,GAAIF,IAAOtI,EAET,GADA0I,EAAKQ,KACDR,IAAO1I,EAAY,CAGrB,IAFA2I,EAAK,GACLC,EAAKJ,KACEI,IAAO5I,GACZ2I,EAAG7M,KAAK8M,GACRA,EAAKJ,KAEHG,IAAO3I,GAETqI,EAAKtH,EAAO2H,GACZN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,EAER,MACC4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,CAER,MACC4F,GAAcwC,EACdA,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASY,KACP,IAAIZ,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAYxB,GAVAR,EAAKxC,GACiC,MAAlC1G,EAAM8I,WAAWpC,KACnByC,EAAKpH,EACL2E,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAAShG,IAGTmH,IAAOrI,EAAY,CAGrB,IAFAsI,EAAK,GACLI,EAAKF,KACEE,IAAO1I,GACZsI,EAAGxM,KAAK4M,GACRA,EAAKF,KAEP,GAAIF,IAAOtI,EAET,GADA0I,EAAKQ,KACDR,IAAO1I,EAAY,CAGrB,IAFA2I,EAAK,GACLC,EAAKJ,KACEI,IAAO5I,GACZ2I,EAAG7M,KAAK8M,GACRA,EAAKJ,KAEHG,IAAO3I,GAETqI,EAAKlH,EAAQuH,GACbN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,EAER,MACC4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,CAER,MACC4F,GAAcwC,EACdA,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASa,KACP,IAAIb,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAYxB,GAVAR,EAAKxC,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnByC,EAAKhH,EACLuE,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAAS5F,IAGT+G,IAAOrI,EAAY,CAGrB,IAFAsI,EAAK,GACLI,EAAKF,KACEE,IAAO1I,GACZsI,EAAGxM,KAAK4M,GACRA,EAAKF,KAEP,GAAIF,IAAOtI,EAET,GADA0I,EAAKH,KACDG,IAAO1I,EAAY,CAGrB,IAFA2I,EAAK,GACLC,EAAKJ,KACEI,IAAO5I,GACZ2I,EAAG7M,KAAK8M,GACRA,EAAKJ,KAEHG,IAAO3I,GAETqI,EAAK9G,EAAQmH,GACbN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,EAER,MACC4F,GAAcwC,EACdA,EAAKpI,OAGP4F,GAAcwC,EACdA,EAAKpI,CAER,MACC4F,GAAcwC,EACdA,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASc,KACP,IAAId,EAAIC,EAIR,GAFAD,EAAK,GACLC,EAAKE,KACDF,IAAOrI,EACT,KAAOqI,IAAOrI,GACZoI,EAAGtM,KAAKuM,GACRA,EAAKE,UAGPH,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASK,KACP,IAAIL,EAUJ,OARAA,EAAKe,KACDf,IAAOpI,IACToI,EAAKgB,KACDhB,IAAOpI,IACToI,EAAKiB,OAIFjB,CACR,CAED,SAASgB,KACP,IAAIhB,EAAIC,EAAIC,EAAII,EAyBhB,OAvBAN,EAAKxC,GACLyC,EAAKiB,KACDjB,IAAOrI,GACTsI,EAAKiB,KACDjB,IAAOtI,GACT0I,EAAKc,KACDd,IAAO1I,GAETqI,EAAK5G,EAAQ4G,EAAIC,EAAII,GACrBN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,GAGAoI,CACR,CAED,SAASmB,KACP,IAAInB,EAaJ,OAXAA,EAAKqB,KACDrB,IAAOpI,IACToI,EAAKsB,KACDtB,IAAOpI,IACToI,EAAKuB,KACDvB,IAAOpI,IACToI,EAAKwB,QAKJxB,CACR,CAED,SAASqB,KACP,IAAIrB,EAYJ,OAVsC,KAAlClJ,EAAM8I,WAAWpC,KACnBwC,EAAKxG,EACLgE,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASrF,IAINuG,CACR,CAED,SAASsB,KACP,IAAItB,EAYJ,OAVIlJ,EAAM2K,OAAOjE,GAAa,KAAO9D,GACnCsG,EAAKtG,EACL8D,IAAe,IAEfwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASnF,IAINqG,CACR,CAED,SAASuB,KACP,IAAIvB,EAYJ,OAVIlJ,EAAM2K,OAAOjE,GAAa,KAAO5D,GACnCoG,EAAKpG,EACL4D,IAAe,IAEfwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASjF,IAINmG,CACR,CAED,SAASwB,KACP,IAAIxB,EAYJ,OAVIlJ,EAAM2K,OAAOjE,GAAa,KAAO1D,GACnCkG,EAAKlG,EACL0D,IAAe,IAEfwC,EAAKpI,EACmB,IAApBmG,IACFe,GAAS/E,IAINiG,CACR,CAED,SAASiB,KACP,IAAIjB,EAAIC,EAAIC,EA2BZ,OAzBAF,EAAKxC,GACLyC,EAAKiB,KACDjB,IAAOrI,GACLd,EAAM2K,OAAOjE,GAAa,KAAOxD,GACnCkG,EAAKlG,EACLwD,IAAe,IAEf0C,EAAKtI,EACmB,IAApBmG,IACFe,GAAS7E,IAGTiG,IAAOtI,GAETqI,EAAK/F,EAAQ+F,GACbD,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,GAGAoI,CACR,CAED,SAASe,KACP,IAAIf,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAAIC,EAAIiB,EAyDhC,OAvDA1B,EAAKxC,GACLyC,EAAKiB,KACDjB,IAAOrI,GACTsI,EAAKmB,KACDnB,IAAOtI,GACT0I,EAAK9C,GACL+C,EAAK/C,GACLgD,EAAKY,KACDZ,IAAO5I,IACT4I,EAAK,MAEHA,IAAO5I,GACT6I,EAAKkB,KACDlB,IAAO7I,GACT8J,EAAKN,KACDM,IAAO9J,IACT8J,EAAK,MAEHA,IAAO9J,GACT4I,EAAK,CAACA,EAAIC,EAAIiB,GACdnB,EAAKC,IAELhD,GAAc+C,EACdA,EAAK3I,KAGP4F,GAAc+C,EACdA,EAAK3I,KAGP4F,GAAc+C,EACdA,EAAK3I,GAGL0I,EADEC,IAAO3I,EACJd,EAAM8K,UAAUtB,EAAI9C,IAEpB+C,EAEHD,IAAO1I,GAETqI,EAAK7F,EAAQ6F,EAAIK,GACjBN,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,GAGAoI,CACR,CAED,SAAS2B,KACP,IAAI3B,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAkBxB,GAhBAR,EAAKxC,GACLyC,EAAKzC,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnB0C,EAAK5F,EACLkD,OAEA0C,EAAKtI,EACmB,IAApBmG,IACFe,GAASvE,IAIX0F,EADEC,IAAOtI,EACJd,EAAM8K,UAAU3B,EAAIzC,IAEpB0C,EAEHD,IAAOrI,EAAY,CAyBrB,IAxBAsI,EAAK,GACLI,EAAK9C,GACL+C,EAAKa,KACDb,IAAO3I,GAC6B,KAAlCd,EAAM8I,WAAWpC,KACnBgD,EAAKlG,EACLkD,OAEAgD,EAAK5I,EACmB,IAApBmG,IACFe,GAASvE,IAGTiG,IAAO5I,GACT2I,EAAK,CAACA,EAAIC,GACVF,EAAKC,IAEL/C,GAAc8C,EACdA,EAAK1I,KAGP4F,GAAc8C,EACdA,EAAK1I,GAEA0I,IAAO1I,GACZsI,EAAGxM,KAAK4M,GACRA,EAAK9C,GACL+C,EAAKa,KACDb,IAAO3I,GAC6B,KAAlCd,EAAM8I,WAAWpC,KACnBgD,EAAKlG,EACLkD,OAEAgD,EAAK5I,EACmB,IAApBmG,IACFe,GAASvE,IAGTiG,IAAO5I,GACT2I,EAAK,CAACA,EAAIC,GACVF,EAAKC,IAEL/C,GAAc8C,EACdA,EAAK1I,KAGP4F,GAAc8C,EACdA,EAAK1I,GAGLsI,IAAOtI,GACTqI,EAAK,CAACA,EAAIC,GACVF,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,EAER,MACC4F,GAAcwC,EACdA,EAAKpI,EAGP,OAAOoI,CACR,CAED,SAASoB,KACP,IAAIpB,EAAIC,EAAIC,EAKZ,GAHAF,EAAKxC,GACLyC,EAAK,GACLC,EAAK2B,KACD3B,IAAOtI,EACT,KAAOsI,IAAOtI,GACZqI,EAAGvM,KAAKwM,GACRA,EAAK2B,UAGP5B,EAAKrI,EAQP,OALEoI,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,EAGAD,CACR,CAED,SAASkB,KACP,IAAIlB,EAAIC,EAAIC,EAAII,EAAIC,EAoDpB,OAlDAxC,KACAiC,EAAKxC,GACLyC,EAAK6B,KACD7B,IAAOrI,GACTsI,EAAK1C,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnB8C,EAAK7F,EACL+C,OAEA8C,EAAK1I,EACmB,IAApBmG,IACFe,GAASpE,IAGT4F,IAAO1I,GACT2I,EAAKwB,KACDxB,IAAO3I,GACT0I,EAAK,CAACA,EAAIC,GACVL,EAAKI,IAEL9C,GAAc0C,EACdA,EAAKtI,KAGP4F,GAAc0C,EACdA,EAAKtI,GAEHsI,IAAOtI,IACTsI,EAAK,MAEHA,IAAOtI,GAETqI,EAAKtF,EAAQsF,EAAIC,GACjBF,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,GAEPmG,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAAStE,IAINwF,CACR,CAED,SAAS8B,KACP,IAAI9B,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAUxB,GARAzC,KACAiC,EAAKxC,GACLyC,EAAK+B,KACD/B,IAAOrI,IAETqI,EAAKlF,EAAQkF,IAEfD,EAAKC,EACDD,IAAOpI,EAAY,CAKrB,GAJAoI,EAAKxC,GACLyC,EAAKzC,GACL0C,EAAK1C,GACL8C,EAAK2B,KACD3B,IAAO1I,EAAY,CAGrB,IAFA2I,EAAK,GACLC,EAAK0B,KACE1B,IAAO5I,GACZ2I,EAAG7M,KAAK8M,GACRA,EAAK0B,KAEH3B,IAAO3I,GACT0I,EAAK,CAACA,EAAIC,GACVL,EAAKI,IAEL9C,GAAc0C,EACdA,EAAKtI,EAER,MACC4F,GAAc0C,EACdA,EAAKtI,EAGLqI,EADEC,IAAOtI,EACJd,EAAM8K,UAAU3B,EAAIzC,IAEpB0C,EAEHD,IAAOrI,IAETqI,EAAKhF,EAAQgF,IAEfD,EAAKC,CACN,CASD,OARAlC,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAAShE,IAINkF,CACR,CAED,SAASkC,KACH,IAAAlC,EA0BJ,OAxBAjC,KACAiC,EAAKiC,KACDjC,IAAOpI,IACToI,EAAKmC,KACDnC,IAAOpI,IAC6B,KAAlCd,EAAM8I,WAAWpC,KACnBwC,EAAK7E,EACLqC,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAAS1D,MAKjB2C,KACIiC,IAAOpI,GAEe,IAApBmG,IACFe,GAAS5D,GAIN8E,CACR,CAED,SAASgC,KACP,IAAIhC,EAAIC,EAAIC,EAAII,EAAIC,EAAIC,EAAIC,EAAIiB,EAOhC,GALA3D,KACAiC,EAAKxC,GACLyC,EAAKzC,GACL0C,EAAK,GACLI,EAAK6B,KACD7B,IAAO1I,EACT,KAAO0I,IAAO1I,GACZsI,EAAGxM,KAAK4M,GACRA,EAAK6B,UAGPjC,EAAKtI,EAEP,GAAIsI,IAAOtI,EAAY,CAYrB,GAXA0I,EAAK,GACLC,EAAK/C,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnBgD,EAAKlF,EACLkC,OAEAgD,EAAK5I,EACmB,IAApBmG,IACFe,GAASvD,IAGTiF,IAAO5I,EAAY,CAGrB,GAFA6I,EAAK,GACLiB,EAAKS,KACDT,IAAO9J,EACT,KAAO8J,IAAO9J,GACZ6I,EAAG/M,KAAKgO,GACRA,EAAKS,UAGP1B,EAAK7I,EAEH6I,IAAO7I,GACT4I,EAAK,CAACA,EAAIC,GACVF,EAAKC,IAELhD,GAAc+C,EACdA,EAAK3I,EAER,MACC4F,GAAc+C,EACdA,EAAK3I,EAEP,KAAO2I,IAAO3I,GAYZ,GAXA0I,EAAG5M,KAAK6M,GACRA,EAAK/C,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnBgD,EAAKlF,EACLkC,OAEAgD,EAAK5I,EACmB,IAApBmG,IACFe,GAASvD,IAGTiF,IAAO5I,EAAY,CAGrB,GAFA6I,EAAK,GACLiB,EAAKS,KACDT,IAAO9J,EACT,KAAO8J,IAAO9J,GACZ6I,EAAG/M,KAAKgO,GACRA,EAAKS,UAGP1B,EAAK7I,EAEH6I,IAAO7I,GACT4I,EAAK,CAACA,EAAIC,GACVF,EAAKC,IAELhD,GAAc+C,EACdA,EAAK3I,EAER,MACC4F,GAAc+C,EACdA,EAAK3I,EAGL0I,IAAO1I,GACTsI,EAAK,CAACA,EAAII,GACVL,EAAKC,IAEL1C,GAAcyC,EACdA,EAAKrI,EAER,MACC4F,GAAcyC,EACdA,EAAKrI,EAeP,OAZEoI,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,EAEPlC,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAASzD,IAIN2E,CACR,CAED,SAAS+B,KACP,IAAI/B,EAAIC,EAAIC,EAAII,EAAIC,EAuDpB,OArDAxC,KACAiC,EAAKxC,GACLyC,EAAKzC,GACL0C,EAAKkC,KACDlC,IAAOtI,GAC6B,KAAlCd,EAAM8I,WAAWpC,KACnB8C,EAAK7F,EACL+C,OAEA8C,EAAK1I,EACmB,IAApBmG,IACFe,GAASpE,IAGT4F,IAAO1I,GACT2I,EAAKwB,KACDxB,IAAO3I,GACTsI,EAAK,CAACA,EAAII,EAAIC,GACdN,EAAKC,IAEL1C,GAAcyC,EACdA,EAAKrI,KAGP4F,GAAcyC,EACdA,EAAKrI,KAGP4F,GAAcyC,EACdA,EAAKrI,GAGLoI,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,EAEHD,IAAOpI,IACToI,EAAKxC,GACLyC,EAAKmC,KAEHpC,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,GAGTlC,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAAStD,IAINwE,CACR,CAED,SAASoC,KACP,IAAIpC,EAAIC,EAKR,GAHAlC,KACAiC,EAAK,GACLC,EAAKiC,KACDjC,IAAOrI,EACT,KAAOqI,IAAOrI,GACZoI,EAAGtM,KAAKuM,GACRA,EAAKiC,UAGPlC,EAAKpI,EAUP,OARAmG,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAASrD,IAINuE,CACR,CAED,SAAS6B,KACP,IAAI7B,EAeJ,OAbAA,EAAKqC,KACDrC,IAAOpI,IACL8D,GAAQ4G,KAAKxL,EAAMwH,OAAOd,MAC5BwC,EAAKlJ,EAAMwH,OAAOd,IAClBA,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASnD,MAKRqE,CACR,CAED,SAASqC,KACP,IAAIrC,EAAIC,EAAIC,EA2BZ,OAzBAF,EAAKxC,GACiC,KAAlC1G,EAAM8I,WAAWpC,KACnByC,EAAKrE,GACL4B,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAASjD,KAGToE,IAAOrI,GACTsI,EAAKqC,KACDrC,IAAOtI,GAETqI,EAAKnE,GAAQoE,GACbF,EAAKC,IAELzC,GAAcwC,EACdA,EAAKpI,KAGP4F,GAAcwC,EACdA,EAAKpI,GAGAoI,CACR,CAED,SAASuC,KACP,IAAIvC,EAAIC,EAAIC,EAAII,EAAIC,EA8BpB,OA5BAP,EAAKxC,GACLyC,EAAKzC,GACL0C,EAAK1C,GACL8C,EAAKkC,KACDlC,IAAO1I,GACT2I,EAAKiC,KACDjC,IAAO3I,GACT0I,EAAK,CAACA,EAAIC,GACVL,EAAKI,IAEL9C,GAAc0C,EACdA,EAAKtI,KAGP4F,GAAc0C,EACdA,EAAKtI,GAGLqI,EADEC,IAAOtI,EACJd,EAAM8K,UAAU3B,EAAIzC,IAEpB0C,EAEHD,IAAOrI,IAETqI,EAAK/D,GAAQ+D,IAEfD,EAAKC,EAEED,CACR,CAED,SAASwC,KACP,IAAIxC,EAYJ,OAVI5D,GAAQkG,KAAKxL,EAAMwH,OAAOd,MAC5BwC,EAAKlJ,EAAMwH,OAAOd,IAClBA,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASzC,KAIN2D,CACR,CAED,SAASI,KACH,IAAAJ,EAkBJ,OAhBAjC,KACAiC,EAAKyC,KACDzC,IAAOpI,IACToI,EAAK0C,KACD1C,IAAOpI,IACToI,EAAK2C,OAGT5E,KACIiC,IAAOpI,GAEe,IAApBmG,IACFe,GAASxC,IAIN0D,CACR,CAED,SAASyC,KACH,IAAAzC,EAoBJ,OAlBAjC,KACIvB,GAAQ8F,KAAKxL,EAAMwH,OAAOd,MAC5BwC,EAAKlJ,EAAMwH,OAAOd,IAClBA,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASrC,KAGbsB,KACIiC,IAAOpI,GAEe,IAApBmG,IACFe,GAASvC,IAINyD,CACR,CAED,SAAS0C,KACH,IAAA1C,EAoBJ,OAlBAjC,KACIpB,GAAQ2F,KAAKxL,EAAMwH,OAAOd,MAC5BwC,EAAKlJ,EAAMwH,OAAOd,IAClBA,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASlC,KAGbmB,KACIiC,IAAOpI,GAEe,IAApBmG,IACFe,GAASpC,IAINsD,CACR,CAED,SAASmC,KACP,IAAInC,EAAIC,EA0BR,OAxBAlC,KACAiC,EAAKxC,GACDV,GAAQwF,KAAKxL,EAAMwH,OAAOd,MAC5ByC,EAAKnJ,EAAMwH,OAAOd,IAClBA,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAAS/B,KAIXiD,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,EAEPlC,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAASjC,KAINmD,CACR,CAED,SAASiC,KACP,IAAIjC,EAAIC,EA0BR,OAxBAlC,KACAiC,EAAKxC,GACDP,GAAQqF,KAAKxL,EAAMwH,OAAOd,MAC5ByC,EAAKnJ,EAAMwH,OAAOd,IAClBA,OAEAyC,EAAKrI,EACmB,IAApBmG,IACFe,GAAS5B,KAIX8C,EADEC,IAAOrI,EACJd,EAAM8K,UAAU5B,EAAIxC,IAEpByC,EAEPlC,KACIiC,IAAOpI,IACTqI,EAAKrI,EACmB,IAApBmG,IACFe,GAAS9B,KAINgD,CACR,CAED,SAAS2C,KACH,IAAA3C,EA+BJ,OA7BAjC,KACIjH,EAAM2K,OAAOjE,GAAa,KAAOJ,IACnC4C,EAAK5C,GACLI,IAAe,IAEfwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASzB,KAGT2C,IAAOpI,IAC6B,KAAlCd,EAAM8I,WAAWpC,KACnBwC,EAAK1C,GACLE,OAEAwC,EAAKpI,EACmB,IAApBmG,IACFe,GAASvB,MAIfQ,KACIiC,IAAOpI,GAEe,IAApBmG,IACFe,GAAS3B,IAIN6C,CACR,CAcD,GAFAxI,EAAaQ,IAETR,IAAeI,GAAc4F,KAAgB1G,EAAMa,OACrD,OAAOH,EAMP,MAJIA,IAAeI,GAAc4F,GAAc1G,EAAMa,QACnDmH,GAAS,CAAEnI,KAAM,MAAO2B,YAAa,iBAGjCyG,GACJ,KACAjB,GACAD,GAAiB/G,EAAMa,OAASb,EAAMwH,OAAOT,IAAkB,KAC/DA,GAAiB/G,EAAMa,OACnB4G,GAAoBV,GAAgBA,GAAiB,GACrDU,GAAoBV,GAAgBA,IAG9C,CElhD2B+E,CAAU3L,GACjC,OAAOV,EAAOsM,iBAAiBtL,EAAgBlB,EAChD,CAEOO,wBAAwBsB,EAAgB7B,GAC9C,IAAK,MAAOa,EAAUC,KAAed,EAAWe,UAC1Cc,EAAO1B,SACT0B,EAAO1B,OAAS0B,EAAO1B,OAAOa,QAAQ,IAAIC,OAAOJ,EAAU,KAAMC,IAIrE,IAAK,MAAM2L,KAAK5K,EAAOxB,QACrBH,EAAOsM,iBAAiBC,EAAGzM,GAG7B,OAAO6B,CACR,CAEDtB,eAAe9D,GACb,MAAM4D,EAAoB,GAE1B,IAAK,IAAKqM,EAAG3P,KAAU6B,OAAOmC,QAAQtE,GACpC4D,EAAQhD,KAAK6C,EAAOyM,MAAM5P,EAAM2B,aAGlC,IAAImD,EAUJ,OARuB,IAAnBxB,EAAQiB,OACVO,EAASxB,EAAQ,GACRzB,OAAOC,KAAKpC,GAAO6E,OAAS,EACrCO,EAAS,IAAI3B,EAAO,KAAMD,EAAWsC,IAAKlC,GACd,IAAnBA,EAAQiB,SACjBO,EAAS,IAAI3B,EAAO,KAAMD,EAAWU,UAAW,OAG3CkB,CACR,CAED+K,MAAMC,GACJ,MAAM9P,EAAQD,KAAKC,MACb+P,EAAQD,EAAK/P,KAAKqD,QAExB,OAAQrD,KAAKsD,MACX,IAAK,IACH,OAAOF,EAAO6C,IAAIjG,KAAKuD,SAAS0M,OAAOF,GACzC,IAAK,IACH,OAAO3M,EAAOqC,IAAIzF,KAAKuD,SAAS0M,OAAOF,GACzC,IAAK,IACH,OAAO3M,EAAOyC,GAAG7F,KAAKuD,SAAS0M,OAAOF,GACxC,IAAK,IACH,QAAc,MAAV9P,IAAiB+P,IAGd5M,EAAO8M,YAAYF,EAAO/P,GACnC,IAAK,KACH,OAAOmD,EAAO+M,SAASH,EAAO/P,GAChC,IAAK,KACH,OAAOmD,EAAOgN,SAASJ,EAAO/P,GAChC,QACE,MAAM,IAAIY,MAAM,+BAErB,CAEDwP,WACE,GAAIrQ,KAAKuD,QAAS,CAChB,GAA2B,GAAvBvD,KAAKuD,QAAQiB,OACf,OAAOxE,KAAKuD,QAAQ,GAAG8M,WAEvBrQ,KAAKuD,QAAUvD,KAAKuD,QAAQpD,KAAK4E,GAAWA,EAAOsL,YAEtD,CACD,OAAOrQ,IACR,CAESsQ,QAAQC,EAAcC,EAAgBC,GAC9C,MAAMC,EAAK1H,SAASuH,GACpB,IAAe,IAAXA,EACFA,EAASnN,EAAOmN,WACX,IAAKI,MAAMD,GAGhB,MAAO,GAFPH,EAASG,CAGV,CAED,QAAgB9M,IAAZ6M,GAA2C,iBAAXA,EAClC,MAAM,IAAI5P,MAAM,gCASlB,OANA2P,EAAQA,GAAS,EAEM,iBADvBC,EAAUA,GAAWrN,EAAOwN,eAE1BH,EAAUA,EAAQ7O,YAGb6O,EAAQI,OAAOL,EAAQD,EAC/B,CAED3O,SAAS2O,EAAcC,EAAgBC,GACrC,MAAO,CAACzQ,KAAKsQ,QAAQC,EAAQC,EAAOC,GAAU,IAAKzQ,KAAKqD,OAAQrD,KAAKsD,KAAMtD,KAAKC,MAAO,KAAKgC,KAAK,GAClG,CAEDwB,mBAAqB,CAAC,IAAK,IAAK,IAAK,KAAMoF,OAAOC,aAAa,IAC/DrF,cAAgB,EAChBA,mBAAqB,IACrBA,qBAAsB,EAEtBA,cAAcxD,GACZ,OAAKA,EAEEA,EACJC,MAAM,IACNC,KAAK2Q,GACG1N,EAAO2N,YAAYC,QAAQF,IAAM,EAAI,KAAOA,EAAErE,WAAW,GAAG7K,SAAS,IAAMkP,IAEnF7O,KAAK,IAPW,EAQpB,CAEDwB,gBAAgBsM,GACd,MAAMkB,EAAQlB,EAAK7P,MAAM,IACnBgR,EAAM,GACZ,IAAIC,EAEJ,KAAOF,EAAMzM,QACX2M,EAAMF,EAAMvJ,QAED,MAAPyJ,IACFA,EAAMF,EAAMvJ,QAAUuJ,EAAMvJ,QAC5ByJ,EAAMnI,SAASmI,EAAK,IACpBA,EAAMtI,OAAOC,aAAaqI,IAE5BD,EAAI3Q,KAAK4Q,GAGX,OAAOD,EAAIjP,KAAK,GACjB,CAEDwB,mBAAmBsM,EAAWhL,GAC5B,IAAKgL,EAAM,OAAO,EAClB,MAAMD,EAAQzD,MAAM+E,QAAQrB,GAAQA,EAAO,CAACA,GAC5C,OAAIhL,EAAOiM,QAAQ,KAAO,EACjBlB,EAAMuB,MAAMC,IACjB,GAAIA,EACF,OAAOA,EAAGC,gBAAkBnO,EAAOoO,SAASzM,GAAQwM,aACrD,IAGEnO,EAAOqO,eAAe1B,EAAMhL,EACpC,CAEDtB,sBAAsBsM,EAAWhL,GAC/B,MAAM+K,EAAQzD,MAAM+E,QAAQrB,GAAQA,EAAO,CAACA,GAC5C,IAAI2B,EAAU3M,EAAOb,QAAQ,MAAO,MACpCwN,EAAUA,EAAQxN,QAAQ,yBAAyB,CAACyN,EAAQC,KAC1D,IAAIrF,EAAI1D,OAAOC,aAAaE,SAAS4I,EAAI,KAIzC,MAHI,CAAC,IAAK,IAAK,KAAM,KAAKZ,QAAQzE,IAAM,IACtCA,EAAI,MAAQqF,EAAGlF,eAEVH,CAAC,IAEV,MAAMsF,EAAQ,IAAI1N,OAAO,IAAMuN,EAAU,IAAK,KAC9C,OAAO5B,EAAMuB,MAAMC,GAAOA,EAAGxB,MAAM+B,IACpC,CAEDpO,gBAAgBsM,EAAWhL,GAEzB,OADcsH,MAAM+E,QAAQrB,GAAQA,EAAO,CAACA,IAC/BsB,MAAMC,GAAOA,GAAMvM,GACjC,CAEDtB,gBAAgBsM,EAAWhL,GAEzB,OADcsH,MAAM+E,QAAQrB,GAAQA,EAAO,CAACA,IAC/BsB,MAAMC,GAAOA,GAAMvM,GACjC,CAEDtB,WAAWF,GACT,OAAO,IAAIuO,EAASvO,EACrB,CAEDE,UAAUF,GACR,OAAO,IAAIwO,EAAQxO,EACpB,CAEDE,WAAWsB,GAIT,GAHKsH,MAAM+E,QAAQrM,KACjBA,EAAS,CAACA,IAES,GAAjBA,EAAOP,OACT,MAAM,IAAI3D,MAAM,+BAElB,OAAO,IAAImR,EAASjN,EACrB,EAGH,MAAMkN,UAAc7O,EACFI,KAAY,QAE5BzD,YAAYuD,EAAkBC,EAAoB,IAChD2O,MAAM,KAAM5O,EAAM,KAAMC,EACzB,CAEDuM,MAAMC,GACJ,OAAOmC,MAAMpC,MAAMC,EACpB,CAEDnO,SAAS2O,EAAcC,EAAgBC,GACrCD,EAAQA,GAAS,EACjB,IAAI2B,EAASnS,KAAKsQ,QAAQC,EAAQC,EAAOC,GACrC2B,EAAUD,EACVE,EAAK9B,EAAS,KAAO,GAQzB,MANyC,MAAdvQ,KAAKsD,OAC9B+O,EAAK,GACLD,EAAU,GACV7B,EAAS,GAGJ,CACL4B,EACA,IACAnS,KAAKsD,KACL+O,EACArS,KAAKuD,QAAQpD,KAAKmS,GAASA,EAAK1Q,SAAS2O,EAAQC,EAAQ,EAAGC,KAAUxO,KAAKoQ,GAC3EA,EACAD,EACA,KACAnQ,KAAK,GACR,EAGH,MAAM8P,UAAgBE,EACpBlS,YAAYwD,EAAoB,IAC9B2O,MAAM/O,EAAW0C,GAAItC,EACtB,CAED0M,OAAOF,GACL,OAAO/P,KAAKuD,QAAQ8N,MAAMC,GAAOA,EAAGxB,MAAMC,IAC3C,EAGH,MAAM+B,UAAiBG,EACrBlS,YAAYwD,EAAoB,IAC9B2O,MAAM/O,EAAWsC,IAAKlC,EACvB,CAED0M,OAAOF,GACL,OAAO/P,KAAKuD,QAAQgP,OAAOjB,GAAOA,EAAGxB,MAAMC,IAC5C,EAGH,MAAMiC,UAAiBC,EACrBlS,YAAYwD,EAAoB,IAC9B2O,MAAM/O,EAAW8C,IAAK1C,EACvB,CAED0M,OAAOF,GACL,OAAO/P,KAAKuD,QAAQgP,OAAOjB,IACzB,GAAIA,GAA0B,mBAAbA,EAAGxB,MAClB,OAAUwB,EAAGxB,MAAMC,EACpB,GAEJ,CAEDM,WACE,OAAOrQ,IACR,EAGH,MAAM0D,EAGgB/C,KAFZoQ,YAAwB,CAAC,IAAK,IAAK,IAAK,KAAMlI,OAAOC,aAAa,IAE1E/I,YAAoBY,GAAAX,KAAIW,KAAJA,CAAgB,CAEpCqG,UACE,OAAO,IAAI5D,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAI,IAC7C,CAEDsL,IAAIvS,GACF,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAIjH,EAC7C,CAEDwS,QAAQxS,GACN,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAIlH,KAAK0S,OAAOzS,GACzD,CAED0S,SAAS1S,GACP,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAI,IAAMlH,KAAK0S,OAAOzS,GAC/D,CAED2S,WAAW3S,GACT,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAIlH,KAAK0S,OAAOzS,GAAS,IAClE,CAED4S,SAAS5S,GACP,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW+D,GAAI,IAAMlH,KAAK0S,OAAOzS,GAAS,IACxE,CAED6S,OAAO7S,GACL,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW4P,OAAQ/S,KAAK0S,OAAOzS,GAC7D,CAED+S,IAAI/S,GACF,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAW8P,IAAKjT,KAAK0S,OAAOzS,GAC1D,CAEDiT,IAAIjT,GACF,OAAO,IAAImD,EAAOpD,KAAKW,KAAMwC,EAAWgQ,IAAKnT,KAAK0S,OAAOzS,GAC1D,CAEDyS,OAAOzS,GACgB,iBAAVA,IACTA,EAAQA,EAAM2B,YAEhB,MAAMwR,EAAK,GACX,IAAK,IAAIhT,EAAI,EAAGiT,EAAIpT,EAAMuE,OAAQpE,EAAIiT,EAAGjT,IACvCgT,EAAG7S,KAAKP,KAAK+Q,YAAYC,QAAQ/Q,EAAMG,KAAO,EAAI,KAAOH,EAAMwM,WAAWrM,GAAGwB,SAAS,IAAM3B,EAAMG,IAEpG,OAAOgT,EAAGnR,KAAK,GAChB,EC/VH,MACMqR,EAAmBC,OAAOD,kBAAoB,iBAqB9CE,EAAqB,IAAIrP,OAJC,uMAK1BsP,EAAgB,iBAETC,EACHC,WACAC,MACAC,MACAC,MACAC,gBACAC,WACAC,MACRC,YACQC,QAERpU,YAAYoU,GACV,GAAIA,aAAmBT,EACrB,OAAOS,EACF,GAAuB,iBAAZA,EAChB,MAAM,IAAIC,UAAU,oBAAsBD,GAG5C,GAAIA,EAAQ3P,OA3CG,IA4Cb,MAAM,IAAI4P,UAAU,yCAGtB,KAAMpU,gBAAgB0T,GACpB,OAAO,IAAIA,EAAcS,GAG3B,MAAME,EAAUF,EAAQ9T,OAAOyP,MAAM0D,GAErCxT,KAAK2T,WAAaQ,EAClBnU,KAAK4T,OAASS,EAAQ,GACtBrU,KAAK6T,OAASQ,EAAQ,GACtBrU,KAAK8T,OAASO,EAAQ,GAEtBrU,KAAKsU,4BAA4BtU,KAAK4T,MAAO,SAC7C5T,KAAKsU,4BAA4BtU,KAAK6T,MAAO,SAC7C7T,KAAKsU,4BAA4BtU,KAAK8T,MAAO,SAEzCO,EAAQ,GACVrU,KAAK+T,gBAAkBM,EAAQ,GAAGnU,MAAM,KAAKC,KAAI,SAAUoU,GACzD,GAAId,EAActE,KAAKoF,GAAK,CAC1B,IAAIC,GAAOD,EACX,GAAIC,GAAO,GAAKA,EAAMlB,EACpB,OAAOkB,CAEV,CACD,OAAOD,CACT,IAEAvU,KAAK+T,gBAAkB,GAKzB/T,KAAKgU,WAAaK,EAAQ,GAC1BrU,KAAKiU,MAAQI,EAAQ,GACrBrU,KAAKkU,YAAc,CAAClU,KAAK4T,MAAO5T,KAAK6T,MAAO7T,KAAK8T,OAAO7R,KAAK,KAC7DjC,KAAKmU,QACHnU,KAAKkU,aAAelU,KAAKgU,WAAa,IAAIhU,KAAKgU,aAAe,KAAOhU,KAAKiU,MAAQ,IAAIjU,KAAKiU,QAAU,GACxG,CAEOK,4BAA4BG,EAAoBC,GACtD,GAAID,EAAgBnB,GAAoBtT,KAAK4T,MAAQ,EACnD,MAAM,IAAIQ,UAAU,WAAWM,YAElC,CAEOC,WAAWC,GACjB,OAAOnB,EAActE,KAAKyF,EAC3B,CAEOC,WAAWL,EAAUM,GAC3B,MAAMtQ,GAAU,GAAKgQ,GAAKhQ,OAC1B,OAAO6H,MAAMyI,EAAOtQ,GAASsQ,EAAOtQ,EAAS,GAAS,GAAGvC,KAAK,GAAYuS,CAC3E,CAED/Q,gBAAgB0Q,GACd,OAAOX,EAAmBrE,KAAKgF,EAChC,CAEDY,qBAAqBC,GACnB,MAAMC,EAAa,CACjBjV,KAAK6U,WAAW7U,KAAK4T,MAAOoB,GAC5BhV,KAAK6U,WAAW7U,KAAK6T,MAAOmB,GAC5BhV,KAAK6U,WAAW7U,KAAK8T,MAAOkB,IAC5B/S,KAAK,IACP,OAAO+G,SAASiM,EACjB,CAED/T,QAAQF,EAAYkU,GAA0B,GAC5C,IAAIC,EAAcnU,EACZA,aAAiB0S,IACrByB,EAAc,IAAIzB,EAAc1S,IAElC,MAAMoU,EAASpV,KAAKqV,mBAAmBF,IAAgBnV,KAAKsV,yBAAyBH,GACrF,OAAKC,GAAUF,EACNlV,KAAKuV,oBAAoBJ,GAEzBC,CAEV,CAGDI,eAAe1J,EAAQC,GACrB,OAAOD,EAAIC,EAAI,EAAID,EAAIC,GAAK,EAAI,CACjC,CAED0J,mBAAmB3J,EAAQC,GACzB,MAAM2J,EAAa1V,KAAK2U,WAAW7I,GAC7B6J,EAAa3V,KAAK2U,WAAW5I,GAMnC,OALI2J,GAAcC,IAChB7J,GAAKA,EACLC,GAAKA,GAGH2J,IAAeC,GACT,EACCA,IAAeD,EACjB,EAEA1V,KAAKwV,eAAe1J,EAAGC,EAEjC,CAEDsJ,mBAAmBF,GACjB,OACEnV,KAAKwV,eAAexV,KAAK4T,MAAOuB,EAAYvB,QAC5C5T,KAAKwV,eAAexV,KAAK6T,MAAOsB,EAAYtB,QAC5C7T,KAAKwV,eAAexV,KAAK8T,MAAOqB,EAAYrB,MAE/C,CAEDwB,yBAAyBH,GACvB,GAAInV,KAAK+T,gBAAgBvP,SAAW2Q,EAAYpB,gBAAgBvP,OAC9D,OAAQ,EACH,IAAKxE,KAAK+T,gBAAgBvP,QAAU2Q,EAAYpB,gBAAgBvP,OACrE,OAAO,EACF,IAAKxE,KAAK+T,gBAAgBvP,SAAW2Q,EAAYpB,gBAAgBvP,OACtE,OAAO,EAET,IAAIpE,EAAI,EACR,EAAG,CACD,MAAM0L,EAAI9L,KAAK+T,gBAAgB3T,GACzB2L,EAAIoJ,EAAYpB,gBAAgB3T,GACtC,QAAUwD,IAANkI,QAAyBlI,IAANmI,EACrB,OAAO,EACF,QAAUnI,IAANmI,EACT,OAAO,EACF,QAAUnI,IAANkI,EACT,OAAQ,EACH,GAAIA,IAAMC,EAGf,OAAO/L,KAAKyV,mBAAmB3J,EAAGC,EAErC,SAAU3L,EACZ,CAEDmV,oBAAoBJ,GAClB,OAAInV,KAAKiU,QAAUkB,EAAYlB,MACtB,GACGjU,KAAKiU,OAASkB,EAAYlB,OAC5B,EAEDjU,KAAKyV,mBAAmBzV,KAAKiU,MAAOkB,EAAYlB,MAE1D,ECtLI,MAAM/S,EAAU,CAAC4K,EAAQC,EAAQmJ,IAC/B,IAAIxB,EAAc5H,GAAG5K,QAAQ,IAAIwS,EAAc3H,GAAImJ,GAgB/ChC,EAAM,CAACpH,EAAQC,EAAQmJ,KAClC,MAAME,EAASlU,EAAQ4K,EAAGC,EAAGmJ,GAC7B,OAAkB,IAAXE,GAA2B,IAAXA,CAAY,EAQxBpC,EAAM,CAAClH,EAAQC,EAAQmJ,KAClC,MAAME,EAASlU,EAAQ4K,EAAGC,EAAGmJ,GAC7B,OAAmB,IAAZE,GAA4B,IAAXA,CAAY,EAGzBQ,EAAQ,CAAC9J,EAAQC,EAAQmJ,IAElB,IADHhU,EAAQ4K,EAAGC,EAAGmJ,SCtClBW,EACkB1B,QAA7BpU,YAA6BoU,GAAAnU,KAAOmU,QAAPA,CAAmB,CAEhDvS,WACE,OAAO5B,KAAKmU,QAAQvS,UACrB,CAEDV,QAAQF,GACN,OAAOE,EAAQlB,KAAKmU,QAASnT,EAAMY,WACpC,CAEDgU,MAAM5U,GACJ,OAAO4U,EAAM5V,KAAKmU,QAASnT,EAC5B,CAEDgS,IAAIhS,GACF,OAAOgS,EAAIhT,KAAKmU,QAASnT,EAC1B,CAEDkS,IAAIlS,GACF,OAAOkS,EAAIlT,KAAKmU,QAASnT,EAC1B,CAED8U,IAAI9U,GACF,OAAQhB,KAAK4V,MAAM5U,EACpB,QClBU+U,EACMC,QAA2C,CAAA,EAC3CC,OAA0B,IAAInW,IAE/CC,YAAYmW,EAA4B,IACtC,IAAK,MAAMC,KAAaD,EACtBlW,KAAKgW,QAAQG,GAAa,EAE7B,CAEDrG,MAAMsG,EAAYC,GAChB,MAAMhC,EAA2BrU,KAAKsW,YAAYtW,KAAKiW,OAAQG,GAC/D,OAAOC,EAAgBN,EAAcQ,qBAAqBlC,EAAS+B,GAAM/B,CAC1E,CAEDmC,cAAcC,GACZzW,KAAKiW,OAAOnV,IAAI2V,GAEhB,IAAK,MAAOzU,EAAK/B,KAAU6B,OAAOmC,QAAQjE,KAAKgW,SAAU,CACvD,IAAI/V,EAAQwW,EAAIrV,gBAAgBY,GAChC,GAAI1C,EAAaW,GAAQ,CACvB,MAAMyW,EAAyBzW,EAE/B,GAAIoM,MAAM+E,QAAQnR,GAAQ,CACxB,MAAM6Q,EAAW7Q,EACjB,IAAK,MAAM0W,KAAK7F,EACdiF,EAAca,gBAAgBF,EAAOD,EAAKE,EAE7C,MACCZ,EAAca,gBAAgBF,EAAOD,EAAKxW,EAE7C,CACF,CACF,CAED4W,iBAAiBJ,GACf,MAAMK,EAAS9W,KAAKiW,OAAOvU,IAAI+U,GAE/B,GADAzW,KAAKiW,OAAOc,OAAON,GACfK,EACF,IAAK,MAAO9U,EAAKgV,KAAWlV,OAAOmC,QAAQjE,KAAKgW,SAAU,CACxD,IAAI/V,EAAQwW,EAAIrV,gBAAgBY,GAChC,GAAI1C,EAAaW,GAAQ,CACvB,MAAMyW,EAA4CM,EAElD,GAAI3K,MAAM+E,QAAQnR,GAAQ,CACxB,MAAM6Q,EAAW7Q,EACjB,IAAK,MAAM0W,KAAK7F,EACdiF,EAAckB,kBAAkBP,EAAOD,EAAKE,EAE/C,MACCZ,EAAckB,kBAAkBP,EAAOD,EAAKxW,EAE/C,CACF,CAEJ,CAEDwD,eAAegT,EAAiBL,GAC9B,OAAOL,EAAcmB,gBAAgBT,EAAKL,IAAOL,EAAcoB,eAAeV,EAAKL,EACpF,CAED3S,sBAAsBgT,EAAiBL,GACrC,GAAIjX,EAAaiX,GACf,OAAO,EAET,MAAMzW,EAAQ8W,EAAIrV,gBAClB,IAAK,MAAMY,KAAOF,OAAOC,KAAKpC,GAC5B,GAAK8W,EAA6BjV,qBAAqBQ,KAAS+T,EAAcqB,wBAAwBpV,EAAKoU,GACzG,OAAO,EAGX,OAAO,CACR,CAED3S,+BAA+B4T,EAAkBjB,GAC/C,IAAKA,EACH,OAAO,EAGT,GAAkB,OAAdA,EAAG/S,aAAiCO,IAAdwS,EAAG/S,QAAwB+S,EAAG/S,SAAWgU,EACjE,OAAO,EACF,GAAIjB,EAAG9S,OAASH,EAAWsC,IAAK,CACrC,IAAI6R,EAAclB,EAAG7S,QACrB,IAAK,IAAInD,EAAI,EAAGA,EAAIkX,EAAK9S,OAAQpE,IAAK,CACpC,IAAImX,EAAMD,EAAKlX,GACf,GAAmB,OAAfmX,EAAIlU,aAAiCO,IAAdwS,EAAG/S,QAAwBkU,EAAIlU,SAAWgU,EACnE,OAAO,CAEV,CACF,CAED,OAAO,CACR,CAED5T,eAAe+T,EAAUC,EAAiBC,GACxC,GAAIvY,EAAaqY,GACf,OAAO,EAGT,GAAIE,IAAQvU,EAAWwU,QACrB,OAAO,EAGT,MAAMC,EAA4B,iBAAfH,EAA0BA,EAAWpX,OAASoX,EAEjE,GAAmB,kBAARD,EACT,OAAQE,GACN,KAAKvU,EAAW+D,GAChB,KAAK/D,EAAWgQ,IAChB,KAAKhQ,EAAW8P,IACd,OAAOuE,KAAiB,SAARI,GAClB,QACE,MAAM,IAAI/W,MAAM,oCAAsC6W,GAI5D,GAAmB,iBAARF,EACT,OAAQE,GACN,KAAKvU,EAAW+D,GACd,OAAOsQ,IAAQjE,OAAOqE,GACxB,KAAKzU,EAAWgQ,IACd,OAAOqE,GAAOjE,OAAOqE,GACvB,KAAKzU,EAAW8P,IACd,OAAOuE,GAAOjE,OAAOqE,GACvB,QACE,MAAM,IAAI/W,MAAM,oCAAsC6W,GAI5D,GAAIF,aAAe3B,EACjB,OAAQ6B,GACN,KAAKvU,EAAW+D,GACd,OAAO0O,EAAM4B,EAAI5V,WAAYgW,EAAIhW,YACnC,KAAKuB,EAAW8C,IACd,OAAQ2P,EAAM4B,EAAI5V,WAAYgW,EAAIhW,YACpC,KAAKuB,EAAWgQ,IACd,OAAOD,EAAIsE,EAAI5V,WAAYgW,EAAIhW,YACjC,KAAKuB,EAAW8P,IACd,OAAOD,EAAIwE,EAAI5V,WAAYgW,EAAIhW,YACjC,QACE,MAAM,IAAIf,MAAM,oCAAsC6W,GAI5D,GAAmB,iBAARF,EACT,OAAQE,GACN,KAAKvU,EAAW+D,GACd,OAAOsQ,IAAQI,EACjB,KAAKzU,EAAW8C,IACd,OAAOuR,IAAQI,EACjB,QACE,MAAM,IAAI/W,MAAM,oCAAsC6W,GAI5D,GAAIrL,MAAM+E,QAAQoG,GAAM,CACtB,IAAK,IAAI1L,KAAK0L,EACZ,GAAIzB,EAAc7U,QAAQ4K,EAAG2L,EAAYC,GACvC,OAAO,EAIX,OAAO,CACR,CAED,OAAO,CACR,CAEOjU,uBAAuBiT,EAAwBD,EAAuBoB,GAC5E,IAAIC,EAA8B,IAAIhY,IACtC,MAAMiY,EAAiCrB,EAAMmB,GACxCE,IACHrB,EAAMmB,GAAYC,GAEhBxY,EAAayY,KACfD,EAAOC,GAETD,EAAKhX,IAAI2V,EACV,CAEOhT,yBAAyBiT,EAAwBD,EAAuBxW,GAC9E,IAAI6X,EAA8BpB,EAAMzW,GAEpCX,EAAawY,KACfA,EAAKf,OAAON,GACM,IAAdqB,EAAKrW,aACAiV,EAAMzW,GAGlB,CAEOwD,4BAA4BqU,EAAuB1B,GACzD,IAAK,MAAMK,KAAOqB,EACX/B,EAAcoB,eAAeV,EAAKL,IACrC0B,EAAKf,OAAON,GAGhB,OAAOqB,CACR,CAEOxB,YAAYwB,EAAuB1B,GACzC,IAAI/B,EAA2B,IAAIvU,IAEnC,GAAIsW,EAAG9S,OAASH,EAAWU,UACzBiU,EAAKE,SAASlH,GAAMuD,EAAQvT,IAAIgQ,UAC3B,GAAIsF,EAAG9S,OAASH,EAAWsC,IAAK,CACrC,MAAMwS,EAAqB7B,EAAG7S,QAC9B,IAAK,IAAInD,EAAI,EAAG0X,EAAKrW,KAAO,GAAKrB,EAAI6X,EAAIzT,OAAQpE,IAC/CiU,EAAUrU,KAAKsW,YAAYwB,EAAMG,EAAI7X,IACrC0X,EAAOzD,CAEV,MAAM,GAAI+B,EAAG9S,OAASH,EAAW0C,GAAI,CACpC,MAAMoS,EAAqB7B,EAAG7S,QAC9B,IAAK,IAAInD,EAAI,EAAGA,EAAI6X,EAAIzT,OAAQpE,IAC9BJ,KAAKsW,YAAYwB,EAAMG,EAAI7X,IAAI4X,SAASlH,GAAMuD,EAAQvT,IAAIgQ,IAE7D,MAAM,GAAIsF,EAAG9S,OAASH,EAAW8C,IAAK,CACrC6R,EAAKE,SAASlH,GAAMuD,EAAQvT,IAAIgQ,KAChC,MAAMmH,EAAqB7B,EAAG7S,QAC9B,IAAK,IAAInD,EAAI,EAAGA,EAAI6X,EAAIzT,OAAQpE,IAAK,CACxBJ,KAAKsW,YAAYwB,EAAMG,EAAI7X,IACnC4X,SAASlH,GAAMuD,EAAQ0C,OAAOjG,IAClC,CACF,KAAM,CACL,MAAM4F,EAA4C1W,KAAKgW,QAAQI,EAAG/S,QAClE,GAAI+S,EAAG9S,OAASH,EAAW+D,IAAM5H,EAAaoX,GAAQ,CACpD,MAAMwB,EAAsCxB,EAAMN,EAAG/S,QACjD/D,EAAa4Y,KACfA,EAAaF,SAASlH,GAAMuD,EAAQvT,IAAIgQ,KACpCgH,IAAS9X,KAAKiW,QAChB6B,EAAKE,SAASlH,IACPuD,EAAQ3S,IAAIoP,IACfuD,EAAQ0C,OAAOjG,EAChB,IAIR,MACC,IAAK,MAAM2F,KAAOqB,EAAM,CACtB,MAAMN,EAAWf,EAAIrV,gBAAgBgV,EAAG/S,QACpC/D,EAAakY,IACXzB,EAAc7U,QAAQsW,EAAKpB,EAAGnW,MAAOmW,EAAG9S,OAC1C+Q,EAAQvT,IAAI2V,EAGjB,CAEJ,CAED,OAAOpC,CACR,CAEO5Q,uBAAuBgT,EAAiBL,GAC9C,IAAI+B,GAAU,EAEd,GAAIhZ,EAAaiX,GACf+B,GAAU,OACL,GAAI/B,EAAG9S,OAASH,EAAWU,UAChCsU,GAAU,OACL,GAAI/B,EAAG9S,OAASH,EAAWsC,IAAK,CACrC,MAAMwS,EAAM7B,EAAG7S,QACf,IAAK,IAAInD,EAAI,EAAG+X,GAAW/X,EAAI6X,EAAIzT,OAAQpE,IACzC+X,EAAUpC,EAAcmB,gBAAgBT,EAAKwB,EAAI7X,GAEpD,MAAM,GAAIgW,EAAG9S,OAASH,EAAW0C,GAAI,CACpCsS,GAAU,EACV,MAAMF,EAAM7B,EAAG7S,QACf,IAAK,IAAInD,EAAI,GAAI+X,GAAW/X,EAAI6X,EAAIzT,OAAQpE,IAC1C+X,EAAUpC,EAAcmB,gBAAgBT,EAAKwB,EAAI7X,GAEpD,MAAM,GAAIgW,EAAG9S,OAASH,EAAW8C,IAAK,CACrC,MAAMgS,EAAM7B,EAAG7S,QACf,IAAK,IAAInD,EAAI,EAAGA,EAAI6X,EAAIzT,OAAQpE,IAC9B+X,GAAWpC,EAAcmB,gBAAgBT,EAAKwB,EAAI7X,GAErD,KAAM,CACL+X,GAAU,EACV,MAAMX,EAAMf,EAAIrV,gBAAgBgV,EAAG/S,QAC/BmU,UACFW,EAAUpC,EAAc7U,QAAQsW,EAAKpB,EAAGnW,MAAOmW,EAAG9S,MAErD,CAED,OAAO6U,CACR,QC/RUC,EACM5Y,SACAC,UACAsF,OACAsT,SACA3Y,KAA+B,CAAA,EAC/BC,MAA6B,CAAA,EAE9CI,YACEP,EACAC,EACAC,EAA+B,CAAA,EAC/BC,EAA6B,CAAE,EAC/BoF,GAEA/E,KAAKR,SAAWA,EAChBQ,KAAKP,UAAYA,EACjBO,KAAKN,KAAOA,EACZM,KAAKL,MAAQA,EACbK,KAAK+E,OAASA,GAAU3B,EAAOkV,QAAQtY,KAAKL,OAC5CK,KAAKqY,SACHrY,KAAKN,KAAKkB,eX+Oa,eA5KD,aWnE4BZ,KAAKN,KAAyB,UACnF,CAED0B,gBACE,OAAOpB,KAAKL,KACb,CAED0B,gBACE,OAAOrB,KAAKN,IACb,CAEDyB,eACE,OAAOnB,KAAKP,SACb,CAED6B,cACE,OAAOtB,KAAKR,QACb,CAED+B,cACE,OAAOvB,KAAKR,QACb,CAED6U,QAAQkE,GACN,OAAOxC,EAAc1B,QAAQkE,EAAYvY,KAAKwY,YAC/C,CAEDC,aACE,OAAOzY,KAAKqY,QACb,CAEDG,YACE,OAAOxY,KAAK+E,MACb,CAEDnD,WACE,MAAO,IAAM5B,KAAKR,SAAW,KAAOQ,KAAKP,UAAY,KAAOO,KAAKwY,aAAa5W,UAC/E,QCvBUnB,EACMiY,UACAC,UACAC,aAAoC,GACpCC,aAAmC,GACnCC,mBACAC,cACTC,qBACAC,qBACAC,iBAAqC,mBAE7CzV,qBAAgC,IAAIoS,EAAW,SAE/C9V,YAAY2Y,EAA4BS,EAAuBR,GAC7D3Y,KAAK0Y,UAAYA,EACjB1Y,KAAK2Y,UAAYA,EAEjB,MAAMS,EAAuC,GAI7C,GADApZ,KAAK+Y,cAAgBtY,EAAmB4Y,cACN,OAA9BV,EZ1Be,wBY0BqD/U,IAA9B+U,EZ1BvB,kBY2BjB,IACE3Y,KAAK+Y,cAAgB,IAAIlD,EAAW8C,EZ5BrB,kBYkChB,CALC,MAAOW,GACP,GAAkC,MAA9BtZ,KAAKuZ,qBACP,MAAMD,EAERtZ,KAAK+Y,cAAgBtY,EAAmB4Y,aACzC,CAIH,MAAMG,EAAkC/Y,EAAmBgZ,wBAAwBN,EAAOnZ,KAAK2Y,WAY/F,GAXIa,IACFxZ,KAAK8Y,mBAAqBU,EAAUpY,gBAAgBnC,GAE/C0Z,EZkCW,kBYjCdS,EAAQ7Y,KAAKiZ,GAGfJ,EAAQ7Y,KAAKE,EAAmBiZ,sBAAsBP,EAAOR,EAAWa,KAIxC,MAA9BxZ,KAAKuZ,uBAAiCvZ,KAAK8Y,mBAC7C,MAAM,IAAIjY,MAAM,0DAIlB,IAAI8Y,EAAuClZ,EAAmBmZ,oBAAoBjB,EZnB/D,mBYoBnBgB,EAAYlZ,EAAmBoZ,wBAAwBF,EAAW3Z,KAAKuZ,sBACvE,MAAMO,EAAuCrZ,EAAmBsZ,gBAAgBJ,EAAWR,GAGrFa,EAAwC,GAC9C,GAAI3N,MAAM+E,QAAQuH,EZjBK,uBYkBrB,IAAK,MAAMsB,KAAQtB,EZlBE,sBYmBnBqB,EAAYzZ,QAAQE,EAAmByZ,mBAAmBD,EAAK5Z,OAAQ8Y,QAEvB,iBAAlCR,EZrBK,uBYsBrBqB,EAAYzZ,QACPE,EAAmByZ,mBAAoBvB,EZvBvB,sBYuBgEtY,OAAQ8Y,IAK/F,MAAMgB,EAAuC,GAC7C,GAAI9N,MAAM+E,QAAQuH,EZjCK,uBYkCrB,IAAK,MAAMsB,KAAQtB,EZlCE,sBYmCnBwB,EAAY5Z,QAAQE,EAAmB2Z,mBAAmBH,EAAK5Z,OAAQ8Y,QAEvB,iBAAlCR,EZrCK,uBYsCrBwB,EAAY5Z,QACPE,EAAmB2Z,mBAAoBzB,EZvCvB,sBYuCgEtY,OAAQ8Y,IAK/FnZ,KAAK4Y,aAAe,GACpB5Y,KAAK4Y,aAAarY,QAAQuZ,GAC1B9Z,KAAK4Y,aAAarY,QAAQyZ,GAG1Bha,KAAK6Y,aAAe,GACpB7Y,KAAK6Y,aAAatY,QAAQ6Y,GAC1BpZ,KAAK6Y,aAAatY,QAAQ4Z,GAG1Bna,KAAKqa,sBAAsB1B,EAC5B,CAEOlV,0BAA0BwW,EAAcd,GAC9C,IAAImB,EAA4C7Z,EAAmBmZ,oBAAoBK,GAEvF,OADAK,EAAiB7Z,EAAmB8Z,2BAA2BD,GACxD7Z,EAAmB+Z,2BAA2BF,EAAgBnB,EACtE,CAEO1V,0BAA0BwW,EAAcd,GAC9C,IAAImB,EAA4C7Z,EAAmBmZ,oBAAoBK,GAEvF,OADAK,EAAiB7Z,EAAmB8Z,2BAA2BD,GACxD7Z,EAAmBga,2BAA2BH,EAAgBnB,EACtE,CAEDuB,gCACE,OAAO1a,KAAKgZ,oBACb,CACD2B,gCACE,OAAO3a,KAAKiZ,oBACb,CAED2B,sBACE,OAAO5a,KAAKkZ,gBACb,CAED2B,kBACE,OAAO7a,KAAK8Y,kBACb,CAEDgC,mBACE,OAAO9a,KAAK+Y,aACb,CAEDgC,QAAQC,GACN,MAAMC,EAAMD,EAAKE,YAAY,KAC7B,OAAOD,GAAO,EAAID,EAAKvM,UAAUwM,GAAOD,CACzC,CAEDG,kBACE,OAAOnb,KAAK6Y,YACb,CAEDuC,kBACE,OAAOpb,KAAK4Y,YACb,CAEDnV,4BAA4BxD,EAAeob,EAAehb,GAAO,GAC3DlB,EAAac,KACfA,EAAQ,IAGV,MAAMqX,EAAiB,GAOvB,IAAIgE,EAAK,GAELC,EAAYC,EAEZC,GAAY,EAChB,IAAK,IAAIrb,EAAI,EAAGA,EAAIH,EAAMuE,OAAQpE,IAAK,CACrC,MAAM0Q,EAAI7Q,EAAMkL,OAAO/K,GAEjBsb,EAAcL,EAAMrK,QAAQF,IAAM,EAExC,GAAK2K,GAAkB,MAAL3K,EAAlB,CAKA,GAAI2K,EACFH,GAAMxK,OACD,GAAI4K,IArBK,EAqBWH,GAAyB,EAC9Clb,EACFiX,EAAK/W,KAAK+a,EAAG1Z,WAAWvB,QAExBiX,EAAK/W,KAAK+a,EAAG1Z,YAEf0Z,EAAK,GACLC,EAAYC,OACP,GAAS,KAAL1K,IA5BM,EA4BOyK,GAA0B,EAChDD,GAAMxK,EACNyK,EAAYC,OACP,GAAS,KAAL1K,IA9BI,EA8BSyK,GAAwB,EAC9CD,GAAMxK,EACNyK,EAAYC,MACP,OApCI,EAoCCD,GAAoB,GAG9B,MAAM,IAAI1a,MAAM,6BAA+BZ,GAF/Cqb,GAAMxK,CAGP,CAED2K,GAAY,CAxBX,MAFCA,GAAY,CA2Bf,CAUD,OARIH,EAAG9W,OAAS,IACVnE,EACFiX,EAAK/W,KAAK+a,EAAG1Z,WAAWvB,QAExBiX,EAAK/W,KAAK+a,EAAG1Z,aAIV0V,CACR,CAEDiC,qBACE,MAAMoC,EAAkBlb,EAAmB8Y,mBAAmBvZ,KAAK2Y,WACnE,OAAOxZ,EAAawc,GAAmB,IAAMA,CAC9C,CAEOlY,0BAA0BkV,GAChC,MAAMgD,EAAkBhD,EZxLG,0BYyL3B,OAAOxZ,EAAawc,GAAmB,KAAOA,EAAgBtb,MAC/D,CAEOoD,+BACN0V,EACAR,GAEA,MAAMiD,EAAqC5b,KAAKua,2BAC9Cva,KAAK4Z,oBAAoBjB,EZxMH,yBY0MxB,GAAIiD,EAAQpX,OAAS,EAAG,CACtB,GAAIoX,EAAQpX,OAAS,EACnB,MAAM,IAAI3D,MAAM,wCAA0C8X,EZ5MtC,wBY6Mf,GAAIiD,EAAQ,GAAGzZ,MAAMqC,OAAS,EACnC,MAAM,IAAI3D,MAAM,wCAA0C8X,EZ9MtC,wBY+Mf,GAAIiD,EAAQ,GAAGjc,MAAMiB,eZlOX,kBYmOf,MAAM,IAAIC,MAAM,iCAAmC8X,EZnOpC,mBYuOjB,IAAII,EAAgB/Y,KAAKqZ,cACzB,GAAkC,OAA9BV,EZxOa,wBYwOuD/U,IAA9B+U,EZxOzB,kBYyOf,IACEI,EAAgB,IAAIlD,EAAW8C,EZ1OlB,kBYiPd,CANC,MAAOW,GACP,IAAIuC,EAAa7b,KAAKuZ,mBAAmBZ,GACzC,GAAIkD,QACF,MAAMvC,EAERP,EAAgB/Y,KAAKqZ,aACtB,CAIH,MAAMyC,EAAkBF,EAAQ,GAAGzZ,MAAM,GAGzC,OAFAyZ,EAAQ,GAAGjc,MAAMV,GAAoB6c,EACrCF,EAAQ,GAAGjc,MZjFgB,kBYiFkBoZ,EACtC,IAAIxZ,EAAqB4Z,EAAOla,EAAkB2c,EAAQ,GAAGlc,KAAMkc,EAAQ,GAAGjc,MACtF,CAGF,CAEO8D,2BAA2BsY,GACjC,MAAMH,EAAgC,GAEtC,GAAIzc,EAAa4c,GACf,OAAOH,EAGT,IAAKG,EAAOjM,MAAM,UAAW,CAC3B,MAAMkM,EAAS,IAAI9Z,EAAmB,CAAC6Z,GAAS,GAAI,CAAA,EAAI,CAAA,GAGxD,OAFAH,EAAQrb,KAAKyb,GAENJ,CACR,CAED,MAAMK,EAAaF,EAAO7b,MAAM,KAEhC,IAAI8b,EACAtc,EAA+B,CAAA,EAC/BC,EAA6B,CAAA,EAC7ByC,EAAgC,CAAA,EA4CpC,OA1CA6Z,EAAWjE,SAAQ,CAAC/X,EAAOyW,KACzB,MAAMwF,EAAYjc,EAAMI,OAEV,IAAVqW,GAAgBwF,EAAUpM,MAAM,UAClCkM,EAAS,IAAI9Z,EAAmB,CAACga,GAAYxc,EAAMC,EAAOyC,IAG5D,MAAM+Z,EAAcD,EAAUE,SAAS,MACjCC,EAAcH,EAAUE,SAAS,KAEvC,GAAID,EAAa,CACf,MAAOG,EAAQC,GAAYL,EAAUhc,MAAM,MAE3CR,EAAK4c,GAAUC,EAASlc,OAAO6D,QAAQ,SAAU,IAAItC,UACtD,MAAM,GAAIya,EAAa,CACtB,MAAOG,EAASC,GAAaP,EAAUhc,MAAM,KACvCwc,EAAeD,EAAUpc,OAAO6D,QAAQ,SAAU,IAAItC,WAG5D,GAFiB4a,EAAQJ,SAAS,KAI3B,CACL,MAAOO,EAAcC,GAAYJ,EAAQtc,MAAM,KAC/CkC,EAAMua,GAAgBC,EAEL,WAAbA,EACFjd,EAAMgd,GAAgBpJ,OAAOmJ,GACP,YAAbE,EACTjd,EAAMgd,GAAiC,SAAjBD,EACA,WAAbE,EACTjd,EAAMgd,GAAgB,IAAI9G,EAAW6G,IAC5BE,EAAShK,WAAW,SAC7BjT,EAAMgd,GAAgBD,EAIzB,MAhBC/c,EAAM6c,GAAWE,CAiBpB,KAGHd,EAAQrb,KAAKyb,GAENJ,CACR,CAEOnY,kCAAkCmY,GACxC,IAAK,MAAMI,KAAUJ,EACnB,IAAK,MAAO5Z,EAAKwB,KAAS1B,OAAOmC,QAAQ+X,EAAO5Z,OAC9C,GAAa,WAAToB,EACF,GAAa,WAATA,EACFwY,EAAOrc,MAAMqC,GAAOuR,OAAOyI,EAAOrc,MAAMqC,GAAKJ,WAAWvB,aACnD,GAAa,WAATmD,EACTwY,EAAOrc,MAAMqC,GAAO,IAAI6T,EAAWmG,EAAOrc,MAAMqC,GAAKJ,WAAWvB,YAC3D,KAAImD,EAAKoP,WAAW,SA+BzB,MAAM,IAAI/R,MAAM,kDAAoDmB,EAAM,OAASwB,GA/BhD,CACnC,IAAIqZ,EAAWrZ,EAAKwN,QAAQ,KACxB8L,EAAStZ,EAAKwN,QAAQ,KAC1B,GAAK6L,EAAW,GAAKC,GAAUD,GAAcA,EAAW,GAAKC,EAAS,EACpE,MAAM,IAAIjc,MAAM,uDAAyDmB,EAAM,OAASwB,GAG1F,IAAIuZ,EAAW,SACXD,EAASD,IACXE,EAAWvZ,EAAKiL,UAAUoO,EAAW,EAAGC,GAAQzc,QAGlD,MAAM2c,EAAwBvc,EAAmBC,qBAC/Csb,EAAOrc,MAAMqC,GAAKJ,WAAWvB,OAC7B,KACA,GAEI4c,EAAqB,GAC3B,IAAK,IAAIC,KAASF,EAChB,GAAiB,WAAbD,EACFE,EAAO1c,KAAK2c,QACP,GAAiB,WAAbH,EACTE,EAAO1c,KAAKgT,OAAO2J,EAAM7c,aACpB,IAAiB,WAAb0c,EAGT,MAAM,IAAIlc,MAAM,uDAAyDmB,EAAM,OAASwB,GAFxFyZ,EAAO1c,KAAK,IAAIsV,EAAWqH,EAAM7c,QAGlC,CAEH2b,EAAOrc,MAAMqC,GAAOib,CACrB,CAEA,CAKP,OAAOrB,CACR,CAEOnY,6BACN0V,EACAR,EACAa,GAEA,MAAM7Z,EAAyB,IAAK6Z,EAAUpY,iBAc9C,IAAI1B,EAMJ,OAlBAC,EZnZuB,oBYmZK6Z,EAAUpY,gBAAgBnC,GACtDU,EAA+B,KAAKgZ,EZ5SlB,iBAtGA,mBADF,iBYoZhBhZ,EAAkC,QAAI6Z,EAAUpY,gBZnNnB,kBYqNzBuX,EZ7ViB,sBY8VnBhZ,EAAoC,UAAIgZ,EZ9VrB,qBYiWjBA,EZzYmB,wBY0YrBhZ,EAAsC,YAAIgZ,EZ1YrB,uBY+YrBjZ,EADE8Z,EAAUnY,gBAAmC,UACxC,CAAE8b,UAAkC3D,EAAUnY,gBAAmC,WAEjF,CAAA,EAEF,IAAI9B,EAAqB4Z,EZraT,mBYqaoCzZ,EAAMC,EAClE,CAEO8D,+BAA+BmY,EAA+BC,GACpE,GAAW,MAAPA,EACFD,EAAQpX,OAAS,OAEjB,IAAK,MAAMwX,KAAUJ,EAAS,CAC5B,IAAI3b,EAAQ+b,EAAOrc,MZ3OM,kBY4OrBM,UACF+b,EAAOrc,MZ7OgB,kBY6OkB,IAAIkW,EAAW5V,EAAM2B,YAEjE,CAGH,OAAOga,CACR,CAEOnY,uBAAuBmY,EAA+BzC,GAC5D,MAAMiE,EAAwC,GAC9C,IAAK,MAAMpB,KAAUJ,EACnB,IAAK,MAAMZ,KAAQgB,EAAO7Z,MAAO,CAC/B,MAAMxC,EAA6Bqc,EAAOrc,MACpC0d,EAAgC,CACpCpe,CAACA,GAAmB+b,KACjBrb,EACHV,CAACA,GAAmB+b,GAEhB5E,EAAahT,EAAOkV,QAAQ+E,GAE5BC,EAAkC,IADHtB,EAAOtc,KAG1C6d,iBAAkBnH,EAAGxU,YAGvBwb,EAAQ7c,KAAK,IAAI6X,EAAsBe,EAAOla,EAAkBqe,EAASD,GAC1E,CAGH,OAAOD,CACR,CAEO3Z,kCAAkCmY,EAA+BzC,GACvE,MAAMiE,EAA+B,GACrC,IAAK,MAAMpB,KAAUJ,EACnB,IACE,IAAI4B,EAAoBxB,EAAOtc,KAAqB,OACpD,MAAM0W,EAAeoH,EACjBpa,EAAOyM,MAAM2N,EAAUnd,OAAO6D,QAAQ,SAAU,IAAItC,YACpD,IAAIwB,EAAO,KAAMD,EAAWU,UAAW,KAAM,IACjD,IAAK,MAAMmX,KAAQgB,EAAO7Z,MAAO,CAC/B,GAAI6Y,EAAKpI,WAAW,mBAClB,MAAM,IAAI/R,MAAM,+CAAiDma,EAAO,gBAG1EoC,EAAQ7c,KAAK,IAAI6X,EAAsBe,EAAO6B,EAAMgB,EAAOtc,KAAMsc,EAAOrc,MAAOyW,GAChF,CAGF,CAFC,MAAOkD,GACP,MAAM,IAAIzY,MAAM,+BAAiCyY,EAClD,CAGH,OAAO8D,CACR,CAEO3Z,kCAAkCmY,EAA+BzC,GACvE,MAAMC,EAAmC,GACzC,IAAK,MAAM4C,KAAUJ,EACnB,IAAK,MAAMZ,KAAQgB,EAAO7Z,MAAO,CAC/B,GAAI6Y,EAAKpI,WAAW,mBAClB,MAAM,IAAI/R,MAAM,+CAAiDma,EAAO,gBAG1E5B,EAAQ7Y,KAAK,IAAIhB,EAAqB4Z,EAAO6B,EAAMgB,EAAOtc,KAAMsc,EAAOrc,OACxE,CAGH,OAAOyZ,CACR,CAEOiB,sBAAsB1B,GAC5B3Y,KAAKkZ,iBAAmB,mBAExB,MAAM0C,EAAqCnb,EAAmBmZ,oBAC5DjB,EZhd0B,4BYmd5B,GAAIiD,EAAQpX,OAAS,EACnB,IAAK,MAAMwW,KAAQY,EAAQ,GAAGzZ,MAC5B,GZ5ZgB,SY4ZZ6Y,EAA0B,CAC5Bhb,KAAKkZ,iBAAmB,kBACxB,IAAK,MAAOlX,EAAK/B,KAAU6B,OAAOmC,QAAQ2X,EAAQ,GAAGlc,MAC/CsC,EAAIuP,gBZ3QM,UY2Q8BA,cAC1CvR,KAAKgZ,qBAAuB/Y,EACnB+B,EAAIuP,gBZtQD,UYsQqCA,gBACjDvR,KAAKiZ,qBAAuBhZ,GAGhC,KACD,CAGN,QCvgBUwd,EACMlJ,GACAoE,UACAgD,gBACA+B,aACAvJ,QACAwJ,aAAwC,GACxCC,aAAyC,GAEzCC,OACAC,yBACTC,OAERhe,YAAY8d,EAAoBtJ,EAAYoE,GAC1C3Y,KAAK6d,OAASA,EACd7d,KAAKuU,GAAKA,EACVvU,KAAK2Y,UAAYA,EAEjB,MAAMqF,EAAqB,IAAIvd,EAAmBod,EAAOI,eAAeC,YAAale,KAAM2Y,GAE3F3Y,KAAK2b,gBAAkBqC,EAAGzE,qBAC1BvZ,KAAKmU,QAAU6J,EAAGlD,mBAClB9a,KAAK2d,aAAeK,EAAG7C,kBACvBnb,KAAK4d,aAAeI,EAAG5C,kBACvBpb,KAAK8d,yBAA2BE,EAAGpD,sBACnC5a,KAAK0d,aAAeM,EAAGnD,iBACxB,CAEDsD,8BACE,OAAOne,KAAK8d,wBACb,CAED/c,OAAOC,GACL,OAAI7B,EAAa6B,IAAYA,aAAiByc,IAGvCzd,KAAK6a,oBAAsB7Z,EAAM6Z,mBAAuE,IAAlD7a,KAAKiB,aAAaC,QAAQF,EAAMC,cAC9F,CAEDmd,YACE,OAAOpe,KAAK6d,MACb,CAED1C,gBAAgB1b,GACd,IAAI2V,EAASpV,KAAK2d,aAIlB,OAHKxe,EAAaM,KAChB2V,EAASpV,KAAK2d,aAAa5Y,QAAQ0R,GAAQA,EAAItV,iBAAmB1B,KAE7D2V,CACR,CAEDiJ,wBAAwB5e,GACtB,IAAI2V,EAASpV,KAAK2d,aAIlB,OAHKxe,EAAaM,KAChB2V,EAASpV,KAAK2d,aAAa5Y,QAAQ0R,GAAQA,EAAItV,iBAAmB1B,KAE7D2V,CACR,CAEDkJ,wBAAwB7e,GACtB,IAAI2V,EAASpV,KAAK4d,aAIlB,OAHIte,EAAaG,KACf2V,EAASpV,KAAK4d,aAAa7Y,QAAQwZ,GAAQA,EAAIpd,iBAAmB1B,KAE7D2V,CACR,CAEDgG,gBAAgB3b,GACd,OAAOO,KAAKse,wBAAwB7e,EACrC,CAEDob,kBACE,OAAO7a,KAAK0d,YACb,CAEDzc,aACE,OAAOjB,KAAKmU,OACb,CAEDqK,YACE,OAAOxe,KAAK+d,MACb,CAEDU,aACE,MAAO,IAAKze,KAAK2Y,UAClB,CAEDY,qBACE,OAAOvZ,KAAK2b,eACb,CAED+C,QACE,OAAO1e,KAAKuU,EACb,CAEDoK,QAAQZ,GACN/d,KAAK+d,OAASA,CACf,CAEDnc,WACE,OAAO5B,KAAK6d,OAAS,OAAS7d,KAAKuU,GAAK,GACzC,QChGUqK,EACMrK,GACAsK,iBACAC,eACAC,QACAC,QACAC,iBACAC,4BACTC,UACAC,QACAC,MACSC,UAAkC,GAC3CC,gBACWC,OAEnBzf,YACEyf,EACAjL,EACAwK,EACAF,EACAC,EACAE,EACAC,GAiBA,GAfAjf,KAAKwf,OAASA,EACdxf,KAAKuU,GAAKA,EACVvU,KAAK8e,eAAiBA,EACtB9e,KAAK6e,iBAAmBA,EACxB7e,KAAKkf,6BAA8B,EACnClf,KAAKqf,MAAQ,YACbrf,KAAK+e,QAAUA,EACf/e,KAAKgf,QAAUA,EACfhf,KAAKif,iBAAmBA,EAEtB3f,EAAayf,EdRM,sBcS6C,mBAAxDA,EdTW,oBcSmCpa,QAEtD3E,KAAKmf,UAAYJ,EdXE,qBcajBzf,EAAa0f,GAAU,CACzB,MAAMxf,EAAWQ,KAAKyf,iBACtBzf,KAAK0f,YAAYlgB,EAClB,CACF,CAEDmgB,wBACE,OAAO3f,KAAKie,eAAe2B,4BAA4B5f,KACxD,CAED6f,mBACE,MAAM,IAAIhf,MAAM,0BACjB,CAEDif,cACE,OAAO9f,KAAKuU,EACb,CAEDwL,mBACE,OAAO/f,KAAKof,OACb,CAEDY,iBAAiBZ,GACfpf,KAAKof,QAAUA,CAChB,CAEDX,aACE,OAAOze,KAAK+e,OACb,CAEDkB,WACE,OAAOjgB,KAAKqf,KACb,CAEDa,SAASb,GACPrf,KAAKqf,MAAQA,CACd,CAEDxE,kBACE,OAAO7a,KAAKmgB,qBAAqBtF,iBAClC,CAED5Z,aACE,OAAOjB,KAAKmgB,qBAAqBlf,YAClC,CAEDmf,YAAY9b,SACJtE,KAAKie,eAAeoC,YAAYrgB,KACvC,CAEDogB,WAAW9b,SACHtE,KAAKie,eAAeqC,WAAWtgB,KACtC,CAEDogB,kBACE,OAAOpgB,KAAKie,eAAesC,gBAAgBvgB,KAC5C,CAEDogB,aAAarB,EAAgClB,SACrC7d,KAAKie,eAAeuC,aAAaxgB,KAAM+e,EAASlB,EACvD,CAED4C,sBACE,OAAOzgB,KAAK6a,kBAAoB,IAAM7a,KAAKiB,aAAaW,UACzD,CAED8e,eACE,OAAO1gB,KAAKmf,SACb,CAEDwB,aAAaxB,GACXnf,KAAKmf,UAAYA,CAClB,CAEDyB,oBACE,OAAO5gB,KAAK8e,cACb,CAED+B,OAAO9B,GACL,MAAM+B,EAAkB9gB,KAAKyf,eAAeV,GAC5C/e,KAAK0f,YAAYoB,EAClB,CAEDV,gBACE,MAAMW,EAAU/gB,KAAKmgB,qBAEjBngB,KAAKghB,mBACPhhB,KAAKihB,kBAELjhB,KAAKie,eAAeiD,cAAcC,eAAeJ,GACjDA,EAAQpC,QAAQ,OAGlB3e,KAAKsf,UAAU9a,OAAS,EACxBxE,KAAK0f,YAAYqB,GACjB/gB,KAAKqf,MAAQ,WACd,CAEOI,eAAeV,GACrB,MAAMvf,EAAW,IAAIie,EACnBzd,KACAA,KAAK8f,cAAgB,IAAM9f,KAAKsf,UAAU9a,OAC1Cua,GAAW/e,KAAK+e,SAGlB,IAAIhG,EAAgBvZ,EAASyB,aAC7B8X,EAAgB5Z,EAAa4Z,GAAiB,IAAIlD,EAAW,SAAWkD,EACxE,MAAM+C,EAAUtc,EAASqb,kBAEnBuG,EAAqC,GACrCC,EAAUrhB,KAAKie,eAAeqD,aACpC,IAAK,IAAIlhB,EAAI,EAAGiM,MAAM+E,QAAQiQ,IAAYjhB,EAAIihB,EAAQ7c,OAAQpE,IAAK,CACrDihB,EAAQjhB,GAAkB0f,gBAC3B9f,KAAK8f,eACVhE,IAAYuF,EAAQjhB,GAAGya,mBAAqBjF,EAAMmD,EAAesI,EAAQjhB,GAAGa,eAC9EmgB,EAAoB7gB,KAAK8gB,EAAQjhB,GAGtC,CACD,GAAIghB,EAAoB5c,QAAUlF,EAAaU,KAAKif,kBAClD,MAAM,IAAIpe,MAAM,oDAAsDib,EAAU,IAAM/C,GAGxF,OAAOvZ,CACR,CAEOyhB,iBACN,IAAK,MAAMM,KAAMvhB,KAAKsf,UACpBtf,KAAKie,eAAeiD,cAAcC,eAAeI,EAEpD,CAEDP,mBACE,MAAsB,gBAAfhhB,KAAKqf,OAA2Brf,KAAKsf,UAAU9a,OAAS,CAChE,CAEDkb,YAAYlgB,GACVQ,KAAKsf,UAAUkC,QAAQhiB,GACvBQ,KAAKuf,gBAAkB/f,EAEvBQ,KAAKie,eAAeiD,cAAcxB,YAAYlgB,EAC/C,CAEDye,eACE,OAAOje,KAAKgf,OACb,CAEDmB,qBACE,OAAOngB,KAAKuf,eACb,CAEDkC,eACE,OAAOzhB,KAAKsf,SACb,CAEDoC,cACE,OAAO1hB,KAAK6e,gBACb,CAEDjd,WACE,MAAO,GAAG5B,KAAK6a,sBAAsB7a,KAAKiB,aAAaW,YACxD,QCjNU+f,EACM9D,OACAuB,QACAwC,SACA7c,OAEjBhF,YACE8hB,EACAhE,EACAuB,EACAwC,EACA7c,GAEI8c,GACF7hB,KAAK6d,OAASgE,EAAKhE,OACnB7d,KAAKof,QAAUyC,EAAKzC,QACpBpf,KAAK4hB,SAAWC,EAAKD,SACrB5hB,KAAK+E,OAAS8c,EAAK9c,SAEnB/E,KAAK6d,OAASA,EACd7d,KAAKof,QAAUA,EACfpf,KAAK4hB,SAAWA,EAChB5hB,KAAK+E,OAASA,EAEjB,CAEMqZ,YACL,OAAOpe,KAAK6d,MACb,CAEMkC,mBACL,OAAO/f,KAAKof,OACb,CAEM0C,cACL,OAAO9hB,KAAK4hB,QACb,CAEMG,kBACL,OAAO/hB,KAAK+E,MACb,CAEMyT,YACL,GAAMxY,KAAK+E,OACT,OAAO/E,KAAK+E,OAAOnD,UAGtB,QCtDUogB,EACkBxe,KAAyCye,UAAtEliB,YAA6ByD,EAAyCye,GAAzCjiB,KAAIwD,KAAJA,EAAyCxD,KAASiiB,UAATA,CAAoC,CAE1GC,sBACE,OAAOliB,KAAKiiB,SACb,CAEDE,UACE,OAAOniB,KAAKwD,IACb,CAED5B,WACE,MAAO,YAAY5B,KAAKiiB,UAAUG,YhBwHnB,mCgBxHgEpiB,KAAKwD,OACrF,QCUU6e,EACM7C,OACT8C,aAAwD,IAAIrf,IAC5Dsf,aAAwD,IAAItf,IAC5Duf,aAAwD,IAAIvf,IAEpElD,YAAYyf,GACVxf,KAAKwf,OAASA,CACf,CAEDiD,iBAAiBC,EAAqBC,GACpC,MAAMC,EAAqD,IAAI3f,IAC7DjD,KAAKsiB,aAAare,WAGpBoe,EAAgBQ,qBAAqB,UAAWD,EAAWF,EAAOC,EACnE,CAEDG,mBAAmBJ,EAAuBK,GACxC,MAAMH,EAAqD,IAAI3f,IAC7DjD,KAAKwiB,aAAave,WAGpBoe,EAAgBQ,qBAAqB,YAAaD,EAAWF,EAAOK,EACrE,CAEDC,gBAAgBN,EAAoBK,GAClC,MAAMH,EAAqD,IAAI3f,IAC7DjD,KAAKuiB,aAAate,WAGpBoe,EAAgBQ,qBAAqB,SAAUD,EAAWF,EAAOK,EAClE,CAEOtf,4BACND,EACAof,EACAF,EACAC,GAEA,IAAK,IAAKM,EAAKC,KAAWN,EAAU3e,UAClC,IAAK,IAAI4d,KAAQqB,EAAQ,CACvB,MAAMrF,EAASgE,EAAKzD,YACdwD,EAAWC,EAAKC,cAChB/c,EAAoB8c,EAAKE,kBAE/B,OAAQve,GACN,IAAK,YACH6e,EAAgBc,gCAAgCtF,EAAQ+D,EAA+Bc,GACvF,MACF,IAAK,SACHL,EAAgBe,6BAA6BvF,EAAQ+D,EAA4Bc,GACjF,MACF,IAAK,UACHL,EAAgBgB,8BAA8BxF,EAAQ+D,EAA6Bc,EAAO3d,EAAQ4d,GAClG,MACF,QACE,MAAM,IAAI9hB,MAAM,yBAAyB2C,MAE9C,CAEJ,CAEOC,qCACNoa,EACA+D,EACAc,EACA3d,EACA4d,GAGA,IAD6C,CAAC,WAAY,WAAY,UAC3CvG,SAASyB,EAAOoC,YACzC,OAOF,GAHE9gB,EAAa4F,IACbgR,EAAc1B,QAAQqO,EAAMR,sBAAgDnd,GAG5E6c,EAAS0B,eAAeZ,QACnB,GAAuB,YAAnBA,EAAMP,WACTpd,GAAUA,EAAO+K,MAAM6S,GAAW,CACtC,IAAIY,EAAK,IAAIvB,EAAiB,oBAAqBU,EAAMR,uBACrDN,EAAS4B,OACX5B,EAAS0B,eAAeC,GAExBE,YAAW,IAAM7B,EAAS0B,eAAeC,IAAK,EAEjD,CAEJ,CAEO9f,oCAAoCoa,EAAgB+D,EAA0Bc,GAC9B,CAAC,WAAY,WAAY,UAC5CtG,SAASyB,EAAOoC,cAC7C2B,EAAS4B,OACX5B,EAAS8B,cAAchB,GAEvBe,YAAW,IAAM7B,EAAS8B,cAAchB,IAAQ,GAGrD,CAEOjf,uCACNoa,EACA+D,EACAc,GAE6C,CAAC,WAAY,UAChCtG,SAASyB,EAAOoC,cACpC2B,EAAS4B,OACX5B,EAAS+B,eAAejB,GAExBe,YAAW,IAAM7B,EAAS+B,eAAejB,IAAQ,GAGtD,CAEDkB,YAAaC,EAAmBrgB,EAAoBoe,EAAe7c,GACjE,IAAK6c,EACH,MAAM,IAAI/gB,MAAM,uBAGlB,MAAMijB,EAAY9jB,KAAK+jB,eAAeF,EAAIrgB,EAAMoe,EAAU7c,GAE1D,GAAI+e,EACF,OAAOA,EAGT,IACED,EAAGzF,WAIJ,CAHC,MAAO9E,GAEP,MACD,CAED,IAAIsJ,EAAqD,KAEzD,GAAa,cAATpf,EACFof,EAAY5iB,KAAKwiB,kBACZ,GAAa,WAAThf,EACTof,EAAY5iB,KAAKuiB,iBACZ,IAAa,YAAT/e,EAGT,MAAM,IAAI3C,MAAM,qBAAuB2C,GAFvCof,EAAY5iB,KAAKsiB,YAGlB,CAED,MAAMT,EAAqB,IAAIF,EAAa,KAAMkC,EAAGzF,YAAayF,EAAIjC,EAAU7c,GAChF6d,EAAYP,EAAgB2B,gBAAgBpB,EAAWf,GAE1C,cAATre,EACFxD,KAAKwiB,aAAeI,EACF,WAATpf,EACTxD,KAAKuiB,aAAeK,EACF,YAATpf,IACTxD,KAAKsiB,aAAeM,EAIvB,CAEDqB,eAAeJ,EAAmBrgB,EAAoBoe,GACpD,IAAIgB,EAAqD,KAEzD,IAAKhB,EACH,MAAM,IAAI/gB,MAAM,uBAGlB,GAAa,cAAT2C,EACFof,EAAY5iB,KAAKwiB,kBACZ,GAAa,WAAThf,EACTof,EAAY5iB,KAAKuiB,iBACZ,IAAa,YAAT/e,EAGT,MAAM,IAAI3C,MAAM,qBAAuB2C,GAFvCof,EAAY5iB,KAAKsiB,YAGlB,CAGD,IAAIrH,GAAe,EACnB,IAAK,IAAK4I,EAAIK,KAAUtB,EAAU3e,UAChC,IAAK,IAAI7D,EAAI,EAAGA,EAAI8jB,EAAM1f,OAAQpE,IAAK,CACrC,IAAIyhB,EAAqBqC,EAAM9jB,GAC/B,GAAIyhB,EAAK9B,mBAAmBhf,OAAO8iB,IAAOhC,EAAKC,gBAAkBF,EAAU,CACzE3G,EAAM7a,EACN,KACD,CACF,CAGC6a,GAAO,IACT2H,EAAYP,EAAgB8B,mBAAmBvB,EAAWiB,EAAI5I,IAGnD,cAATzX,EACFxD,KAAKwiB,aAAeI,EACF,WAATpf,EACTxD,KAAKuiB,aAAeK,EACF,YAATpf,IACTxD,KAAKsiB,aAAeM,EAEvB,CAEDwB,gBAAgBP,GACd7jB,KAAKwiB,aAAeH,EAAgBgC,oBAAoBrkB,KAAKwiB,aAAcqB,GAC3E7jB,KAAKuiB,aAAeF,EAAgBgC,oBAAoBrkB,KAAKuiB,aAAcsB,GAC3E7jB,KAAKsiB,aAAeD,EAAgBgC,oBAAoBrkB,KAAKsiB,aAAcuB,EAC5E,CAEOpgB,2BACNmf,EACAiB,GAEA,MAAMS,EAAgD,IAAIrhB,IACxD2f,EAAU3e,WAGZ,OADAqgB,EAAKvN,OAAO8M,GACLS,CACR,CAEO7gB,0BACNmf,EACAiB,EACA5I,GAEA,MAAMqJ,EAAgD,IAAIrhB,IACxD2f,EAAU3e,WAENigB,EAA6B,IAAII,EAAKC,IAAIV,IAEhD,OADAS,EAAKvN,OAAO8M,GACRxX,MAAM+E,QAAQ8S,IAChBA,EAAMlY,OAAOiP,EAAK,GACdiJ,EAAM1f,OAAS,GACjB8f,EAAKE,IAAIX,EAAIK,GAERI,GAEF1B,CACR,CAEDmB,eAAeF,EAAmBrgB,EAAoBoe,EAAe7c,GACnE,GAAa,YAATvB,EAAoB,CAEtB,IACEqgB,EAAGzF,WAGJ,CAFC,MAAOqG,GACP,MACD,CAED,MAAMP,EAA6BlkB,KAAKsiB,aAAaiC,IAAIV,GACzD,IAAK,IAAIzjB,EAAI,EAAGd,EAAa4kB,IAAU9jB,EAAI8jB,EAAM1f,OAAQpE,IAAK,CAC5D,MAAMyhB,EAAqBqC,EAAM9jB,GACjC,GAAIyhB,EAAK9B,mBAAmBhf,OAAO8iB,IAAOhC,EAAKC,gBAAkBF,EAAU,CAEzE,MAAMkC,EAAYjC,EAAKE,kBACjB2C,EAAU,IAAI/C,EAAa,KAAME,EAAKzD,YAAayD,EAAK9B,mBAAoB8B,EAAKC,cAAe/c,GAEtG,OADA/E,KAAKsiB,aAAeD,EAAgBsC,mBAAmB3kB,KAAKsiB,aAAcliB,EAAGskB,GACtEZ,CACR,CACF,CACF,CAGF,CAEOrgB,0BACNmf,EACA3H,EACA4G,GAEA,IAAIyC,EAAgD,IAAIrhB,IAAwC2f,GAC5FsB,EAA6BI,EAAKC,IAAI1C,EAAK9B,oBAE/C,OADAuE,EAAKvN,OAAO8K,EAAK9B,oBACbzgB,EAAa4kB,IACfA,EAAQ,IAAIA,GACZA,EAAMjJ,GAAO4G,EACbyC,EAAKE,IAAI3C,EAAK9B,mBAAoBmE,GAC3BI,GAEF1B,CACR,CAEOnf,uBACNmf,EACAf,GAEKe,EAAUlhB,IAAImgB,EAAK9B,qBACtB6C,EAAU4B,IAAI3C,EAAK9B,mBAAoB,IAMzC,OAJc6C,EAAU2B,IAAI1C,EAAK9B,oBAE3Bxf,KAAKshB,GAEJe,CACR,QC5TUgC,EACMC,IACAzF,QACAJ,QAEjBjf,YAAY8kB,EAA0BzF,EAA4BJ,GAChEhf,KAAK6kB,IAAMA,EACX7kB,KAAKof,QAAUA,EACfpf,KAAKgf,QAAUA,CAChB,CAED8F,aAGE,OAFA9kB,KAAKof,QAAQ2F,gBAEN/kB,KAAKgf,QAAQ8F,WAAW9kB,KAAKof,QAAQhB,YAAape,KAAK6kB,KAAK,EACpE,CAED3C,sBACE,OAAOliB,KAAK6kB,GACb,CAEDG,aAAaC,GAGX,GAFAjlB,KAAKof,QAAQ2F,gBAETzlB,EAAaU,KAAK6kB,IAAIzG,eAAiBpe,KAAKgf,QAAQgG,aAAahlB,KAAK6kB,IAAIzG,YAAape,KAAK6kB,IAAKI,GACnG,MAAM,IAAIpkB,MAAM,yBAAyBokB,IAE5C,ECrBA,MACYC,EACbC,QAAS,EACDC,cAAgB,EAChBC,QAAqB,IAAIpiB,IACzBqiB,OAAmB,GACnBC,QAAoB,GA6B5BC,WAAWlO,EAAY,IACrB,IAAK,MAAMhF,KAAQgF,EACZhF,GAGLtS,KAAKulB,QAAQhlB,KAAK+R,EAErB,CAEDmT,eACE,OAAa,CACX,IAAInT,EACJ,GAAItS,KAAKmlB,QAAkC,IAAxBnlB,KAAKulB,QAAQ/gB,OAC9B,OAEF8N,EAAOtS,KAAKulB,QAAQ,GACpBvlB,KAAKulB,QAAQvZ,OAAO,EAAG,GACnBhM,KAAKqlB,QAAQd,IAAIjS,KAGjBtS,KAAKslB,OAAOlJ,SAAS9J,KAGzBtS,KAAKslB,OAAO/kB,KAAK+R,GACjBtS,KAAK0lB,YAAYpT,OAAM1O,IACxB,CACF,CAED+hB,QACE3lB,KAAKmlB,QAAS,CACf,CAEDS,MAAMtT,EAASuT,GACb,IAAIC,EACJ,IAAI9lB,KAAKmlB,OAAT,CAIA,GADAW,EAAS9lB,KAAKqlB,QAAQd,IAAIjS,GACtBnT,EAAa2mB,GAAS,CACxB,GAAI9lB,KAAKslB,OAAOlJ,SAAS9J,GACvB,OAEFtS,KAAKslB,OAAO/kB,KAAK+R,EAClB,MACCtS,KAAK+lB,WAEH5mB,EAAa2mB,GACf9lB,KAAK0lB,YAAYpT,EAAMuT,GAEvB7lB,KAAKgmB,mBAAmB1T,EAAMwT,EAAQD,EAbvC,CAeF,CAEDI,QAAQ3T,EAASuT,GACf,IAAIC,EACJ,MAAMI,EAAalmB,KAAKulB,QAAQY,WAAW/lB,GAAMA,IAAMkS,IACvD,GAAI4T,GAAc,EAEhB,YADAlmB,KAAKulB,QAAQvZ,OAAOka,EAAY,GAGlC,MAAME,EAAYpmB,KAAKslB,OAAOa,WAAWra,GAAMA,IAAMwG,IACjD8T,GAAa,EACfpmB,KAAKslB,OAAOtZ,OAAOoa,EAAW,IAGhCN,EAAS9lB,KAAKqlB,QAAQd,IAAIjS,GAC1BtS,KAAKqlB,QAAQtO,OAAOzE,GAChBnT,EAAa2mB,KAGjB9lB,KAAK+lB,WACL/lB,KAAKqmB,kBAAkB/T,EAAMwT,EAAQD,IACtC,CAEDpkB,OACE,OAAOzB,KAAKqlB,QAAQ5jB,IACrB,CAED6kB,UACE,OAAuB,IAAhBtmB,KAAKyB,MACb,CAED8kB,oBAAoBjU,GAClB,OAAOtS,KAAKqlB,QAAQd,IAAIjS,EACzB,CAEDkU,SAASlP,GACP,MAAO,IAAIA,KAASjL,MAAMoa,KAAKzmB,KAAKqlB,QAAQtjB,QAC7C,CAEDgkB,WACE/lB,KAAKolB,eACN,CAEDsB,mBACE,OAAO1mB,KAAKolB,aACb,CAEOM,YAAYpT,EAASuT,GAC3B,IAAIC,EACAa,GAAkB,EACtB,IACEb,EAAS9lB,KAAK4mB,iBAAiBtU,EAAMuT,EAYtC,CAXS,QACR,MAAM5K,EAAMjb,KAAKslB,OAAOa,WAAWra,GAAMA,IAAMwG,IAC3C2I,GAAO,IAAMjb,KAAKmlB,QACpBnlB,KAAKslB,OAAOtZ,OAAOiP,EAAK,GACpB6K,IACF9lB,KAAKqlB,QAAQb,IAAIlS,EAAMwT,GACvB9lB,KAAK+lB,aAGPY,GAAkB,CAErB,CAEGA,GAAmBb,GACrB9lB,KAAKqmB,kBAAkB/T,EAAMwT,EAAQD,EAExC,ECxBH,MAAMgB,UAAmB3B,EACvB1B,QAAS,EAEDsD,QAER/mB,YAAY+mB,GACV5U,QACAlS,KAAK8mB,QAAUA,CAChB,CAEDF,iBAAiBtU,EAAcuT,GAC7B,OAAQ7lB,KAAK8mB,QAAiCC,WAAWC,aAAa1U,EAAMuT,EAC7E,CAEDG,mBAAmB1T,EAAcwT,EAAWD,GACzC7lB,KAAK8mB,QAAiCC,WAAWE,eAAe3U,EAAMuT,EAASC,EACjF,CAEDO,kBAAkB/T,EAAcwT,EAAWD,GACxC7lB,KAAK8mB,QAAiCC,WAAWG,cAAc5U,EAAMuT,EAASC,EAChF,CAEDpC,cAAchB,GACZ,GAAI1iB,KAAKmlB,OACP,OAEF,MAAMtH,EAAS6E,EAAMtE,YACfiB,EAAQxB,EAAOoC,WAEhBjgB,KAAK8mB,QAAiCK,mBAAmB/K,SAASiD,GACrErf,KAAK4lB,MAAM/H,EAAQ6E,GAMnB1iB,KAAKimB,QAAQpI,EAAQ6E,EAMxB,ECsEH,MAAMmE,UAAsB3B,EAC1B1B,QAAS,EACDsD,QAER/mB,YAAY+mB,GACV5U,QACAlS,KAAK8mB,QAAUA,CAChB,CAEDxD,eAAeZ,GACb,GAAI1iB,KAAKmlB,OACP,OAEF,MAAMlD,EAAiCS,EAAMR,sBAE7C,OAAQQ,EAAMP,WACZ,IAAK,aACL,IAAK,WACHniB,KAAK4lB,MAAM3D,EAAWS,GACtB,MACF,IAAK,oBACL,IAAK,gBACH1iB,KAAKimB,QAAQhE,EAAWS,GAG7B,CAEDqD,WACE7T,MAAM6T,WACN/lB,KAAK8mB,QAAQf,UACd,CAEDa,iBAAiBtU,EAA2BuT,GAC1C,OAAO7lB,KAAK8mB,QAAQC,WAAWK,cAAc9U,EAC9C,CAED0T,mBAAmB1T,EAA2BwT,EAAWD,GACvD7lB,KAAK8mB,QAAQC,WAAWM,gBAAgB/U,EAAMwT,EAC/C,CAEDO,kBAAkB/T,EAA2BwT,EAAWD,GACtD7lB,KAAK8mB,QAAQC,WAAWO,eAAehV,EAAMwT,EAC9C,EAGH,MAAMyB,UAAyBV,EAC7B9mB,YAAY+mB,GACV5U,MAAM4U,EACP,QC7QUU,EAMQhI,OACA3B,OACAmB,QAPXyI,OAAQ,EACRC,eAAuC,GACvCC,gBAA8C,GAEtD5nB,YACmByf,EACA3B,EACAmB,GAFAhf,KAAMwf,OAANA,EACAxf,KAAM6d,OAANA,EACA7d,KAAOgf,QAAPA,CACf,CAEJ4I,kBAAkBhG,GAChB5hB,KAAK+kB,gBAEL/kB,KAAKgf,QAAQ4I,kBAAkB5nB,KAAK6d,OAAQ+D,EAC7C,CAEDiG,qBAAqBjG,GACnB5hB,KAAK+kB,gBAEL/kB,KAAKgf,QAAQ6I,qBAAqB7nB,KAAK6d,OAAQ+D,EAChD,CAEDkG,qBAAqBlG,GACnB5hB,KAAK+kB,gBAEL/kB,KAAKgf,QAAQ8I,qBAAqB9nB,KAAK6d,OAAQ+D,EAChD,CAEDmG,wBAAwBnG,GACtB5hB,KAAK+kB,gBAEL/kB,KAAKgf,QAAQ+I,wBAAwB/nB,KAAK6d,OAAQ+D,EACnD,CAEDoG,aAAajjB,GAGX,OAFA/E,KAAK+kB,gBAEE3hB,EAAOyM,MAAM9K,EACrB,CAEDqZ,UAAU7J,GAGR,OAFAvU,KAAK+kB,gBAEDzlB,EAAaiV,GACRvU,KAAKgf,QAAQZ,UAAU7J,GAGzBvU,KAAK6d,MACb,CAEDyD,aAGE,OAFAthB,KAAK+kB,gBAEE/kB,KAAKgf,QAAQsC,WAAWthB,KAChC,CAEDoiB,YAAYpgB,GAGV,OAFAhC,KAAK+kB,gBAEE/kB,KAAKgf,QAAQoD,YAAYpgB,EACjC,CAEDoe,oBAAoB6H,GAUlB,MATiC,iBAAtBA,EACTjoB,KAAKwf,OAAO0I,MAAM,oCAAoCD,KAEtDjoB,KAAKwf,OAAO0I,MACV,sBAAsBD,EtB5CF,2BsB4C6CA,EtB/DlD,qBsBkEnBjoB,KAAK+kB,gBAEE/kB,KAAKgf,QAAQmJ,cAAcnoB,KAAK6d,OAAQoK,EAChD,CAEDG,mBAAmBxG,EAA2B7c,GAC5C/E,KAAK+kB,gBACL/kB,KAAKgf,QAAQoJ,mBAAmBpoB,KAAK6d,OAAQ+D,EAAU7c,EACxD,CAED+f,WAAc7C,GAGZ,GAFAjiB,KAAK+kB,gBAED5lB,EAAa8iB,GACf,MAAM,IAAIphB,MAAM,gDAGlB,OAAOb,KAAKgf,QAAQ8F,WAAW9kB,KAAK6d,OAAQoE,GAAW,EACxD,CAEDC,oBAAuBmG,GACrBroB,KAAK+kB,gBACL,IACE,MAAMuD,EAAOtoB,KAAKuoB,qBAAqBF,EAAY,MACnD,OAAOb,EAAkBgB,wBAAwBF,EAGlD,CAFC,MAAOhP,GACPtZ,KAAKwf,OAAOiJ,MAAM,sBAAwBnP,EAC3C,CAEF,CAEDoP,wBAAwBL,EAAqBtjB,GAG3C,OAFA/E,KAAK+kB,gBAEE/kB,KAAKgf,QAAQ2J,4BAA4B3oB,KAAK6d,OAAQwK,EAAYtjB,GAAQ,EAClF,CAEDwjB,qBAAwBF,EAAqBtjB,GAG3C,OAFA/E,KAAK+kB,gBAEE/kB,KAAKgf,QAAQ2J,4BAA4B3oB,KAAK6d,OAAQwK,EAAYtjB,GAAQ,EAClF,CAED6jB,gBACEC,EACA5D,EACA6D,GAGA,OADA9oB,KAAK+kB,gBACE/kB,KAAKgf,QAAQ4J,gBAAgB5oB,KAAM6oB,EAAa5D,EAAS6D,GAAc,CAAA,EAC/E,CAEDC,sBAAsBnH,GACpB5hB,KAAK+kB,gBACL/kB,KAAKgf,QAAQ+J,sBAAsB/oB,KAAK6d,OAAQ+D,EACjD,CAEDoD,aAAgB/C,GAGd,GAFAjiB,KAAK+kB,gBAED5lB,EAAa8iB,GACf,MAAM,IAAIphB,MAAM,kDAGlB,OAAOb,KAAKgf,QAAQgG,aAAahlB,KAAK6d,OAAQoE,EAAW,KAC1D,CAED+G,kBAAqB/G,GACnBjiB,KAAK+kB,gBAGL,GADa9C,EAAmCgH,kBACxCC,UACN,OAAO,IAAItE,EAAsB3C,EAAWjiB,KAAMA,KAAKgf,QAG1D,CAEDkK,UACE,OAAOlpB,KAAKynB,KACb,CAED0B,aACEnpB,KAAKynB,OAAQ,CACd,CAED1C,gBACE,GAAI/kB,KAAKynB,MACP,OAAQznB,KAAK6d,OAAOoC,YAClB,IAAK,SACL,IAAK,WACL,IAAK,WACH,OAIN,MAAM,IAAIpf,MAAM,yBACjB,CAEDE,OAAOC,GACL,OAAI7B,EAAa6B,IAAYA,aAAiBwmB,IAI5CxnB,KAAKoe,YAAYvD,oBAAsB7Z,EAAMod,YAAYvD,mBACzD7a,KAAKoe,YAAYnd,aAAaW,aAAeZ,EAAMod,YAAYnd,aAAaW,WAK/E,CAEDwnB,YAAeC,EAA8BtC,GAC3C/mB,KAAK+kB,gBAEL,MAAMuE,EAAOtpB,KAEP8mB,EAAU,IAAK,oBF9MdC,WACQ3H,QACAiK,cAA+B,GACxChE,QAERtlB,YAAYqf,EAAwBiK,EAA8BtC,GAChE/mB,KAAKof,QAAUA,EACfpf,KAAKqpB,cAAgBA,EACrBrpB,KAAK+mB,WAAaA,GAAc/mB,IACjC,CAEDupB,OACE,GAAIjqB,EAAaU,KAAKqlB,SACpB,OAGF,MAAMmE,EAAgB,IAAI3C,EAAQ7mB,MAElCA,KAAKof,QAAQwI,kBAAkB4B,GAE/B,MAAMnI,EAAUrhB,KAAKof,QAAQkC,aAE7B,GAAID,GAAWA,EAAQ7c,OAAQ,CAC7B,MAAMA,EAAS6c,EAAQ7c,OACvB,IAAK,IAAIpE,EAAI,EAAGA,EAAIoE,EAAQpE,IAAK,CAC/B,MAAMif,EAAQgC,EAAQjhB,GAAG6f,WACrBjgB,KAAKmnB,mBAAmB/K,SAASiD,KAEnCgC,EAAQjhB,QAAKwD,EAEhB,CAED4lB,EAAEhE,WAAWnE,EACd,CAEDrhB,KAAKqlB,QAAUmE,EAEfA,EAAE/D,cACH,CAEDE,QACE,MAAM8D,EAAuBzpB,KAAKqlB,QAClC,IAAIhE,EAEJ,IAAIliB,EAAasqB,GAAjB,CAIAA,EAAS9D,QACTtE,EAAUrhB,KAAKshB,aAEfthB,KAAKqlB,aAAUzhB,EAEf,IACE5D,KAAKof,QAAQyI,qBAAqB4B,EAGnC,CAFC,MAAO7Z,GAER,CAED,GAAIvD,MAAM+E,QAAQiQ,GAChB,IAAK,MAAMxD,KAAUwD,EACnBoI,EAASxD,QAAQpI,OAAQja,EAf5B,CAkBF,CAEDojB,aAAanJ,EAAgB6E,GAC3B,OAAO7E,CACR,CAEDoJ,eAAepJ,EAAgB6E,EAAoBoD,GAElD,CAEDoB,cAAcrJ,EAAgB6E,EAAoBoD,GAEjD,CAEDxE,aACE,OAAIniB,EAAaa,KAAKqlB,UAGlBrlB,KAAKqlB,QAAQiB,UAFR,GAKFtmB,KAAKqlB,QAAQmB,SAAS,GAC9B,CAEDkD,UAAU7L,GACR,IAAI1e,EAAaa,KAAKqlB,SAGtB,OAAOrlB,KAAKqlB,QAAQkB,oBAAoB1I,EACzC,CAED8L,OAAO9L,GACD1e,EAAaa,KAAKqlB,UAGtBrlB,KAAKqlB,QAAQY,QAAQpI,OAAQja,EAC9B,CAEDnC,OACE,OAAItC,EAAaa,KAAKqlB,SACb,EAEFrlB,KAAKqlB,QAAQ5jB,MACrB,CAEDilB,mBACE,OAAIvnB,EAAaa,KAAKqlB,UACZ,EAEHrlB,KAAKqlB,QAAQqB,kBACrB,CAEDJ,UACE,QAAInnB,EAAaa,KAAKqlB,UAGfrlB,KAAKqlB,QAAQiB,SACrB,CAEDa,mBACE,OAAOnnB,KAAKqpB,aACb,GEkFGtpB,cACEmS,MAAMoX,EAAMD,EACb,CAEDrC,aAAanJ,EAAgB6E,GAC3B,OAAOqE,EAAWC,aAAeD,EAAWC,aAAanJ,EAAQ6E,GAASxQ,MAAM8U,aAAanJ,EAAQ6E,EACtG,CAEDuE,eAAepJ,EAAgB6E,EAAoBoD,GACjDiB,EAAWE,eACPF,EAAWE,eAAepJ,EAAQ6E,EAAOoD,GACzC5T,MAAM+U,eAAepJ,EAAQ6E,EAAOoD,EACzC,CAEDoB,cAAcrJ,EAAgB6E,EAAoBoD,GAChDiB,EAAWG,cACPH,EAAWG,cAAcrJ,EAAQ6E,EAAOoD,GACxC5T,MAAMgV,cAAcrJ,EAAQ6E,EAAOoD,EACxC,GAKH,OAFA9lB,KAAK0nB,eAAennB,KAAKumB,GAElBA,CACR,CAED8C,aACEC,EACA9C,GAEA/mB,KAAK+kB,gBAEL,MAAMuE,EAAOtpB,KAEP8mB,EAAU,IAAK,oBD9OdC,WACU3H,QACAra,OACF+kB,eACAzB,WACThD,QACA0E,gBACAC,cAERjqB,YACEqf,EACAyK,EACA9C,GAEA/mB,KAAKof,QAAUA,EACfpf,KAAK+mB,WAAaA,GAAc/mB,KAChCA,KAAK8pB,eAC2B,iBAAvBD,EAAkC,gBAAmBA,KAAwBA,EAAmBjoB,WACzG5B,KAAKqoB,WAA2C,iBAAvBwB,EAAkCA,OAAqBjmB,EAChF5D,KAAK+E,OAC2B,iBAAvB8kB,EAAkCzK,EAAQ4I,aAAahoB,KAAK8pB,gBAAkBD,CACxF,CAEDN,OACE,IAAIC,EAEJ,GAAIlqB,EAAaU,KAAKqlB,SACpB,OAGFmE,EAAI,IAAIjC,EAAWvnB,MAEnBA,KAAKof,QAAQgJ,mBAAmBoB,EAAGxpB,KAAK8pB,gBAExC,IAAIG,EAAyC,GAG3CA,EADE3qB,EAAaU,KAAKqoB,YACProB,KAAKkqB,qBAAqBlqB,KAAKqoB,YAE/BroB,KAAKkqB,0BAAqBtmB,EAAW5D,KAAK8pB,gBAGzDN,EAAEhE,WAAWyE,GAEbjqB,KAAKqlB,QAAUmE,EAEfA,EAAE/D,cACH,CAEDE,QACE,MAAM8D,EAA0BzpB,KAAKqlB,QACrC,IAAI4E,EAEJ,IAAI9qB,EAAasqB,GAAjB,CAIAA,EAAS9D,QACTsE,EAAajqB,KAAKuoB,uBAElBvoB,KAAKqlB,aAAUzhB,EAEf,IACE5D,KAAKof,QAAQ2J,sBAAsBU,EAGpC,CAFC,MAAO7Z,GAER,CAID,GAFA5P,KAAK+lB,WAEDzmB,EAAa2qB,GACf,IAAK,MAAMhI,KAAagI,EACtBR,EAASxD,QAAQhE,OAAWre,EAjB/B,CAoBF,CAED2kB,uBACE,IAAIiB,EAAmBxpB,KAAKqlB,QAC5B,OAAIlmB,EAAaqqB,IAGbA,EAAElD,UAFG,GAOFkD,EAAEhD,SADgC,GAE1C,CAEDY,cAAcnF,GACZ,OAAOjiB,KAAKof,QAAQ0F,WAAc7C,EACnC,CAEDoF,gBAAgBpF,EAAgCgD,GAE/C,CAEDqC,eAAerF,EAAgCgD,GAC7C,IAEEjlB,KAAKof,QAAQ4F,aAAa/C,EACd,CAAZ,MAAOrS,GAAK,CACf,CAEDkV,aACE,IAAIG,EAAajlB,KAAKgqB,cACtB,GAAI1qB,EAAa2lB,GACf,OAAOA,EAET,IAAIhD,EAAiCjiB,KAAKkiB,sBAC1C,OAAI/iB,EAAa8iB,QAAjB,EAGQjiB,KAAKgqB,cAAgBhqB,KAAKmqB,uBAAuBlI,EAC1D,CAEDC,sBACE,MAAMD,EAAiCjiB,KAAK+pB,gBAC5C,GAAIzqB,EAAa2iB,GACf,OAAOA,EAET,MAAMgI,EAAyCjqB,KAAKuoB,uBAC9C/jB,EAASrF,EAAa8qB,GAAc,EAAIA,EAAWzlB,OACzD,GAAe,IAAXA,EACF,OAEF,IAAIkS,EAAQ,EACZ,GAAIlS,EAAS,EAAG,CACd,MAAM4lB,EAAqB,GAC3B,IAAIC,EAAQ,EACRC,EAAa/W,OAAOgX,UACxB,IAAK,IAAInqB,EAAI,EAAGA,EAAIoE,EAAQpE,IAAK,CAC/B,MAAMoqB,EAAWP,EAAW7pB,GAAGgiB,YrBIf,mBqBHVqI,EAAsC,iBAAbD,EAAwBjX,OAAOiX,GAAY,EAC1EJ,EAAShqB,GAAKqqB,EACVA,EAAUH,GACZ5T,EAAQtW,EACRkqB,EAAaG,EACbJ,EAAQ,GAEJI,IAAYH,GACdD,GAGL,CACD,GAAIA,EAAQ,EAAG,CACb,IAAIK,EAAQnX,OAAOoX,UACnB,IAAK,IAAIvqB,EAAI,EAAGA,EAAIoE,EAAQpE,IAC1B,GAAIgqB,EAAShqB,IAAMkqB,EAAY,CAC7B,MAAM/V,EAAahB,OAAO0W,EAAW7pB,GAAGgiB,YrBhCjC,eqBiCH7N,EAAKmW,IACPhU,EAAQtW,EACRsqB,EAAQnW,EAEX,CAEJ,CACF,CACD,OAAQvU,KAAK+pB,gBAAkBE,EAAWvT,EAC3C,CAEDyT,uBAAuBlI,GACrB,IAAIuH,EAAmBxpB,KAAKqlB,QAC5B,IAAIlmB,EAAaqqB,GAGjB,OAAOA,EAAEjD,oBAAoBtE,EAC9B,CAED2I,cAEE,GAAIzrB,EADmBa,KAAKqlB,SAE1B,MAAO,GAET,IAAI4E,EAAoCjqB,KAAKuoB,uBACzC/jB,EAASlF,EAAa2qB,GAAcA,EAAWzlB,OAAS,EAC5D,GAAe,IAAXA,EACF,MAAO,GAET,MAAMqmB,EAAe,GACrB,IAAK,IAAIzqB,EAAI,EAAGA,EAAIoE,EAAQpE,IAC1ByqB,EAAQzqB,GAAKJ,KAAKmqB,uBAAuBF,EAAW7pB,IAEtD,OAAOyqB,CACR,CAED9E,WACE/lB,KAAK+pB,qBAAkBnmB,EACvB5D,KAAKgqB,mBAAgBpmB,CACtB,CAED+lB,OAAO1H,GACL,IAAIuH,EAAmBxpB,KAAKqlB,QACxBlmB,EAAaqqB,IAGjBA,EAAEvD,QAAQhE,OAAWre,EACtB,CAEDnC,OACE,MAAM+nB,EAAmBxpB,KAAKqlB,QAC9B,OAAIlmB,EAAaqqB,GACR,EAGFA,EAAE/nB,MACV,CAEDilB,mBACE,MAAM8C,EAAmBxpB,KAAKqlB,QAE9B,OAAIlmB,EAAaqqB,IACP,EAGHA,EAAE9C,kBACV,CAEDJ,UACE,MAAMkD,EAAmBxpB,KAAKqlB,QAE9B,QAAIlmB,EAAaqqB,IAIVA,EAAElD,SACV,CAEO4D,qBAAqB7B,EAAqByC,GAChD,GAAI3rB,EAAakpB,IAAelpB,EAAa2rB,GAC3C,MAAM,IAAIjqB,MAAM,yEAElB,OAAOb,KAAKof,QAAQsJ,wBAAwBL,EAAYyC,EACzD,GCKG/qB,cACEmS,MAAMoX,EAAMO,EACb,CAEDzC,cAAcnF,GACZ,OAAO8E,EAAWK,cAAgBL,EAAWK,cAAcnF,GAAa/P,MAAMkV,cAAcnF,EAC7F,CAEDoF,gBAAgBpF,EAAgCgD,GAC9C8B,EAAWM,gBACPN,EAAWM,gBAAgBpF,EAAWgD,GACtC/S,MAAMmV,gBAAgBpF,EAAWgD,EACtC,CAEDqC,eAAerF,EAAgCgD,GAC7C8B,EAAWO,eACPP,EAAWO,eAAerF,EAAWgD,GACrC/S,MAAMoV,eAAerF,EAAWgD,EACrC,GAKH,OAFAjlB,KAAK2nB,gBAAgBpnB,KAAKumB,GAEnBA,CACR,CAEDiE,gBACE,IAAK,MAAMjE,KAAW9mB,KAAK0nB,eACzB,IACEZ,EAAQnB,OACI,CAAZ,MAAO/V,GAAK,CAGhB,IAAK,MAAMkX,KAAW9mB,KAAK2nB,gBACzB,IACEb,EAAQnB,OACI,CAAZ,MAAO/V,GAAK,CAGhB5P,KAAK0nB,eAAiB,GACtB1nB,KAAK2nB,gBAAkB,EACxB,CAEOlkB,+BAA+B6kB,GACrC,GAAInpB,EAAampB,GACf,OAGF,GAAoB,IAAhBA,EAAK9jB,OACP,OAAO8jB,EAAK,GAGd,IAAI0C,EAAiC1C,EAAK,GAC1C,IAAK,IAAIloB,EAAI,EAAGA,EAAIkoB,EAAK9jB,OAAQpE,IAC3B4qB,EAAQC,UAAU3C,EAAKloB,IAAM,IAC/B4qB,EAAU1C,EAAKloB,IAInB,OAAO4qB,CACR,QCzTUE,EAEQrN,OACAra,KACA2nB,OAHnBprB,YACmB8d,EACAra,EACA2nB,GAFAnrB,KAAM6d,OAANA,EACA7d,KAAIwD,KAAJA,EACAxD,KAAMmrB,OAANA,CACf,CAEJ/M,YACE,OAAOpe,KAAK6d,MACb,CAEDuN,YACE,OAAOprB,KAAKmrB,MACb,CAEDhJ,UACE,OAAOniB,KAAKwD,IACb,CAED5B,WACE,MAAO,GAAG5B,KAAK6d,OAAO4C,2CAA2CzgB,KAAKwD,OACvE,QCjBU6nB,EACMC,SACA/M,IACAgN,SACA9U,IAEjB1W,YAAYurB,EAA0B/M,EAAwBgN,EAA0B9U,GACtFzW,KAAKsrB,SAAWA,EAChBtrB,KAAKue,IAAMA,EACXve,KAAKurB,SAAWA,EAChBvrB,KAAKyW,IAAMA,CACZ,CAED1V,OAAOC,GACL,OAAI7B,EAAa6B,IAAYA,aAAiBqqB,IAGvCrrB,KAAKwrB,mBAAqBxqB,EAAMwqB,kBAAoBxrB,KAAKyrB,kBAAoBzqB,EAAMyqB,gBAC3F,CAEMC,cACL,OAAO1rB,KAAKsrB,QACb,CAEME,iBACL,OAAOxrB,KAAKue,GACb,CAEMoN,cACL,OAAO3rB,KAAKurB,QACb,CAEME,gBACL,OAAOzrB,KAAKyW,GACb,CAEM7U,WACL,OAAO5B,KAAKue,IAALve,QAA0BA,KAAKurB,SAAW,GAClD,QCxBUK,EACMlT,UAAiC,CAAA,EACjCmT,SACArsB,SACAssB,MAA2B,GAC3BC,aAAwC,GACxCC,aAAyC,GAClDC,YAAa,EAErBlsB,YACE2Y,EACAmT,EACArsB,EACAssB,EAA2B,IAE3B9rB,KAAK0Y,UAAYA,EACjB1Y,KAAK6rB,SAAWA,EAChB7rB,KAAKR,SAAWA,EAChBQ,KAAK8rB,MAAQ,IAAIA,GAEjB,MAAM1O,EAAoC,GAE1C,IAAK,MAAM8O,KAAMJ,EzB3BE,wByB4BbI,EAAGV,iBAAiBrqB,gBAAsCic,EAAQhB,SAAS8P,EAAGV,mBAChFpO,EAAQ7c,KAAK2rB,EAAGV,kBAIpB,IAAK,MAAMjN,KAAOve,KAAKR,SAAS8e,wBAAwB,MACtD,GzBnCoB,2ByBmChBC,EAAIpd,eAAsC,CAC5C,MAAMgrB,EAAqB5N,EAAIld,gBAAoC,WAC/D/B,EAAa6sB,IAA8B,YAAfA,GAC9B/O,EAAQ7c,KAAKge,EAEhB,CAGHve,KAAKgsB,aAAe,IAAI5O,GAExB,MAAMhE,EAAmC,GAEzC,IAAK,MAAM3C,KAAOzW,KAAKR,SAAS6e,wBAAwB,MACtD,GzBhDoB,2ByBgDhB5H,EAAItV,eAAsC,CAC5C,IAAIirB,EAAoB3V,EAAIpV,gBAAmC,WAC3DlC,EAAaitB,IzB+NC,YyB/NaA,IAC7BhT,EAAQ7Y,KAAKkW,EAEhB,CAGHzW,KAAK+rB,aAAe,IAAI3S,EACzB,CAEDiT,UACErsB,KAAKisB,YAAa,CACnB,CAED7N,YACE,OAAOpe,KAAKR,SAAS4e,WACtB,CAEDkO,YACE,MAAMzO,EAAS7d,KAAKoe,YACd2C,EACkB,gBAAtBlD,EAAOoC,WAA+B,KAAQpC,EAAsBsC,qBACtE,OAAO7gB,EAAayhB,IAAYA,EAAQvC,cAAgBxe,IACzD,CAEDusB,UACE,OAAQvsB,KAAKisB,UACd,CAEDO,wBAAwB/sB,GACtB,OAAOO,KAAKmb,gBAAgB1b,EAC7B,CAED0b,gBAAgB1b,GACd,GAAIO,KAAKusB,UAAW,CAClB,IAAInX,EAAkCpV,KAAK+rB,aAC3C,GAAIzsB,EAAaG,GAAY,CAC3B2V,EAAS,GACT,IAAK,MAAMqB,KAAOzW,KAAK+rB,aACjBtV,EAAItV,iBAAmB1B,GACzB2V,EAAO7U,KAAKkW,EAGjB,CACD,OAAOrB,CACR,CACD,MAAO,EACR,CAEDqX,iBAAiBhtB,GACf,MAAM,IAAIoB,MAAM,8BACjB,CAED6rB,iBAAiBjtB,GACf,GAAIO,KAAKusB,UAAW,CAClB,IAAInX,EAA4B,IAAIpV,KAAK8rB,OAIzC,OAHIxsB,EAAaG,KACf2V,EAASpV,KAAK8rB,MAAM/mB,QAAQmnB,GAAOA,EAAGV,iBAAiBrqB,iBAAmB1B,KAErE2V,CACR,CACD,MAAO,EACR,CAEDgG,gBAAgB3b,GACd,GAAIO,KAAKusB,UAAW,CAClB,IAAII,EAAuC3sB,KAAKgsB,aAC5C5W,EAAmCpV,KAAKgsB,aAE5C,GAAI1sB,EAAaG,GAAY,CAC3B2V,EAAS,GACT,IAAK,MAAMmJ,KAAOoO,EACZpO,EAAIpd,iBAAmB1B,GACzB2V,EAAO7U,KAAKge,EAGjB,CACD,OAAOnJ,CACR,CACD,MAAO,EACR,CAED9T,cACE,OAAOtB,KAAKR,QACb,CAEDotB,wBAAwBntB,GACtB,OAAOO,KAAKob,gBAAgB3b,EAC7B,CAED8B,cACE,OAAOvB,KAAKR,QACb,CAEDoC,WACE,OAAO5B,KAAKR,SAAS4e,YAAYxc,UAClC,QChJUirB,EACM7N,QACAM,UAAmC,GACnCwN,SACAtN,OAEjBzf,YAAYyf,EAAgBR,EAAkB8N,GAC5C9sB,KAAKwf,OAASA,EACdxf,KAAKgf,QAAUA,EACfhf,KAAK8sB,SAAWA,CACjB,CAED1M,iBAAiB5gB,GACf,GAAI,CAAC,UAAU4c,SAAS5c,EAAS4e,YAAY6B,YAC3C,OAGF,MAAM8M,EAAe/sB,KAAK2e,QAAQnf,GAClC,GAAIutB,EAAc,CAChB/sB,KAAKwf,OAAO0I,MACV,uCAAuC1oB,EAASqb,sBAAsBrb,EAASyB,aAAaW,cAG9F,MAAMic,EAASkP,EAAaxrB,cAAc6c,YAC1Cpe,KAAKgf,QAAQgE,gBAAgB,WAAYnF,GAEzC,UACQ7d,KAAKgf,QAAQqB,YAAYxC,SACzB7d,KAAKgtB,kBAGZ,CAFC,MAAOvI,GACPzkB,KAAKwf,OAAOiJ,MAAMhE,EACnB,CACF,MACCzkB,KAAKwf,OAAO0I,MACV,iCAAiC1oB,EAASqb,sBAAsBrb,EAASyB,aAAaW,aAG3F,CAEDwe,yBACE,MACM6M,EADiBjtB,KAAKsf,UAAUva,QAAQmoB,GAAM/tB,EAAa+tB,EAAE1O,eAChCzZ,QAAQmoB,IACzC,MAAMpB,EAAQe,EAAiBM,mBAAmBD,EAAGltB,KAAKotB,2BAC1D,M1BsC6B,qB0BtCtBF,EAAErS,mBAAoDgS,EAAiBQ,oBAAoBH,EAAGpB,EAAM,IAE7G,IAAK,MAAMwB,KAAOL,QACVjtB,KAAKutB,WAAWD,EAEzB,CAEDE,mBAAmB3P,GACjB,MAAMwD,EAAwB,GAExBoM,EAAUztB,KAAKsf,UAClBva,QAAQuoB,KAAUA,EAAI9O,cACtBre,KAAKmtB,GAAQA,EAAI9O,cACjBzZ,QAAQgZ,GAAWA,EAAOwO,YAC7B,IAAK,MAAMxO,KAAU0P,EAAS,CAC5B,MAAMC,EAAO3P,EACV2O,iBAAiB,MACjBiB,MAAMD,GAAqBA,EAAK/B,cAAc5qB,OAAO8c,EAAOsC,wBAC3DuN,GACFrM,EAAQ9gB,KAAKmtB,EAAKhC,cAActN,YAEnC,CACD,OAAOiD,CACR,CAMO+L,0BACN,MAAMtV,EAA2B,GAC3B8V,EAAoC5tB,KAAKsf,UAAUva,QAAQuoB,GAAuC,WAA/BA,EAAIlP,YAAY6B,aACzF,IAAK,MAAMqN,KAAOM,EAChB9V,EAAKvX,QAAQ+sB,EAAIjP,wBAAwB,OAE3C,OAAOvG,CACR,CAEO6G,QAAQ2O,GACd,MAAMvP,EAAS/d,KAAK6tB,wBAAwBP,GAG5C,OADAA,EAAI3O,QAAQZ,GACLA,CACR,CAEOta,2BAA2B6pB,EAAqBxB,GAEtD,IADmC,CAAC,YAAa,YAChC1P,SAASkR,EAAIlP,YAAY6B,YACxC,OAAO,EAET,MAAMrH,EAAe0U,EAAIhP,wBAAwB,MAC3CwP,EAAOlV,EAAazY,KAAK+sB,GAAMA,EAAE/rB,iBACjC4sB,EAAWjC,EAAM3rB,KAAK6tB,GAAMA,EAAEvC,gBAAgBtqB,iBAEpD,OAA+B,IAAxByX,EAAapU,QAAgBspB,EAAKvb,OAAO2a,GAAMa,EAAS3R,SAAS8Q,IACzE,CAEDzpB,0BAA0B6pB,EAAqBW,GAC7C,MAAMrV,EAAe0U,EAAIhP,wBAAwB,MAC3CwN,EAA2B,GACjC,IAAK,MAAMvN,KAAO3F,EAAc,CAC9B,MAAM7T,EAAUwZ,EAA8B/F,YACxC0V,EAAcD,EAAwBN,MACzC3iB,GAAMA,EAAE7J,iBAAmBod,EAAIpd,gBAAkB4U,EAAc1B,QAAQrJ,EAAGjG,KAE7E,GAAImpB,EAAa,CACf,MAAMR,EAAO,IAAIrC,EAAe9M,EAAIjd,cAAeid,EAAK2P,GAAa5sB,cAAe4sB,GACpFpC,EAAMvrB,KAAKmtB,EACZ,CACF,CACD,OAAO5B,CACR,CAED+B,wBAAwBruB,GACtB,MAAMssB,EAAQe,EAAiBM,mBAAmB3tB,EAAUQ,KAAKotB,2BAEjE,GAAIP,EAAiBQ,oBAAoB7tB,EAAUssB,GAAQ,CACzD,MAAMqC,EAAO3uB,EACb,OAAO,IAAIosB,EAAiBuC,EAAK1P,aAAcze,KAAMmuB,EAAMrC,EAC5D,CACF,CAEDpM,YAAY6B,GACVvhB,KAAKmhB,eAAeI,GACpBvhB,KAAKsf,UAAU/e,KAAKghB,EACrB,CAEDJ,eAAeI,GACb,MAAMtG,EAAMjb,KAAKsf,UAAU6G,WAAW+G,GAAMA,EAAEnsB,OAAOwgB,KACjDtG,EAAM,GACRjb,KAAKsf,UAAUtT,OAAOiP,EAAK,EAE9B,EClIG,MAAOmT,UAA6B7uB,EACvB8uB,IACAxQ,OAEjB9d,YAAYsuB,EAA8BxQ,GACxC3L,MAAM,KAAM,KAAM,CAAE,EAAE,CAAE,GACxBlS,KAAKquB,IAAMA,EACXruB,KAAK6d,OAASA,CACf,CAEDoN,UAAUjqB,GACR,MAAMuT,EAAahB,OAAOvT,KAAKoiB,Y3BuGhB,e2BtGTkM,EAAkB/a,OAAOvS,EAAMohB,Y3BsGtB,e2BpGf,GAAI7N,IAAO+Z,EACT,OAAO,EAGT,MAAMC,EAAkBhb,OAAOvT,KAAKoiB,Y3BmHhB,oB2BlHdoM,EAAuBjb,OAAOvS,EAAMohB,Y3BkHtB,oB2BhHdqM,EAAQF,G3BiFW,E2BhFnBG,EAAaF,G3BgFM,E2B9EzB,OAAIC,EAAOC,EAAY,GACb,EACCD,EAAOC,EAAY,EACrB,EAIFJ,EAAU/Z,CAClB,CAED0U,kBACE,OAAOjpB,KAAKquB,GACb,CAED9sB,cACE,MAAM,IAAIV,MAAM,qBACjB,CAEDM,eACE,MAAO,mBACR,CAEDE,gBACE,MAAO,EACR,CAEDD,gBACE,MAAO,IACFpB,KAAKipB,kBAAkB0F,gBAE7B,CAEDhtB,UACE,MAAO,EACR,CAEDyc,YACE,GAAIpe,KAAKquB,IAAInF,UACX,OAAOlpB,KAAK6d,MAEf,CAED8Q,gBACE,OAAO3uB,KAAKquB,IAAIM,eACjB,CAEDvM,YAAYpgB,GACV,OAAOhC,KAAKquB,IAAIjM,YAAYpgB,EAC7B,CAED4sB,kBACE,OAAO5uB,KAAKquB,IAAIO,iBACjB,CAEDC,kBACE,OAAO7uB,KAAKquB,IAAIQ,gBAAgB7uB,KACjC,CAED8uB,eAAejR,EAAgBkR,GAC7B,GAAIlR,IAAW7d,KAAK6d,OAClB,OAAO,EAGT,IAAImR,EACJ,MAAMC,EAAUb,EAAqBc,gBAAgBH,GAE/CI,EAAqBtR,EAAsBsC,qBAC3CiP,EAAgBhB,EAAqBiB,QAAQF,EAAmBF,GAChEK,EAAelB,EAAqBmB,qBAAqBJ,EAAmBF,GAE5EO,EAAoBxvB,KAAK6d,OAAsBsC,qBAC/CsP,EAAerB,EAAqBiB,QAAQG,EAAkBP,GAC9DS,EAActB,EAAqBmB,qBAAqBC,EAAkBP,GAoBhF,OAjBED,KADE7vB,EAAaiwB,KAAkBjwB,EAAaswB,MAErCtwB,EAAaiwB,IAAkB9vB,EAAamwB,IACjDnwB,EAAagwB,IACPE,EAAiBhR,YAAYjd,cAAcR,OAAOouB,GAIlC,MAAjBC,GAAyC,MAAhBK,GAC9BnwB,EAAaowB,IACPN,EAAczD,cAAc5qB,OAAOyuB,GAKrCC,EAAa9D,cAAc5qB,OAAOquB,EAAczD,gBAGnDqD,CACR,CAEDW,eAAeC,GACb,MAAMC,EAAe7vB,KAAKoiB,Y3B0DV,e2BzDhB,OAAO/V,MAAM+E,QAAQye,GAAgBA,EAAazT,SAASwT,GAAeC,IAAiBD,CAC5F,CAEOnsB,oBAAoBsrB,GAC1B,OAAI5vB,EAAa4vB,GACR,GAEFA,EAAUtgB,UAAUsgB,EAAU7T,YAlIR,KAkIwC6T,EAAUvqB,OAAS,EACzF,CAEOf,uBAAuBsrB,GAC7B,OAAI5vB,EAAa4vB,GACR,GAEFA,EAAUtgB,UAAU,EAAGsgB,EAAU7T,YAzIX,KA0I9B,CAEOzX,eAAe8d,EAAoB5gB,GACzC,GAAIrB,EAAaiiB,EAAG/C,aAAc,CAChC,MAAMsN,EAAQvK,EAAG/C,YAAYkO,iBAAiB,MAC9C,GAAIptB,EAAawsB,GACf,IAAK,MAAMkC,KAAKlC,EACd,G3BrJgB,2B2BsJdkC,EAAEvC,gBAAgBtqB,gBAClB6sB,EAAEvC,gBAAgBrqB,gB3BvJJ,4B2BuJ2CT,EAEzD,OAAOqtB,CAId,CAEF,CAEOvqB,4BAA4B8d,EAAoB5gB,GACtD,GAAIrB,EAAaiiB,EAAG/C,aAAc,CAChC,MAAM3F,EAAe0I,EAAG/C,YAAYrD,gBAAgB,MACpD,GAAI7b,EAAauZ,GACf,IAAK,MAAM/H,KAAK+H,EACd,G3BtKgB,2B2BsKZ/H,EAAE3P,gBAAwC2P,EAAE1P,gB3BtKhC,4B2BsKuET,EACrF,OAAOmQ,CAId,CAEF,QCxKUgf,EACMhD,SACAjP,OACAkS,QACAC,UACTC,OACAC,QACAC,QACStL,IACTuL,iBAAkB,EAE1BrwB,YACE+sB,EACAjP,EACAwS,EACAL,EACAC,EACAK,GAEAtwB,KAAK8sB,SAAWA,EAChB9sB,KAAK6d,OAASA,EACd7d,KAAK+vB,QAAUM,EACfrwB,KAAKgwB,UAAYA,EACjBhwB,KAAKiwB,OAASA,EACdjwB,KAAKkwB,QAAU5wB,EAAcU,KAAKiwB,OAA+BM,aAAevwB,KAAKiwB,YAASrsB,EAC9F5D,KAAKmwB,QAAUG,EAEftwB,KAAKwwB,qBAAqBF,GAE1BtwB,KAAK6kB,IAAM,IAAIuJ,EAAqBpuB,KAAM6d,EAC3C,CAEDqL,UACE,OAAO5pB,EAAaU,KAAKiwB,OAC1B,CAED9G,aACEnpB,KAAKiwB,OAAS,IACf,CAEDpB,gBAAgBhK,GACd,OAAO7kB,KAAK8sB,SAAS+B,gBAAgBhK,EACtC,CAEDC,WAAW2L,GACT,OAAIzwB,KAAKkwB,QACAlwB,KAAK0wB,oBAAoBD,GAE3BzwB,KAAKiwB,MACb,CAEDjL,aAAa2L,EAAmBV,GAC9B,GAAIjwB,KAAKkwB,QACP,IACElwB,KAAK4wB,sBAAsBD,EAAWV,EAKvC,CAJC,MAAOY,GACN7wB,KAAK8sB,SACHgE,YACArI,MAAM,oDAAqDoI,EAC/D,CAEJ,CAEDE,eACE,IAAK/wB,KAAKkpB,UACR,MAAM,IAAIroB,MAAM,8DAAgEmwB,KAAKC,UAAUjxB,KAAK+vB,UAEtG,OAAO/vB,KAAK6kB,GACb,CAEDqM,cAAcpI,GACZ,IAAInG,EACJ,IAAK3iB,KAAKkpB,UACR,MAAM,IAAIroB,MAAM,8DAAgEmwB,KAAKC,UAAUjxB,KAAK+vB,UAEtGpN,EAAW3iB,KAAKmwB,QAChBnwB,KAAKwwB,qBAAqB1H,GAC1B9oB,KAAK8sB,SAASqE,0BAA0BnxB,KAAM,IAAK2iB,GACpD,CAEDyO,aACE,IAAKpxB,KAAKkpB,WAAalpB,KAAKowB,gBAC1B,MAAM,IAAIvvB,MAAM,iCAElBb,KAAKowB,iBAAkB,EAEvBpwB,KAAK8sB,SAASuE,kBAAkBrxB,KAAK6d,OAAQ7d,MAC7CA,KAAKiwB,OAAS,KACdjwB,KAAKkwB,QAAU,IAChB,CAED9N,YAAYpgB,GACV,OAAOhC,KAAKmwB,QAAQnuB,EACrB,CAED2sB,gBACE,OAAO3uB,KAAKmwB,OACb,CAEDvB,kBACE,OAAO9sB,OAAOC,KAAK/B,KAAKmwB,SAAW,CAAE,EACtC,CAEOO,oBAAoB7S,GAC1B,OAAO7d,KAAKkwB,QAAQpL,WAAWjH,EAAQ7d,KACxC,CAEO4wB,sBAAsB/S,EAAgBoS,GAC5CjwB,KAAKkwB,QAAQlL,aAAanH,EAAQ7d,KAAMiwB,EACzC,CAEOO,qBAAqBF,GAC3B,MAAMgB,EAA6B,CAAA,EAC/BhyB,EAAagxB,IACfxuB,OAAOyvB,OAAOD,EAAO,IAAKhB,IAG5BgB,EAAiB,YAAItxB,KAAK+vB,QAC1BuB,E5BHe,c4BGKtxB,KAAKgwB,UACzBsB,E5BwBqB,oB4BxBKtxB,KAAK6d,OAAOiC,cAElC9f,KAAKkwB,QACPoB,E5BmCgB,iB4BnCoC,cAA7BtxB,KAAKkwB,QAAQK,Y5BiDlB,YALH,S4B1Cfe,E5BiCgB,iBAKE,Y4BnCpBtxB,KAAKmwB,QAAUmB,CAChB,QChJUE,EACM3M,IACTI,QACAoF,MAAQ,EACRoH,oBAAsB,EACbC,QAEjB3xB,YAAY8kB,EAA4B8M,GAAc,GACpD3xB,KAAK6kB,IAAMA,EACX7kB,KAAK0xB,QAAUC,CAChB,CAEDZ,eACE,OAAO/wB,KAAK6kB,GACb,CAED+M,WACE,OAAO5xB,KAAKqqB,KACb,CAEDwH,yBACE,OAAO7xB,KAAKyxB,mBACb,CAEDK,2BACE,OAAI9xB,KAAKqqB,MAAQ,EAAI,EACXrqB,KAAKqqB,MAAQ,GAEvBrqB,KAAKqqB,QACErqB,KAAKqqB,MACb,CAED0H,8CACE,OAAI/xB,KAAKyxB,qBAAuB,EACtBzxB,KAAKyxB,oBAAsB,GAErCzxB,KAAKyxB,sBACEzxB,KAAKyxB,oBACb,CAEDO,kBACE,QAAShyB,KAAKqqB,KACf,CAED4H,kBACE,QAASjyB,KAAKqqB,KACf,CAED6H,gCACE,QAASlyB,KAAKyxB,mBACf,CAED3M,aACE,OAAO9kB,KAAKilB,OACb,CAEDkN,WAAWlN,GACTjlB,KAAKilB,QAAUA,CAChB,CAED0M,cACE,OAAO3xB,KAAK0xB,OACb,QCxCUU,EACM5S,OACA6S,UACAC,QAAwD,IAAIrvB,IAI5DsvB,UAA2B,IAAIxc,EAAc,C9BsK5C,gB8BrKDyc,SAAsC,IAAIvvB,IACnDwvB,iBAAmB,EAE3B1yB,YAAYyf,EAAgB6S,GAC1BryB,KAAKwf,OAASA,EACdxf,KAAKqyB,UAAYA,CAClB,CAED1S,sBAAsB9B,GACpB,MAAM6U,EAAwC1yB,KAAKsyB,QAAQ/N,IAAI1G,GAC/D,GAAIve,EAAaozB,GAAO,CACtB,MAAMpK,EAAqC,GAC3C,IAAK,MAAM+F,KAAOqE,EAChB,IACEpK,EAAK/nB,KAAK8tB,EAAI0C,eAGf,CAFC,MAAOzX,GAER,CAEH,OAAOgP,CACR,CACD,MAAO,EACR,CAEDxD,WAAcjH,EAAgBgH,EAA0B8N,GAAmB,GACzE,MAAMhB,EAAcgB,G9BoIA,c8BpIoB9N,EAAIzC,Y9BsH1B,iB8BrHlB,IAAIwQ,EACA3C,EAEJ,MAAM5B,EAAOxJ,EAA6BoE,kBAE1C,IACE,GAAIoF,EAAInF,YAEN0J,EAAQ5yB,KAAK6yB,iBAAiBhV,EAAQgH,OAAKjhB,EAAW+tB,GAEtDiB,EAAMd,2BACN7B,EAAS2C,EAAM9N,aAEX3lB,EAAa8wB,KACfA,EAAS5B,EAAIvJ,WAAWjH,GACxB+U,EAAMT,WAAWlC,IAGf0C,GACFC,EAAMb,8CAGJzyB,EAAaszB,IAAUjB,GAAa,CACtC,MAAMmB,EAAgB9yB,KAAK6yB,iBAAiBhV,EAAQgH,EAAKoL,GACrD6C,GAAiBA,IAAkBF,IACrC5yB,KAAK+yB,gBAAgBlV,EAAQgH,EAAK+N,GAClCA,EAAQE,EACRF,EAAMd,2BACFa,GACFC,EAAMb,8CAGX,CAMJ,CAJS,QACH1D,EAAInF,YAAa/pB,EAAa8wB,IACjCjwB,KAAK+yB,gBAAgBlV,EAAQgH,EAAK+N,EAErC,CAED,OAAO3C,CACR,CAEDkB,0BAA0B9C,EAA+B1L,GACnDrjB,EAAaU,KAAKqyB,YACpBryB,KAAKqyB,UAAU/O,eAAe,IAAItB,EAAiB,WAAYqM,EAAI0C,gBAAiBpO,EAEvF,CAED4F,qBAAqBF,EAAqBtjB,GACxC,IAAIiuB,EAA0BjuB,EAC9B,GAAI5F,EAAakpB,IAAelpB,EAAa4F,GAC3CiuB,EAAkB,IAAI5vB,EAAO,KAAMD,EAAWU,UAAW,WACpD,GAAIvE,EAAa+oB,IAAelpB,EAAa4F,GAClDiuB,EAAkB,IAAI5vB,E9BqFR,c8BrF4BD,EAAW+D,GAAImhB,QACpD,GAAI/oB,EAAa+oB,IAAe/oB,EAAayF,GAAS,CAC3D,MAAMxB,EAAyB,GAC/BA,EAAQhD,KAAK,IAAI6C,E9BkFH,c8BlFuBD,EAAW+D,GAAImhB,IACpD9kB,EAAQhD,KAAKwE,GACbiuB,EAAkB,IAAI5vB,EAAO,KAAMD,EAAWsC,IAAK,KAAMlC,EAC1D,CAED,OAAO8I,MAAMoa,KAAKzmB,KAAKuyB,UAAUziB,MAAMkjB,GAAiB,GACzD,CAEDnE,gBAAgBhK,GACd,IAAIxD,EAAoB,GACxB,IAAK,MAAMxD,KAAU7d,KAAKwyB,SAASzwB,OAAQ,CACzC,MAAMkxB,EAASjzB,KAAKwyB,SAASjO,IAAI1G,GACjC,IAAK,MAAM+U,KAASK,EAC0B,IAAxCL,EAAM7B,eAAe9F,UAAUpG,IAAc+N,EAAMhB,WAAa,IAC9DzyB,EAAakiB,GACfA,EAAU,CAACxD,GAEXwD,EAAQ9gB,KAAKsd,GAIpB,CACD,OAAOwD,CACR,CAEDuH,gBACE/K,EACAwS,EACAJ,EACAK,GAEA,MAAMjC,EAAM,IAAIyB,EAAwB9vB,KAAM6d,EAAQwS,IAAcrwB,KAAKyyB,iBAAkBxC,EAAQK,GAE9FtwB,KAAKsyB,QAAQ5wB,IAAImc,IACpB7d,KAAKsyB,QAAQ9N,IAAI3G,EAAQ,IAG3B,MAAM6U,EAAO1yB,KAAKsyB,QAAQ/N,IAAI1G,GAU9B,OAPK6U,EAAK/E,MAAMT,GAAMA,EAAE6D,eAAe3O,Y9BtBxB,gB8BsBoDiM,EAAI0C,eAAe3O,Y9BtBvE,gB8ByBbpiB,KAAKwf,OAAO0T,KAAK,0CAA0C7E,EAAI0C,eAAe3O,Y9BzBjE,kB8BuBbsQ,EAAKnyB,KAAK8tB,GAIZruB,KAAKuyB,UAAU/b,cAAc6X,EAAI0C,gBAE1B1C,CACR,CAEDgD,kBAAqBxT,EAAgBwQ,GACnC,MAAMqE,EAAwC1yB,KAAKsyB,QAAQ/N,IAAI1G,GAC/D,GAAIve,EAAaozB,GAAO,CACtB,MAAMS,EAAST,EAAKvM,WAAW+G,GAAMA,IAAMmB,IACvC8E,GAAU,GACZT,EAAK1mB,OAAOmnB,EAAQ,EAEvB,CAEDnzB,KAAKuyB,UAAU1b,iBAAiBwX,EAAI0C,gBAEhCzxB,EAAaU,KAAKqyB,YACpBryB,KAAKqyB,UAAU/O,eAAe,IAAItB,EAAiB,gBAAiBqM,EAAI0C,gBAAiB,MAG3F,MAAMlM,EAAMwJ,EAAI0C,eAChB/wB,KAAKozB,mBAAmBvO,GAEvBwJ,EAAgClF,aAEjCnpB,KAAKozB,mBAAmBvO,GAExB,IAAK,MAAMhH,KAAU7d,KAAKwyB,SAASzwB,OACjC/B,KAAK+yB,gBAAgBlV,EAAQgH,EAEhC,CAEDG,aAAanH,EAAgBgH,EAA4BoL,GACvD,MAAM5B,EAAgCxJ,EAA6BoE,kBAEnE,IACE,MAAM2J,EAAQ5yB,KAAK6yB,iBAAiBhV,EAAQgH,EAAKoL,GAEjD,GAAI9wB,EAAayzB,GACf,OAAO,EAGT,GAAItzB,EAAa2wB,IACX2C,EAAMX,kBAAoB,EAC5B,OAAO,EAIX,MAAM5H,EAAQuI,EAAMX,kBACpB,IACE,GAAI5H,GAAS,EAAG,CACd,MAAMgJ,EAAMT,EAAM9N,aAElB,GAAIxlB,EAAa+zB,KACfT,EAAMT,WAAW,MACbS,EAAMhB,YAAc,GAAG,CAEzBgB,EAAMd,2BACN,IAEEzD,EAAIrJ,aAAanH,EAAQwV,EAI1B,CAHS,QAERT,EAAMX,iBACP,CACF,CAEJ,CAED,OAAOW,EAAMhB,YAAc,CAS5B,CARS,QACHvD,EAAInF,WACP0J,EAAMT,WAAW,QAGd9D,EAAInF,WAAcmB,GAAS,GAAK/qB,EAAa2wB,KAChDjwB,KAAK+yB,gBAAgBlV,EAAQgH,EAAK+N,EAErC,CAGF,CAFS,QAET,CACF,CASOG,gBAAgBlV,EAAgBgH,EAA4ByO,GAClE,MAAML,EAAuBjzB,KAAKwyB,SAASjO,IAAI1G,IAAW,GAC1D,IAAI0V,GAAe,EAEnB,MAAwB,IAAjBA,GAAuB,CAC5B,MAAMC,EAAWP,EAAO9M,WACrByM,GAAWzzB,EAAam0B,IAA+C,IAAxCV,EAAM7B,eAAe9F,UAAUpG,IAAeyO,IAAOV,IAGnFY,GAAY,EACdP,EAAOjnB,OAAOwnB,EAAU,GAExBD,GAAe,CAElB,CAEqB,IAAlBN,EAAOzuB,QACTxE,KAAKwyB,SAASzb,OAAO8G,EAExB,CAQDgV,iBACEhV,EACAgH,EACAoL,EACA0B,GAAc,GAEd,IAAIiB,EAAoB,KAExB,MAAMK,EAAuBjzB,KAAKwyB,SAASjO,IAAI1G,GAE/C,IAAoB,IAAhB8T,GAAyBryB,EAAa2zB,GACxC,IAAK,MAAML,KAASK,EAClB,GAC0C,IAAxCL,EAAM7B,eAAe9F,UAAUpG,KAC7B1lB,EAAa8wB,KAAY2C,EAAMjB,eAAkBiB,EAAM9N,eAAiBmL,GAE1E,OAAO2C,EAWb,GAFAA,EAAQ,IAAIpB,EAAe3M,EAAK8M,GAE5BxyB,EAAa8zB,GAAS,CACxB,MAAMQ,EAA0B,CAACb,GACjC5yB,KAAKwyB,SAAShO,IAAI3G,EAAQ4V,EAC3B,MACCR,EAAO1yB,KAAKqyB,GAEd,OAAOA,CACR,CAEDc,mBAAmB7V,GACjB,MAAM6U,EAAwC1yB,KAAKsyB,QAAQ/N,IAAI1G,GAG/D,GAFA7d,KAAKsyB,QAAQvb,OAAO8G,GAEhBve,EAAaozB,GACf,IAAK,MAAMrE,KAAOqE,EAChB,GAAKrE,EAAgCnF,UACnC,IACEmF,EAAI+C,YAGL,CAFC,MAAO9X,GAER,CAIR,CAEDqa,cAAc9V,GACZ,MAAMoV,EAAuBjzB,KAAKwyB,SAASjO,IAAI1G,GAC/C,IAAI1e,EAAa8zB,GAIjB,IAAK,MAAML,KAASK,EAElB,KAAOjzB,KAAKglB,aAAanH,EAAQ+U,EAAM7B,eAAgB6B,EAAMjB,cAAgBiB,EAAM9N,aAAe,QAIrG,CAEOsO,mBAAmBvO,GACzB,MAAM+O,EAAoB5zB,KAAK6uB,gBAAgBhK,GAC/C,IAAK,MAAMgP,KAAUD,EAAS,CAC5B,MAAMX,EAAuBjzB,KAAKwyB,SAASjO,IAAIsP,GAC/C,IAAK,MAAMjB,KAASK,EAC0B,IAAxCL,EAAM7B,eAAe9F,UAAUpG,IACjC7kB,KAAKglB,aAAa6O,EAAQhP,EAAK+N,EAAMjB,cAAgBiB,EAAM9N,aAAe,KAG/E,CACF,CAEDgM,YACE,OAAO9wB,KAAKwf,MACb,CAEDsU,YAAYjW,GACV,OAAO7d,KAAKwyB,SAASjO,IAAI1G,EAC1B,QC1WUkW,EAEQvwB,KACAqa,OACA4K,MAHnB1oB,YACmByD,EACAqa,EACA4K,GAFAzoB,KAAIwD,KAAJA,EACAxD,KAAM6d,OAANA,EACA7d,KAAKyoB,MAALA,CACf,CAEJrK,YACE,OAAOpe,KAAK6d,MACb,CAEDsE,UACE,OAAOniB,KAAKwD,IACb,CAEDwwB,WACE,OAAOh0B,KAAKyoB,KACb,CAED7mB,WACE,MAAO,GAAG5B,KAAK6d,OAAO4C,2CAA2CzgB,KAAKwD,OACvE,QCpBUywB,EACSzjB,MAApBzQ,YAAoByQ,EAAkBtR,EAASg1B,OAA3Bl0B,KAAKwQ,MAALA,CAAoC,CAExD0X,SAASnY,GACH/P,KAAKwQ,MAAQtR,EAASg1B,OAAS,GACjCC,QAAQjM,OAAM,IAAIkM,MAAOC,cAAe,aAActkB,EAEzD,CAED0Y,SAAS1Y,GACH/P,KAAKwQ,MAAQtR,EAASo1B,OAAS,GACjCH,QAAQ1L,OAAM,IAAI2L,MAAOC,cAAe,aAActkB,EAEzD,CAED8R,QAAQ9R,GACF/P,KAAKwQ,MAAQtR,EAASq1B,MAAQ,GAChCJ,QAAQtS,MAAK,IAAIuS,MAAOC,cAAe,YAAatkB,EAEvD,CAEDykB,OAAOzkB,GACD/P,KAAKwQ,MAAQtR,EAASu1B,KAAO,GAC/BN,QAAQK,KAAI,IAAIJ,MAAOC,cAAe,WAAYtkB,EAErD,CAED2kB,SAAS3kB,GACH/P,KAAKwQ,MAAQtR,EAASy1B,OAAS,GACjCR,QAAQO,OAAM,IAAIN,MAAOC,cAAe,aAActkB,EAEzD,CAEDmjB,QAAQnjB,GACF/P,KAAKwQ,MAAQtR,EAAS01B,MAAQ,GAChCT,QAAQjB,MAAK,IAAIkB,MAAOC,cAAe,YAAatkB,EAEvD,CAED8kB,YAAYrkB,GACVxQ,KAAKwQ,MAAQA,CACd,QCzCUskB,EACXC,MAAMjW,EAAwBkW,GAC5B,OAAOC,QAAQC,OAAO,kBAAkBF,kDACzC,QCHUG,EACXC,OAAOC,EAA2BxW,EAA0BC,GAC1D,OAAOmW,QAAQC,OAAO,mBAAmBG,mDAC1C,QCFUC,EACXzlB,MAAM9K,GACJ,OAAO3B,EAAOyM,MAAM9K,EACrB,QCJUwwB,EACXthB,MAAME,GACJ,OAAO,IAAI0B,EAAW1B,EACvB,ECyDG,MAAOqhB,UAAgB5W,EACV6W,QACAC,SACAhd,UAA8B,IAAIzV,IAClCoe,QAAoB,GACpBsU,eAAoC,GACpCC,WACA/J,SACAiB,SACT+I,OAAS,EAEjB91B,YAAY2Y,GACV,MAAMoG,EAAqCpG,ErCxElB,2BqCyEnB8G,EAAiBlgB,EAAaoZ,ErCvEhB,uBqCuE8CA,ErCvE9C,sBqCuE2E,IAAIub,EAC7FwB,EAA2Bn2B,EAAaoZ,ErCtEZ,6BqCuE9BA,ErCvE8B,4BqCwE9B,IAAIoc,EACFY,EAA2Bp2B,EAAaoZ,ErC1Eb,4BqC2E7BA,ErC3E6B,2BqC4E7B,IAAIyc,EA0BN,IAAEnW,EAzBJQ,EAAOqV,YAAYnc,ErC/EA,sBqC+E6BxZ,EAASu1B,KAEzDviB,MACEsN,EACA,EACA,CACE,sBrCO2B,mBqCN3B,iBAAkB,QAClB,cAAe,qBAEjB,GACAV,GAGF9e,KAAKy1B,QAAUA,EACfz1B,KAAK01B,SAAWA,EAChB5zB,OAAOC,KAAK2W,GAAWV,SAAS8d,IAC9B91B,KAAK0Y,UAAU8L,IAAIsR,EAAWpd,EAAUod,GAAW,IAEjDhX,GACF9e,KAAK0Y,UAAU8L,IrCpGQ,0BqCoGkB1F,GAE3C9e,KAAK21B,eAAiB31B,KAAK0Y,UAAU6L,IrC7FJ,oCqC6FyC,GAC1EvkB,KAAK8sB,SAAW,IAAIsF,EAClBpyB,KAAKwf,QACHR,EAKMhf,KAJN,UACEsjB,eAAeZ,EAAqBC,GAClC3D,EAAQyD,iBAAiBC,EAAOC,EACjC,KAGP3iB,KAAK6rB,SAAW,IAAIgB,EAAiB7sB,KAAKwf,OAAQxf,KAAMA,KAAK8sB,UAC7D9sB,KAAK41B,WAAa,IAAIvT,EAAgBriB,KAAKwf,QAC3C,MAAM8N,EAAM,IAAI7P,EAAmBzd,KAAM,IAAK,CAC5C,sBrCtB6B,mBqCuB7B,iBAAkB,QAClB,cAAe,sBAEjBA,KAAK0f,YAAY4N,EAClB,CAEDxN,cACE,OAAO,CACR,CAED7B,eACE,OAAOje,IACR,CAED6a,kBACE,OAAO7a,KAAKye,arC9EY,sBqC+EzB,CAEDxd,aACE,OAAO,IAAI4U,EAAW7V,KAAKye,arCrGR,kBqCsGpB,CAED2B,cACE,IAC0B,cAApBpgB,KAAKigB,kBACDjgB,KAAK+1B,OAEW,aAApB/1B,KAAKigB,aACPjgB,KAAK+f,mBAAmB6I,gBrCjCP,0BqCiCyC5oB,KAAKwf,QAC/Dxf,KAAK+f,mBAAmB6I,gBrCjCG,mCqCiCyC5oB,KAAKy1B,SACzEz1B,KAAK+f,mBAAmB6I,gBrCjCE,kCqCiCyC5oB,KAAK01B,UACxE11B,KAAK+f,mBAAmB6I,gBrCjCA,gCqCiCyC,IAAI0M,GACrEt1B,KAAK+f,mBAAmB6I,gBrCjCC,iCqCiCyC,IAAI2M,GACtEv1B,KAAKg2B,wBAAwBh2B,KAAM,UAItC,CAFC,MAAOykB,GACPzkB,KAAKwf,OAAOiJ,MAAMhE,EACnB,CAEDzkB,KAAKgjB,gBAAgB,UAAWhjB,MAChCA,KAAK8iB,mBAAmB,UAAW9iB,KACpC,CAEDogB,cAAcwC,GACZ,IACE,GAAwB,cAApB5iB,KAAKigB,WAA4B,CACnCjgB,KAAKggB,iBAAiB,IAAIwH,EAAkBxnB,KAAKwf,OAAQxf,KAAMA,OAC/DA,KAAKkgB,SAAS,YACd,IAAK,MAAM0B,KAAYgB,EACrB5iB,KAAK8nB,qBAAqB9nB,KAAM4hB,EAOnC,CAKF,CAJC,MAAO6C,SACDzkB,KAAKsgB,WAAWtgB,MAEtBA,KAAKkgB,SAAS,YACf,CACF,CAEDE,oBAAoB+K,EAAgBlD,GAClC,GAAwB,aAApBjoB,KAAKigB,YAAiD,gBAApBjgB,KAAKigB,WACzC,MAAM,IAAIpf,MAAM,oCAGlB,MAAMo1B,EACyB,iBAAtBhO,QACGjoB,KAAKy1B,QAAQV,MAAM9M,EAAmBjoB,KAAK4gB,qBACjDqH,EACN,IAAIpK,EACAqY,EAAmBl2B,KAAKm2B,gBAAgBF,GAE5C,IAAKC,EAAU,CACb,MAAM3hB,EAAKvU,KAAKo2B,YAEVvX,EAAgD,iBAAtBoJ,EAAiCA,EAAoB,GAcrF,OAbApK,EAAS,IAAIe,EACX5e,KAAKwf,OACLjL,EACA0hB,EACApX,EACA7e,KAAK4gB,oBACL5gB,KACAmrB,GAEFnrB,KAAKqhB,QAAQ9gB,KAAKsd,GAClB7d,KAAKgjB,gBAAgB,YAAanF,EAAQsN,GAC1CnrB,KAAKwf,OAAOqC,KAAK,qBAAqBoU,ErC1JhB,2BqC0JyDA,ErC7K9D,2BqC8KXj2B,KAAK6rB,SAAS0B,WAAW1P,EAAOsC,sBAC/BtC,CACR,CACC,IAGE,aAFM7d,KAAKwgB,aAAa0V,EAAwBD,EAAiB9K,SAC3DnrB,KAAK6rB,SAAS0B,WAAY2I,EAAwB/V,sBACjD+V,CAGR,CAFC,MAAOzR,GACPzkB,KAAKwf,OAAOiJ,MAAMhE,EACnB,CAEJ,CAEDrE,mBAAmBvC,EAAoBkB,EAAgCoM,GACrE,GAA0B,aAAtBtN,EAAOoC,YAAmD,aAAtBpC,EAAOoC,WAC7C,MAAM,IAAIpf,MACR,UAAYgd,EAAO4C,sBAAwB,gEAG/C,IAAI4V,EACJ,MAAMC,EAAwBzY,EAAOoC,WAEpB,WAAbqW,SACIt2B,KAAKsgB,WAAWzC,GAGxB,IACEA,EAAOgD,OAAO9B,EAIf,CAHC,MAAOzF,GACPtZ,KAAKwf,OAAOiJ,MAAM,+BAAgCnP,GAClD+c,EAAU/c,CACX,CAYD,OAVIna,EAAak3B,KACfr2B,KAAKg2B,wBAAwBnY,EAAQ,aACrC7d,KAAKgjB,gBAAgB,aAAcnF,EAAQsN,GAC3CnrB,KAAKgjB,gBAAgB,UAAWnF,EAAQsN,IAGzB,WAAbmL,SACIt2B,KAAKqgB,YAAYxC,GAGlBA,CACR,CAEDuC,kBAAkBvC,GAEhB,IAAIwY,EADJr2B,KAAKwf,OAAOqC,KAAK,oBAAoBhE,EAAOhD,sBAAsBgD,EAAO5c,gBAEzE,MAAMs1B,EAA6B,CAAC,aACpC,IAAKA,EAAYna,SAASyB,EAAOoC,YAC/B,MAAM,IAAIpf,MACR,gBAAgBgd,EAAO4C,uEAAwE8V,EAAYt0B,KACzG,UAKN4b,EAAOmC,iBAAiB,IAAIwH,EAAkBxnB,KAAKwf,OAAQ3B,EAAQ7d,OACnEA,KAAKg2B,wBAAwBnY,EAAQ,YAErC,IACE,MAAMre,EAAWqe,EAAOsC,sBACpB7gB,EAAaE,EAASgf,cAAgBxe,KAAK6rB,SAASgC,wBAAwBruB,WACxEQ,KAAKw2B,eAAe3Y,GAAQ,EAKrC,CAHC,MAAOvE,GACP+c,EAAU/c,EACVtZ,KAAKwf,OAAOiJ,MAAM,gCAAgC5K,EAAOhD,sBAAsBgD,EAAO5c,eAAgBqY,EACvG,CAED,GAA0B,WAAtBuE,EAAOoC,WACTjgB,KAAKgjB,gBAAgB,UAAWnF,GAChC7d,KAAKwf,OAAOqC,KAAK,mBAAmBhE,EAAOhD,sBAAsBgD,EAAO5c,sBAClEjB,KAAK6rB,SAASmB,wBAIpB,GAFAnP,EAAOqC,SAAS,aAChBlgB,KAAKgjB,gBAAgB,UAAWnF,GAC5BwY,EACF,MAAMA,CAGX,CAEDjW,qBAAqBvC,EAAoB4Y,GAEvC,GADAz2B,KAAKwf,OAAOqC,KAAK,sBAAsBhE,EAAOhD,sBAAsBgD,EAAO5c,gBACjD,WAAtB4c,EAAOoC,WACT,OAGF,IAAIoW,EAAiB,KACrB,IACE,MAAMlX,QAAkBnf,KAAK02B,sBAAsB7Y,GACnDA,EAAO8C,aAAaxB,EAGrB,CAFC,MAAOwX,GACPN,EAAUM,CACX,CAED,IAGE,GAFA32B,KAAKgjB,gBAAgB,WAAYnF,GAE7Bve,EAAa+2B,GACf,MAAMA,EAGJ/2B,EAAaue,EAAO6C,uBAChB7C,EAAO6C,eAAe/b,MAAMkZ,EAAOkC,oBAG3C/f,KAAKg2B,wBAAwBnY,EAAQ,UACjC4Y,GACFz2B,KAAKgjB,gBAAgB,UAAWnF,EAqBnC,CAnBC,MAAO8Y,GACP32B,KAAKwf,OAAOiJ,MAAMkO,GAClB32B,KAAKgjB,gBAAgB,WAAYnF,GAEjC7d,KAAKg2B,wBAAwBnY,EAAQ,aAErCA,EAAO8C,aAAa,MAEpB,MAAMiW,EAAyB/Y,EAAOkC,mBAUtC,MATA6W,EAAIzN,aACJyN,EAAI7L,gBACJlN,EAAOmC,iBAAiB,MAExBhgB,KAAK8sB,SAAS4G,mBAAmB7V,GACjC7d,KAAK8sB,SAAS6G,cAAc9V,GAC5B7d,KAAK41B,WAAWxR,gBAAgBwS,GAG1B,IAAI/1B,MAAM,mCAAqCgd,EAAS,KAAO8Y,EACtE,CACF,CAEDvW,iBAAiBvC,GACf,IACE,IAAI4K,EACAoO,GAAY,EAEhB,OAAQhZ,EAAOoC,YACb,IAAK,cACH,MAAM,IAAIpf,MAAM,sCAClB,IAAK,WACL,IAAK,WACH,MAAM,IAAIA,MAAM,sEAClB,IAAK,YACH,OACF,IAAK,SACHg2B,GAAY,EAQhB,GAJA72B,KAAKwf,OAAOqC,KAAK,oBAAoBhE,EAAO4C,4BAC5C5C,EAAOqC,SAAS,YAChBlgB,KAAKgjB,gBAAgB,WAAYnF,GAE7BgZ,GAAsC,IAAzBhZ,EAAOiC,cACtB,IAC6C,mBAAhCjC,EAAO6C,gBAAgBoW,YAC1BjZ,EAAO6C,eAAeoW,KAAKjZ,EAAOkC,mBAI3C,CAFC,MAAO0E,GACPgE,EAAQhE,CACT,CAGH,GAA6B,IAAzB5G,EAAOiC,cAAqB,CAC9BjC,EAAO8C,aAAa,MACpB,MAAMiW,EAAyB/Y,EAAOkC,mBACtC6W,EAAIzN,aACJyN,EAAI7L,gBACJlN,EAAOmC,iBAAiB,MAGxBhgB,KAAK8sB,SAAS4G,mBAAmB7V,GAGjC7d,KAAK8sB,SAAS6G,cAAc9V,GAG5B7d,KAAK41B,WAAWxR,gBAAgBwS,GAGhC/Y,EAAOsC,qBAAqBxB,aAAQ/a,GAEpCia,EAAOqC,SAAS,YACjB,CAED,GAAMuI,EACJ,MAAM,IAAI5nB,MAAM,kCAAoCgd,EAAS,KAAO4K,EAGvE,CADS,QACT,CAED,IAAK,MAAM6C,KAAYtrB,KAAK6rB,SAAS2B,mBAAmB3P,SAChD7d,KAAKsgB,WAAWgL,GAGxBtrB,KAAKwf,OAAOqC,KAAK,mBAAmBhE,EAAO4C,4BAC3CzgB,KAAKgjB,gBAAgB,UAAWnF,EACjC,CAEDO,UAAU7J,GACR,OAAOvU,KAAKqhB,QAAQsM,MAAM5hB,GAAMA,EAAE+T,gBAAkBvL,GACrD,CAED4hB,gBAAgBpX,GACd,OAAO/e,KAAKqhB,QAAQsM,MAAM5hB,GAAMA,EAAE8O,oBAAsBkE,ErC3WhC,wBqC4WzB,CAEDiE,gBAAgBxf,EAAuBqa,EAAgBsN,GACrDnrB,KAAK41B,WAAW5S,gBAAgB,IAAIkI,EAAgBrN,EAAQra,EAAM2nB,GAASnrB,KAC5E,CAED8iB,mBAAmBtf,EAA0Bqa,EAAgB4K,GAC3DzoB,KAAK41B,WAAW9S,mBAAmB,IAAIiR,EAAmBvwB,EAAMqa,EAAQ4K,GAAQzoB,KACjF,CAEDoiB,YAAYpgB,GACV,OAAOhC,KAAK0Y,UAAU6L,IAAIviB,EAC3B,CAEDsf,WAAWuC,GACT,MAAO,IAAI7jB,KAAKqhB,QACjB,CAEDuG,kBAAkB/J,EAAoBxK,GACpCrT,KAAK41B,WAAWhS,YAAY/F,EAAOkC,mBAAoB,SAAU1M,EAAG,KACrE,CAEDwU,qBAAqBhK,EAAoBxK,GACvCrT,KAAK41B,WAAW3R,eAAepG,EAAOkC,mBAAoB,SAAU1M,EACrE,CAED+U,mBAAmBvK,EAAoB+D,EAA2B7c,GAChE,MAAMgyB,EAAuB53B,EAAa4F,GAAU,KAAO3B,EAAOyM,MAAM9K,GAExE/E,KAAK41B,WAAWhS,YAAY/F,EAAOkC,mBAAoB,UAAW6B,EAAUmV,EAC7E,CAEDhO,sBAAsBlL,EAAoBxK,GACxCrT,KAAK41B,WAAW3R,eAAepG,EAAOkC,mBAAoB,UAAW1M,EACtE,CAEDyU,qBAAqBjK,EAAoBxK,GACvCrT,KAAK41B,WAAWhS,YAAY/F,EAAOkC,mBAAoB,YAAa1M,EAAG,KACxE,CAED0U,wBAAwBlK,EAAoBxK,GAC1CrT,KAAK41B,WAAW3R,eAAepG,EAAOkC,mBAAoB,YAAa1M,EACxE,CAED6K,YACE,OAAOle,KAAK0Y,SACb,CAEDse,oBACE,OAAOh3B,KAAK21B,cACb,CAEDlT,iBAAiBC,EAAqBC,GACpC3iB,KAAK41B,WAAWnT,iBAAiBC,EAAOC,EACzC,CAEDqT,wBAAwBnY,EAAoBwB,GAC1CxB,EAAOqC,SAASb,EACjB,CAED6B,cACE,OAAOlhB,KAAK6rB,QACb,CAEDzL,sBAAsBvC,GACpB7d,KAAKwf,OAAOqC,KAAK,wBAAwBhE,EAAO4C,4BAGhD,IAFqC,CAAC,YAAa,WAAY,SAAU,YAEtDrE,SAASyB,EAAOoC,YACjC,KAA0B,gBAAtBpC,EAAOoC,WACH,IAAIpf,MAAM,2CAEV,IAAIA,MACR,UAAUgd,EAAO4C,oFAAoF5C,EAAOoC,cAKlH,GAA0B,aAAtBpC,EAAOoC,YAAmD,aAAtBpC,EAAOoC,WAC7C,MAAM,IAAIpf,MACR,UAAYgd,EAAO4C,sBAAwB,oEAI/C,IAAIwW,EAAU,KAEd,GAA0B,WAAtBpZ,EAAOoC,WACT,UACQjgB,KAAKsgB,WAAWzC,EAKvB,CAJC,MAAO4G,GACPzkB,KAAKwf,OAAOiJ,MAAM,0BAA0B5K,EAAO4C,wBAAyBgE,GAC5EzkB,KAAK8iB,mBAAmB,QAASjF,EAAQ4G,GACzCwS,EAAUxS,CACX,CAGHzkB,KAAKgjB,gBAAgB,aAAcnF,GAC9BoZ,IACHpZ,EAAOqC,SAAS,eAChBlgB,KAAKgjB,gBAAgB,cAAenF,GACpC7d,KAAKwf,OAAOqC,KAAK,uBAAuBhE,EAAO4C,yBAElD,CAEDkI,4BACE9K,EACAkR,EACAmI,EACAC,GAAkB,GAElB,MAAM7O,EAAgCtoB,KAAKuoB,qBAAqB1K,EAAQkR,EAAWmI,EAAMC,GAEzF,OAAOh4B,EAAampB,GAAQ,GAAK,IAAIA,EACtC,CAEOC,qBACN1K,EACAkR,EACAmI,EACAC,GAAkB,GAElB,IAAIpyB,EAAoB,KACpBzF,EAAa43B,KACfnyB,EAAS3B,EAAOyM,MAAMqnB,IAGxB,MAAME,EAAUp3B,KAAK8sB,SAASvE,qBAAqBwG,EAAWhqB,GACxDsyB,EAA4C,GAElD,GAAIF,EACF,IAAK,MAAMtS,KAAOuS,EACZ5B,EAAQ8B,oBAAoBzZ,EAAQgH,IACtCwS,EAAiB92B,KAAKskB,GAK5B,OAAIwS,EAAiB7yB,OAAS,EACrB6yB,EAGF,EACR,CAEOjB,YACN,MAAMmB,EAAIv3B,KAAK61B,OAEf,OADA71B,KAAK61B,SACE0B,CACR,CAEOnX,4BAA4B+N,GAClC,IAAIhP,EAA6B,KAE7BqY,EADmCrJ,EAAK1P,arChhBvB,oBqCkhBrB,GAAItf,EAAaq4B,GACf,MAAM,IAAI32B,MAAM,uCACX,GAAmC,iBAAxB22B,EAahB,OAAOrJ,EAAKzN,eAbsC,CAElD,IAAI+W,EADJz3B,KAAKwf,OAAO0I,MAAM,sCAAsCsP,KAExD,IACEC,SACQz3B,KAAK01B,SAASN,OAAOoC,EAAqBx3B,KAAK0hB,cAAe1hB,KAAK4gB,sBACzE8W,OAGH,CAFC,MAAOpe,GACP,MAAM,IAAIzY,MAAM,cAAgB22B,EAAsB,KAAOle,EAC9D,CACD6F,EAC+B,mBAAtBsY,EAAoC,IAAIA,EAA0CA,CAC5F,CAID,OAAOtY,CACR,CAEO1b,2BAA2Bk0B,EAAmB9S,GACpD,IAAImK,GAAQ,EACZ,MAAMY,EAAiC/K,EAAIzC,YrC/Y3B,eqCiZhB,GAAI/V,MAAM+E,QAAQwe,GAChB,IAAK,IAAIgI,EAAW,EAAG5I,GAAS4I,EAAWhI,EAAYprB,OAAQozB,IACxD/S,EAAIiK,eAAe6I,EAAW/H,EAAYgI,MAC7C5I,GAAQ,QAIPnK,EAAIiK,eAAe6I,EAAW/H,KACjCZ,GAAQ,GAIZ,OAAOA,CACR,CAEDlK,WAAcjH,EAAgBgH,EAA0B8N,GACtD,IACE,OAAO3yB,KAAK8sB,SAAShI,WAAWjH,EAAQgH,EAAK8N,EAG9C,CAFC,MAAOrZ,GACPtZ,KAAK8iB,mBAAmB,QAASjF,EAAQvE,EAC1C,CAGF,CAED0L,aAAanH,EAAgBgH,EAA4BgT,GACvD,OAAO73B,KAAK8sB,SAAS9H,aAAanH,EAAQgH,EAAKgT,EAChD,CAEDjP,gBACExJ,EACAiJ,EACA4H,EACAK,GAEA,IAAIjC,EAAMruB,KAAK8sB,SAASlE,gBAAgBxJ,EAAQhB,YAAaiK,EAAY4H,EAAQK,GAIjF,OAFAtwB,KAAKyiB,iBAAiB,IAAIT,EAAiB,aAAcqM,EAAI0C,gBAAiB,CAAA,GAEvE1C,CACR,CAED3M,cACE,MrC/mB2B,eqCgnB5B,CAED9B,4BAA4B/B,GAC1B,GAA0B,gBAAtBA,EAAOoC,WACT,MAAM,IAAIpf,MAAM,8BAGlB,OAAOb,KAAK8sB,SAASnN,sBAAsB9B,EAC5C"}