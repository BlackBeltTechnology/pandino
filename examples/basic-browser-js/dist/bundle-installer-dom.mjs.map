{
  "version": 3,
  "file": "bundle-installer-dom.mjs",
  "sources": [
    "../../pandino-api/dist/esm/pandino-api.mjs",
    "../src/index.ts"
  ],
  "sourcesContent": [
    "/**\n * PANDINO\n */\nconst DEPLOYMENT_ROOT_PROP = 'pandino.deployment.root';\nconst LOG_LEVEL_PROP = 'pandino.log.level';\nconst LOG_LOGGER_PROP = 'pandino.log.logger';\nconst PANDINO_BUNDLE_IMPORTER_PROP = 'pandino.bundle.importer';\nconst PANDINO_MANIFEST_FETCHER_PROP = 'pandino.manifest.fetcher';\nconst BUNDLE_NAMESPACE = 'pandino.wiring.bundle';\nconst IDENTITY_NAMESPACE = 'pandino.identity';\nconst TYPE_BUNDLE = 'pandino.bundle';\nconst TYPE_FRAGMENT = 'pandino.fragment';\nconst SYSTEMBUNDLE_ACTIVATORS_PROP = 'pandino.systembundle.activators';\nconst PANDINO_VERSION_PROPERTY = 'pandino.version';\nconst PACKAGE_NAMESPACE = 'pandino.wiring.package';\nconst HOST_NAMESPACE = 'pandino.wiring.host';\n/**\n * Location identifier of the Pandino <i>system bundle </i>, which is defined to be &quot;System Bundle&quot;.\n */\nconst SYSTEM_BUNDLE_LOCATION = 'System Bundle';\n/**\n * Manifest header identifying the bundle's name.\n */\nconst BUNDLE_NAME = 'Bundle-Name';\n/**\n * Manifest header containing a brief description of the bundle's functionality.\n */\nconst BUNDLE_DESCRIPTION = 'Bundle-Description';\n/**\n * Manifest header identifying the bundle's vendor.\n */\nconst BUNDLE_VENDOR = 'Bundle-Vendor';\n/**\n * Manifest header identifying the bundle's version.\n *\n * (Required attribute)\n */\nconst BUNDLE_VERSION = 'Bundle-Version';\n/**\n * If the corresponding value is a path string, then the value <b>MUST</b> be a relative path calculated from the\n * {@link DEPLOYMENT_ROOT_PROP}'s value!\n *\n * (Required attribute)\n */\nconst BUNDLE_ACTIVATOR = 'Bundle-Activator';\n/**\n * Manifest header identifying the bundle's activation policy.\n *\n * (Not yet implemented)\n */\nconst BUNDLE_ACTIVATIONPOLICY = 'Bundle-ActivationPolicy';\n/**\n * Manifest header identifying the bundle's symbolic name.\n *\n * (Required attribute)\n */\nconst BUNDLE_SYMBOLICNAME = 'Bundle-SymbolicName';\n/**\n * Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in\n * which it is written by specifying a bundle manifest version.\n *\n * (Required attribute)\n */\nconst BUNDLE_MANIFESTVERSION = 'Bundle-ManifestVersion';\n/**\n * Manifest header identifying the bundle's copyright information.\n */\nconst BUNDLE_COPYRIGHT = 'Bundle-Copyright';\n/**\n * Manifest header identifying the symbolic names of other bundles required by the bundle.\n *\n * (Not yet implemented)\n */\nconst REQUIRE_BUNDLE = 'Require-Bundle';\n/**\n * Manifest header identifying the capabilities that the bundle offers to provide to other bundles.\n */\nconst PROVIDE_CAPABILITY = 'Provide-Capability';\n/**\n * Manifest header identifying the capabilities on which the bundle depends.\n */\nconst REQUIRE_CAPABILITY = 'Require-Capability';\n/**\n * Manifest header identifying the path to a LICENSE file (if any).\n */\nconst BUNDLE_LICENSE = 'Bundle-License';\n/**\n * Manifest header directive value identifying an optional resolution type. An optional resolution type indicates that\n * the import, require bundle or require capability is optional and the bundle may be resolved without the import,\n * require bundle or require capability being resolved. If the import, require bundle or require capability is not\n * resolved when the bundle is resolved, the import, require bundle or require capability may not be resolved until the\n * bundle is refreshed.\n *\n * (Not yet implemented)\n */\nconst RESOLUTION_OPTIONAL = 'optional';\nconst SYSTEM_BUNDLE_SYMBOLICNAME = '@pandino/pandino';\n/**\n * Bundle activation policy declaring the bundle must be activated when the first class load is made from the bundle.\n *\n * <p>\n * A bundle with the lazy activation policy that is started with the \"START_ACTIVATION_POLICY\" option will wait in the\n * \"STARTING\" state until the first class load from the bundle occurs. The bundle will then be activated before the\n * class is returned to the requester.\n *\n * (Not yet implemented)\n */\nconst ACTIVATION_LAZY = 'lazy';\n/**\n * Manifest header identifying the symbolic name of another bundle for which that the bundle is a fragment.\n *\n * (Not yet implemented)\n */\nconst FRAGMENT_HOST = 'Fragment-Host';\nconst FRAMEWORK_LOGGER = '@pandino/pandino/Logger';\nconst FRAMEWORK_MANIFEST_FETCHER = '@pandino/pandino/ManifestFetcher';\nconst FRAMEWORK_BUNDLE_IMPORTER = '@pandino/pandino/BundleImporter';\nconst FRAMEWORK_FILTER_PARSER = '@pandino/pandino/FilterParser';\nconst FRAMEWORK_SEMVER_FACTORY = '@pandino/pandino/SemVerFactory';\nconst FRAMEWORK_UUID = '@pandino/pandino/uuid';\nconst FRAMEWORK_VERSION = '@pandino/pandino/version';\nconst FRAMEWORK_VENDOR = '@pandino/pandino/vendor';\nconst SERVICE_DEFAULT_RANK = 0;\nconst SERVICE_EVENT_INTERFACE_KEY = '@pandino/pandino/service/ServiceEvent';\nconst SERVICE_LISTENER_INTERFACE_KEY = '@pandino/pandino/service/ServiceListener';\n/**\n * Service property identifying a service's registration number. The value of this property must be of type\n * {@code number}.\n *\n * <p>\n * The value of this property is assigned by the Framework when a service is registered. The Framework assigns a unique,\n * non-negative value that is larger than all previously assigned values since the Framework was started. These values\n * are NOT persistent across restarts of the Framework.\n */\nconst SERVICE_ID = 'service.id';\n/**\n * Service property identifying a service's ranking number.\n *\n * <p>\n * This property may be supplied in the {@code properties Record} object passed to the\n * {@code BundleContext.registerService} method. The value of this property must be of type {@code number}.\n *\n * <p>\n * The service ranking is used by the Framework to determine the <i>natural order</i> of services, see\n * {@link ServiceReference#compareTo(Object)}, and the <i>default</i> service to be returned from a call to the\n * {@link BundleContext#getServiceReference(Class)} or\n * {@link BundleContext#getServiceReference(String)} method.\n *\n * <p>\n * The default ranking is zero (0). A service with a ranking of {@code Number.MAX_VALUE} is very likely to be returned\n * as the default service, whereas a service with a ranking of {@code Number.MIN_VALUE} is very unlikely to be\n * returned.\n */\nconst SERVICE_RANKING = 'service.ranking';\n/**\n * Service property identifying the {@link Bundle#getBundleId() bundle id} of the {@link ServiceReference#getBundle()\n * bundle registering the service}.\n *\n * <p>\n * This property is set by the Framework when a service is registered. The value of this property must be of type\n * {@code number}.\n */\nconst SERVICE_BUNDLEID = 'service.bundleid';\n/**\n * Service property identifying a service's description.\n */\nconst SERVICE_DESCRIPTION = 'service.description';\n/**\n * Service property identifying a service's scope.\n *\n * <p>\n * This property is set by the Framework when a service is registered. If the registered object implements\n * {@link PrototypeServiceFactory}, then the value of this service property will be {@link #SCOPE_PROTOTYPE}. Otherwise,\n * if the registered object implements {@link ServiceFactory}, then the value of this service property will be\n * {@link #SCOPE_BUNDLE}. Otherwise, the value of this service property will be {@link #SCOPE_SINGLETON}.\n */\nconst SERVICE_SCOPE = 'service.scope';\nconst SERVICE_PID = 'service.pid';\n/**\n * Service scope is singleton. All bundles using the service receive the same service object.\n */\nconst SCOPE_SINGLETON = 'singleton';\n/**\n * Service scope is bundle. Each bundle using the service receives a customized service object.\n */\nconst SCOPE_BUNDLE = 'bundle';\n/**\n * Service scope is prototype. Each bundle using the service receives either a customized service object or can request\n * multiple customized service objects.\n */\nconst SCOPE_PROTOTYPE = 'prototype';\n/**\n * Service property identifying all of the class names under which a service was registered in the Framework. The value\n * of this property must be of type {@code string | string[]}.\n *\n * <p>\n * This property is set by the Framework when a service is registered.\n */\nconst OBJECTCLASS = 'objectClass';\n/**\n * Manifest header attribute identifying a range of versions for a bundle specified in the {@code Require-Bundle} or\n * {@code Fragment-Host} manifest headers. The default value is {@code 0.0.0}.\n */\nconst BUNDLE_VERSION_ATTRIBUTE = 'bundle-version';\n/**\n * Manifest header attribute identifying the version of a package specified in the Export-Package or Import-Package\n * manifest header.\n */\nconst VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute identifying the {@code SemVer} of the resource if one is specified or {@code 0.0.0} if not\n * specified. The value of this attribute must be of type {@code SemVer}.\n */\nconst CAPABILITY_VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute that contains a human readable copyright notice for the resource. See the\n * {@code Bundle-Copyright} manifest header.\n */\nconst CAPABILITY_COPYRIGHT_ATTRIBUTE = 'copyright';\n/**\n * The attribute value that contains tags for the resource. A tag is used to identify an aspect of the resource that is\n * not otherwise expressed by the capabilities of the resource. The value of this attribute must be of type\n * {@code Array<string>}.\n */\nconst CAPABILITY_TAGS_ATTRIBUTE = 'tags';\n/**\n * The capability attribute identifying the resource type. If the resource has no type then the value\n * {@link #TYPE_UNKNOWN unknown} must be used for the attribute.\n */\nconst CAPABILITY_TYPE_ATTRIBUTE = 'type';\n/**\n * The capability attribute that contains a human readable description for the resource. See the\n * {@code Bundle-Description} manifest header.\n */\nconst CAPABILITY_DESCRIPTION_ATTRIBUTE = 'description';\n/**\n * Manifest header directive identifying a list of packages that an exported package or provided capability uses.\n */\nconst USES_DIRECTIVE = 'uses';\n/**\n * Manifest header directive identifying names of matching attributes which must be specified by matching Import-Package\n * statements in the Export-Package manifest header.\n */\nconst MANDATORY_DIRECTIVE = 'mandatory';\n/**\n * Manifest header directive identifying the capability filter specified in the Require-Capability manifest header.\n */\nconst FILTER_DIRECTIVE = 'filter';\n/**\n * Manifest header directive identifying a list of classes to include in the exported package.\n *\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must be allowed to be exported.\n */\nconst INCLUDE_DIRECTIVE = 'include';\n/**\n * Manifest header directive identifying a list of classes to exclude in the exported package..\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must not be allowed to be exported.\n */\nconst EXCLUDE_DIRECTIVE = 'exclude';\n/**\n * Manifest header directive identifying the resolution type in the Import-Package, Require-Bundle or Require-Capability\n * manifest header. The default value is {@link #RESOLUTION_MANDATORY mandatory}.\n */\nconst RESOLUTION_DIRECTIVE = 'resolution';\n/**\n * Manifest header directive identifying whether a bundle is a singleton. The default value is {@code false}.\n */\nconst SINGLETON_DIRECTIVE = 'singleton';\n/**\n * The capability directive identifying if the resource is a singleton. A {@code string} value of &quot;true&quot;\n * indicates the resource is a singleton; any other value or {@code undefined} indicates the resource is not a\n * singleton.\n */\nconst CAPABILITY_SINGLETON_DIRECTIVE = 'singleton';\n/**\n * Manifest header directive identifying the effective time of the provided capability. The default value is\n * {@link #EFFECTIVE_RESOLVE resolve}.\n */\nconst EFFECTIVE_DIRECTIVE = 'effective';\n/**\n * Manifest header directive value identifying a capability that is effective at resolve time. Capabilities with an\n * effective time of resolve are the only capabilities which are processed by the resolver.\n */\nconst EFFECTIVE_RESOLVE = 'resolve';\n/**\n * The requirement directive used to specify a capability filter. This filter is used to match against a capability's\n * attributes.\n */\nconst REQUIREMENT_FILTER_DIRECTIVE = 'filter';\n/**\n * The requirement directive used to specify the cardinality for a requirement. The default value is {@link #CARDINALITY_SINGLE single}.\n */\nconst REQUIREMENT_CARDINALITY_DIRECTIVE = 'cardinality';\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"TRACE\"] = 5] = \"TRACE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    LogLevel[LogLevel[\"LOG\"] = 3] = \"LOG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\n\nexport { ACTIVATION_LAZY, BUNDLE_ACTIVATIONPOLICY, BUNDLE_ACTIVATOR, BUNDLE_COPYRIGHT, BUNDLE_DESCRIPTION, BUNDLE_LICENSE, BUNDLE_MANIFESTVERSION, BUNDLE_NAME, BUNDLE_NAMESPACE, BUNDLE_SYMBOLICNAME, BUNDLE_VENDOR, BUNDLE_VERSION, BUNDLE_VERSION_ATTRIBUTE, CAPABILITY_COPYRIGHT_ATTRIBUTE, CAPABILITY_DESCRIPTION_ATTRIBUTE, CAPABILITY_SINGLETON_DIRECTIVE, CAPABILITY_TAGS_ATTRIBUTE, CAPABILITY_TYPE_ATTRIBUTE, CAPABILITY_VERSION_ATTRIBUTE, DEPLOYMENT_ROOT_PROP, EFFECTIVE_DIRECTIVE, EFFECTIVE_RESOLVE, EXCLUDE_DIRECTIVE, FILTER_DIRECTIVE, FRAGMENT_HOST, FRAMEWORK_BUNDLE_IMPORTER, FRAMEWORK_FILTER_PARSER, FRAMEWORK_LOGGER, FRAMEWORK_MANIFEST_FETCHER, FRAMEWORK_SEMVER_FACTORY, FRAMEWORK_UUID, FRAMEWORK_VENDOR, FRAMEWORK_VERSION, HOST_NAMESPACE, IDENTITY_NAMESPACE, INCLUDE_DIRECTIVE, LOG_LEVEL_PROP, LOG_LOGGER_PROP, LogLevel, MANDATORY_DIRECTIVE, OBJECTCLASS, PACKAGE_NAMESPACE, PANDINO_BUNDLE_IMPORTER_PROP, PANDINO_MANIFEST_FETCHER_PROP, PANDINO_VERSION_PROPERTY, PROVIDE_CAPABILITY, REQUIREMENT_CARDINALITY_DIRECTIVE, REQUIREMENT_FILTER_DIRECTIVE, REQUIRE_BUNDLE, REQUIRE_CAPABILITY, RESOLUTION_DIRECTIVE, RESOLUTION_OPTIONAL, SCOPE_BUNDLE, SCOPE_PROTOTYPE, SCOPE_SINGLETON, SERVICE_BUNDLEID, SERVICE_DEFAULT_RANK, SERVICE_DESCRIPTION, SERVICE_EVENT_INTERFACE_KEY, SERVICE_ID, SERVICE_LISTENER_INTERFACE_KEY, SERVICE_PID, SERVICE_RANKING, SERVICE_SCOPE, SINGLETON_DIRECTIVE, SYSTEMBUNDLE_ACTIVATORS_PROP, SYSTEM_BUNDLE_LOCATION, SYSTEM_BUNDLE_SYMBOLICNAME, TYPE_BUNDLE, TYPE_FRAGMENT, USES_DIRECTIVE, VERSION_ATTRIBUTE };\n",
    "import {\n  BundleActivator,\n  BundleContext,\n  DEPLOYMENT_ROOT_PROP,\n  FRAMEWORK_MANIFEST_FETCHER,\n  ManifestFetcher,\n  ServiceReference,\n} from '@pandino/pandino-api';\n\nexport default class PandinoBundleInstallerDomActivator implements BundleActivator {\n  private context: BundleContext;\n  private observer: MutationObserver;\n  private fetcherReference: ServiceReference<ManifestFetcher>;\n  private fetcher: ManifestFetcher;\n  private installedManifestList: string[] = [];\n\n  async start(context: BundleContext): Promise<void> {\n    this.context = context;\n    this.fetcherReference = context.getServiceReference<ManifestFetcher>(FRAMEWORK_MANIFEST_FETCHER);\n    this.fetcher = context.getService<ManifestFetcher>(this.fetcherReference);\n    await this.registerDocumentDefinedManifests();\n  }\n\n  async stop(context: BundleContext): Promise<void> {\n    context.ungetService(this.fetcherReference);\n    this.observer.disconnect();\n  }\n\n  async registerDocumentDefinedManifests(): Promise<void> {\n    const documentDefinedManifest = document.querySelector('script[type=\"pandino-manifests\"]');\n    if (!documentDefinedManifest) {\n      throw new Error(`Cannot find manifests definition for selector: 'script[type=\"pandino-manifests\"]'!`);\n    }\n\n    const config = {\n      attributes: true,\n      childList: true,\n      characterData: true,\n    };\n\n    let locations: string[];\n\n    const callback = async () => {\n      if (documentDefinedManifest.hasAttribute('src')) {\n        locations = await this.fetcher.fetch(\n          this.context.getProperty(DEPLOYMENT_ROOT_PROP),\n          documentDefinedManifest.getAttribute('src'),\n        );\n      } else {\n        locations = documentDefinedManifest ? JSON.parse(documentDefinedManifest.textContent) : [];\n      }\n\n      const installList = locations.filter(\n        (manifestLocation) => !this.installedManifestList.includes(manifestLocation),\n      );\n      const uninstallList = this.installedManifestList.filter(\n        (manifestLocation) => !locations.includes(manifestLocation),\n      );\n\n      await Promise.all(uninstallList.map((manifestLocation) => this.uninstall(manifestLocation)));\n      await Promise.all(installList.map((manifestLocation) => this.install(manifestLocation)));\n\n      this.installedManifestList = [...locations];\n    };\n\n    await callback();\n\n    this.observer = new MutationObserver(callback);\n    this.observer.observe(documentDefinedManifest.childNodes[0], config);\n  }\n\n  async install(path: string): Promise<void> {\n    await this.context.installBundle(path);\n  }\n\n  async uninstall(path: string): Promise<void> {\n    const bundle = this.context.getBundles().find((bundle) => path === bundle.getLocation());\n    if (bundle) {\n      await bundle.uninstall();\n    }\n  }\n}\n"
  ],
  "names": [
    "LogLevel",
    "PandinoBundleInstallerDomActivator",
    "context",
    "observer",
    "fetcherReference",
    "fetcher",
    "installedManifestList",
    "async",
    "this",
    "getServiceReference",
    "getService",
    "registerDocumentDefinedManifests",
    "ungetService",
    "disconnect",
    "documentDefinedManifest",
    "document",
    "querySelector",
    "Error",
    "locations",
    "callback",
    "hasAttribute",
    "fetch",
    "getProperty",
    "getAttribute",
    "JSON",
    "parse",
    "textContent",
    "installList",
    "filter",
    "manifestLocation",
    "includes",
    "uninstallList",
    "Promise",
    "all",
    "map",
    "uninstall",
    "install",
    "MutationObserver",
    "observe",
    "childNodes",
    "attributes",
    "childList",
    "characterData",
    "path",
    "installBundle",
    "bundle",
    "getBundles",
    "find",
    "getLocation"
  ],
  "mappings": "AA0SA,IAAIA,GACJ,SAAWA,GACPA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAc,IAAI,GAAK,MAChCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,OACrC,CAPD,CAOGA,IAAaA,EAAW,CAAA,ICzSb,MAAOC,EACXC,QACAC,SACAC,iBACAC,QACAC,sBAAkC,GAE1CC,YAAYL,GACVM,KAAKN,QAAUA,EACfM,KAAKJ,iBAAmBF,EAAQO,oBDiGD,oCChG/BD,KAAKH,QAAUH,EAAQQ,WAA4BF,KAAKJ,wBAClDI,KAAKG,kCACZ,CAEDJ,WAAWL,GACTA,EAAQU,aAAaJ,KAAKJ,kBAC1BI,KAAKL,SAASU,YACf,CAEDN,yCACE,MAAMO,EAA0BC,SAASC,cAAc,oCACvD,IAAKF,EACH,MAAM,IAAIG,MAAM,wFASlB,IAAIC,EAEJ,MAAMC,EAAWZ,UAEbW,EADEJ,EAAwBM,aAAa,aACrBZ,KAAKH,QAAQgB,MAC7Bb,KAAKN,QAAQoB,YD1CM,2BC2CnBR,EAAwBS,aAAa,QAG3BT,EAA0BU,KAAKC,MAAMX,EAAwBY,aAAe,GAG1F,MAAMC,EAAcT,EAAUU,QAC3BC,IAAsBrB,KAAKF,sBAAsBwB,SAASD,KAEvDE,EAAgBvB,KAAKF,sBAAsBsB,QAC9CC,IAAsBX,EAAUY,SAASD,WAGtCG,QAAQC,IAAIF,EAAcG,KAAKL,GAAqBrB,KAAK2B,UAAUN,YACnEG,QAAQC,IAAIN,EAAYO,KAAKL,GAAqBrB,KAAK4B,QAAQP,MAErErB,KAAKF,sBAAwB,IAAIY,EAAU,QAGvCC,IAENX,KAAKL,SAAW,IAAIkC,iBAAiBlB,GACrCX,KAAKL,SAASmC,QAAQxB,EAAwByB,WAAW,GAlC1C,CACbC,YAAY,EACZC,WAAW,EACXC,eAAe,GAgClB,CAEDnC,cAAcoC,SACNnC,KAAKN,QAAQ0C,cAAcD,EAClC,CAEDpC,gBAAgBoC,GACd,MAAME,EAASrC,KAAKN,QAAQ4C,aAAaC,MAAMF,GAAWF,IAASE,EAAOG,gBACtEH,SACIA,EAAOV,WAEhB"
}
