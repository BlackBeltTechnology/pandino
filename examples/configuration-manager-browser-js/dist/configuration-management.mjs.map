{"version":3,"file":"configuration-management.mjs","sources":["../../../pandino-api/dist/esm/pandino-api.mjs","../../../configuration-management-api/dist/esm/configuration-management-api.mjs","../../../persistence-manager-api/dist/esm/persistence-manager-api.mjs","../../src/configuration-admin-impl.ts","../../src/helper/targeted-pid.ts","../../src/configuration-impl.ts","../../src/configuration-cache.ts","../../src/configuration-manager.ts","../../src/activator.ts"],"sourcesContent":["/**\n * PANDINO\n */\nconst DEPLOYMENT_ROOT_PROP = 'pandino.deployment.root';\nconst LOG_LEVEL_PROP = 'pandino.log.level';\nconst LOG_LOGGER_PROP = 'pandino.log.logger';\nconst PANDINO_BUNDLE_IMPORTER_PROP = 'pandino.bundle.importer';\nconst PANDINO_MANIFEST_FETCHER_PROP = 'pandino.manifest.fetcher';\nconst BUNDLE_NAMESPACE = 'pandino.wiring.bundle';\nconst IDENTITY_NAMESPACE = 'pandino.identity';\nconst TYPE_BUNDLE = 'pandino.bundle';\nconst TYPE_FRAGMENT = 'pandino.fragment';\nconst SYSTEMBUNDLE_ACTIVATORS_PROP = 'pandino.systembundle.activators';\nconst PANDINO_VERSION_PROPERTY = 'pandino.version';\nconst PACKAGE_NAMESPACE = 'pandino.wiring.package';\nconst HOST_NAMESPACE = 'pandino.wiring.host';\n/**\n * Location identifier of the Pandino <i>system bundle </i>, which is defined to be &quot;System Bundle&quot;.\n */\nconst SYSTEM_BUNDLE_LOCATION = 'System Bundle';\n/**\n * Manifest header identifying the bundle's name.\n */\nconst BUNDLE_NAME = 'Bundle-Name';\n/**\n * Manifest header containing a brief description of the bundle's functionality.\n */\nconst BUNDLE_DESCRIPTION = 'Bundle-Description';\n/**\n * Manifest header identifying the bundle's vendor.\n */\nconst BUNDLE_VENDOR = 'Bundle-Vendor';\n/**\n * Manifest header identifying the bundle's version.\n *\n * (Required attribute)\n */\nconst BUNDLE_VERSION = 'Bundle-Version';\n/**\n * If the corresponding value is a path string, then the value <b>MUST</b> be a relative path calculated from the\n * {@link DEPLOYMENT_ROOT_PROP}'s value!\n *\n * (Required attribute)\n */\nconst BUNDLE_ACTIVATOR = 'Bundle-Activator';\n/**\n * Manifest header identifying the bundle's activation policy.\n *\n * (Not yet implemented)\n */\nconst BUNDLE_ACTIVATIONPOLICY = 'Bundle-ActivationPolicy';\n/**\n * Manifest header identifying the bundle's symbolic name.\n *\n * (Required attribute)\n */\nconst BUNDLE_SYMBOLICNAME = 'Bundle-SymbolicName';\n/**\n * Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in\n * which it is written by specifying a bundle manifest version.\n *\n * (Required attribute)\n */\nconst BUNDLE_MANIFESTVERSION = 'Bundle-ManifestVersion';\n/**\n * Manifest header identifying the bundle's copyright information.\n */\nconst BUNDLE_COPYRIGHT = 'Bundle-Copyright';\n/**\n * Manifest header identifying the symbolic names of other bundles required by the bundle.\n *\n * (Not yet implemented)\n */\nconst REQUIRE_BUNDLE = 'Require-Bundle';\n/**\n * Manifest header identifying the capabilities that the bundle offers to provide to other bundles.\n */\nconst PROVIDE_CAPABILITY = 'Provide-Capability';\n/**\n * Manifest header identifying the capabilities on which the bundle depends.\n */\nconst REQUIRE_CAPABILITY = 'Require-Capability';\n/**\n * Manifest header identifying the path to a LICENSE file (if any).\n */\nconst BUNDLE_LICENSE = 'Bundle-License';\n/**\n * Manifest header directive value identifying an optional resolution type. An optional resolution type indicates that\n * the import, require bundle or require capability is optional and the bundle may be resolved without the import,\n * require bundle or require capability being resolved. If the import, require bundle or require capability is not\n * resolved when the bundle is resolved, the import, require bundle or require capability may not be resolved until the\n * bundle is refreshed.\n *\n * (Not yet implemented)\n */\nconst RESOLUTION_OPTIONAL = 'optional';\nconst SYSTEM_BUNDLE_SYMBOLICNAME = '@pandino/pandino';\n/**\n * Bundle activation policy declaring the bundle must be activated when the first class load is made from the bundle.\n *\n * <p>\n * A bundle with the lazy activation policy that is started with the \"START_ACTIVATION_POLICY\" option will wait in the\n * \"STARTING\" state until the first class load from the bundle occurs. The bundle will then be activated before the\n * class is returned to the requester.\n *\n * (Not yet implemented)\n */\nconst ACTIVATION_LAZY = 'lazy';\n/**\n * Manifest header identifying the symbolic name of another bundle for which that the bundle is a fragment.\n *\n * (Not yet implemented)\n */\nconst FRAGMENT_HOST = 'Fragment-Host';\nconst FRAMEWORK_LOGGER = '@pandino/pandino/Logger';\nconst FRAMEWORK_MANIFEST_FETCHER = '@pandino/pandino/ManifestFetcher';\nconst FRAMEWORK_BUNDLE_IMPORTER = '@pandino/pandino/BundleImporter';\nconst FRAMEWORK_FILTER_PARSER = '@pandino/pandino/FilterParser';\nconst FRAMEWORK_SEMVER_FACTORY = '@pandino/pandino/SemVerFactory';\nconst FRAMEWORK_UUID = '@pandino/pandino/uuid';\nconst FRAMEWORK_VERSION = '@pandino/pandino/version';\nconst FRAMEWORK_VENDOR = '@pandino/pandino/vendor';\nconst SERVICE_DEFAULT_RANK = 0;\nconst SERVICE_EVENT_INTERFACE_KEY = '@pandino/pandino/service/ServiceEvent';\nconst SERVICE_LISTENER_INTERFACE_KEY = '@pandino/pandino/service/ServiceListener';\n/**\n * Service property identifying a service's registration number. The value of this property must be of type\n * {@code number}.\n *\n * <p>\n * The value of this property is assigned by the Framework when a service is registered. The Framework assigns a unique,\n * non-negative value that is larger than all previously assigned values since the Framework was started. These values\n * are NOT persistent across restarts of the Framework.\n */\nconst SERVICE_ID = 'service.id';\n/**\n * Service property identifying a service's ranking number.\n *\n * <p>\n * This property may be supplied in the {@code properties Record} object passed to the\n * {@code BundleContext.registerService} method. The value of this property must be of type {@code number}.\n *\n * <p>\n * The service ranking is used by the Framework to determine the <i>natural order</i> of services, see\n * {@link ServiceReference#compareTo(Object)}, and the <i>default</i> service to be returned from a call to the\n * {@link BundleContext#getServiceReference(Class)} or\n * {@link BundleContext#getServiceReference(String)} method.\n *\n * <p>\n * The default ranking is zero (0). A service with a ranking of {@code Number.MAX_VALUE} is very likely to be returned\n * as the default service, whereas a service with a ranking of {@code Number.MIN_VALUE} is very unlikely to be\n * returned.\n */\nconst SERVICE_RANKING = 'service.ranking';\n/**\n * Service property identifying the {@link Bundle#getBundleId() bundle id} of the {@link ServiceReference#getBundle()\n * bundle registering the service}.\n *\n * <p>\n * This property is set by the Framework when a service is registered. The value of this property must be of type\n * {@code number}.\n */\nconst SERVICE_BUNDLEID = 'service.bundleid';\n/**\n * Service property identifying a service's description.\n */\nconst SERVICE_DESCRIPTION = 'service.description';\n/**\n * Service property identifying a service's scope.\n *\n * <p>\n * This property is set by the Framework when a service is registered. If the registered object implements\n * {@link PrototypeServiceFactory}, then the value of this service property will be {@link #SCOPE_PROTOTYPE}. Otherwise,\n * if the registered object implements {@link ServiceFactory}, then the value of this service property will be\n * {@link #SCOPE_BUNDLE}. Otherwise, the value of this service property will be {@link #SCOPE_SINGLETON}.\n */\nconst SERVICE_SCOPE = 'service.scope';\nconst SERVICE_PID = 'service.pid';\n/**\n * Service scope is singleton. All bundles using the service receive the same service object.\n */\nconst SCOPE_SINGLETON = 'singleton';\n/**\n * Service scope is bundle. Each bundle using the service receives a customized service object.\n */\nconst SCOPE_BUNDLE = 'bundle';\n/**\n * Service scope is prototype. Each bundle using the service receives either a customized service object or can request\n * multiple customized service objects.\n */\nconst SCOPE_PROTOTYPE = 'prototype';\n/**\n * Service property identifying all of the class names under which a service was registered in the Framework. The value\n * of this property must be of type {@code string | string[]}.\n *\n * <p>\n * This property is set by the Framework when a service is registered.\n */\nconst OBJECTCLASS = 'objectClass';\n/**\n * Manifest header attribute identifying a range of versions for a bundle specified in the {@code Require-Bundle} or\n * {@code Fragment-Host} manifest headers. The default value is {@code 0.0.0}.\n */\nconst BUNDLE_VERSION_ATTRIBUTE = 'bundle-version';\n/**\n * Manifest header attribute identifying the version of a package specified in the Export-Package or Import-Package\n * manifest header.\n */\nconst VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute identifying the {@code SemVer} of the resource if one is specified or {@code 0.0.0} if not\n * specified. The value of this attribute must be of type {@code SemVer}.\n */\nconst CAPABILITY_VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute that contains a human readable copyright notice for the resource. See the\n * {@code Bundle-Copyright} manifest header.\n */\nconst CAPABILITY_COPYRIGHT_ATTRIBUTE = 'copyright';\n/**\n * The attribute value that contains tags for the resource. A tag is used to identify an aspect of the resource that is\n * not otherwise expressed by the capabilities of the resource. The value of this attribute must be of type\n * {@code Array<string>}.\n */\nconst CAPABILITY_TAGS_ATTRIBUTE = 'tags';\n/**\n * The capability attribute identifying the resource type. If the resource has no type then the value\n * {@link #TYPE_UNKNOWN unknown} must be used for the attribute.\n */\nconst CAPABILITY_TYPE_ATTRIBUTE = 'type';\n/**\n * The capability attribute that contains a human readable description for the resource. See the\n * {@code Bundle-Description} manifest header.\n */\nconst CAPABILITY_DESCRIPTION_ATTRIBUTE = 'description';\n/**\n * Manifest header directive identifying a list of packages that an exported package or provided capability uses.\n */\nconst USES_DIRECTIVE = 'uses';\n/**\n * Manifest header directive identifying names of matching attributes which must be specified by matching Import-Package\n * statements in the Export-Package manifest header.\n */\nconst MANDATORY_DIRECTIVE = 'mandatory';\n/**\n * Manifest header directive identifying the capability filter specified in the Require-Capability manifest header.\n */\nconst FILTER_DIRECTIVE = 'filter';\n/**\n * Manifest header directive identifying a list of classes to include in the exported package.\n *\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must be allowed to be exported.\n */\nconst INCLUDE_DIRECTIVE = 'include';\n/**\n * Manifest header directive identifying a list of classes to exclude in the exported package..\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must not be allowed to be exported.\n */\nconst EXCLUDE_DIRECTIVE = 'exclude';\n/**\n * Manifest header directive identifying the resolution type in the Import-Package, Require-Bundle or Require-Capability\n * manifest header. The default value is {@link #RESOLUTION_MANDATORY mandatory}.\n */\nconst RESOLUTION_DIRECTIVE = 'resolution';\n/**\n * Manifest header directive identifying whether a bundle is a singleton. The default value is {@code false}.\n */\nconst SINGLETON_DIRECTIVE = 'singleton';\n/**\n * The capability directive identifying if the resource is a singleton. A {@code string} value of &quot;true&quot;\n * indicates the resource is a singleton; any other value or {@code undefined} indicates the resource is not a\n * singleton.\n */\nconst CAPABILITY_SINGLETON_DIRECTIVE = 'singleton';\n/**\n * Manifest header directive identifying the effective time of the provided capability. The default value is\n * {@link #EFFECTIVE_RESOLVE resolve}.\n */\nconst EFFECTIVE_DIRECTIVE = 'effective';\n/**\n * Manifest header directive value identifying a capability that is effective at resolve time. Capabilities with an\n * effective time of resolve are the only capabilities which are processed by the resolver.\n */\nconst EFFECTIVE_RESOLVE = 'resolve';\n/**\n * The requirement directive used to specify a capability filter. This filter is used to match against a capability's\n * attributes.\n */\nconst REQUIREMENT_FILTER_DIRECTIVE = 'filter';\n/**\n * The requirement directive used to specify the cardinality for a requirement. The default value is {@link #CARDINALITY_SINGLE single}.\n */\nconst REQUIREMENT_CARDINALITY_DIRECTIVE = 'cardinality';\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"TRACE\"] = 5] = \"TRACE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    LogLevel[LogLevel[\"LOG\"] = 3] = \"LOG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\n\nexport { ACTIVATION_LAZY, BUNDLE_ACTIVATIONPOLICY, BUNDLE_ACTIVATOR, BUNDLE_COPYRIGHT, BUNDLE_DESCRIPTION, BUNDLE_LICENSE, BUNDLE_MANIFESTVERSION, BUNDLE_NAME, BUNDLE_NAMESPACE, BUNDLE_SYMBOLICNAME, BUNDLE_VENDOR, BUNDLE_VERSION, BUNDLE_VERSION_ATTRIBUTE, CAPABILITY_COPYRIGHT_ATTRIBUTE, CAPABILITY_DESCRIPTION_ATTRIBUTE, CAPABILITY_SINGLETON_DIRECTIVE, CAPABILITY_TAGS_ATTRIBUTE, CAPABILITY_TYPE_ATTRIBUTE, CAPABILITY_VERSION_ATTRIBUTE, DEPLOYMENT_ROOT_PROP, EFFECTIVE_DIRECTIVE, EFFECTIVE_RESOLVE, EXCLUDE_DIRECTIVE, FILTER_DIRECTIVE, FRAGMENT_HOST, FRAMEWORK_BUNDLE_IMPORTER, FRAMEWORK_FILTER_PARSER, FRAMEWORK_LOGGER, FRAMEWORK_MANIFEST_FETCHER, FRAMEWORK_SEMVER_FACTORY, FRAMEWORK_UUID, FRAMEWORK_VENDOR, FRAMEWORK_VERSION, HOST_NAMESPACE, IDENTITY_NAMESPACE, INCLUDE_DIRECTIVE, LOG_LEVEL_PROP, LOG_LOGGER_PROP, LogLevel, MANDATORY_DIRECTIVE, OBJECTCLASS, PACKAGE_NAMESPACE, PANDINO_BUNDLE_IMPORTER_PROP, PANDINO_MANIFEST_FETCHER_PROP, PANDINO_VERSION_PROPERTY, PROVIDE_CAPABILITY, REQUIREMENT_CARDINALITY_DIRECTIVE, REQUIREMENT_FILTER_DIRECTIVE, REQUIRE_BUNDLE, REQUIRE_CAPABILITY, RESOLUTION_DIRECTIVE, RESOLUTION_OPTIONAL, SCOPE_BUNDLE, SCOPE_PROTOTYPE, SCOPE_SINGLETON, SERVICE_BUNDLEID, SERVICE_DEFAULT_RANK, SERVICE_DESCRIPTION, SERVICE_EVENT_INTERFACE_KEY, SERVICE_ID, SERVICE_LISTENER_INTERFACE_KEY, SERVICE_PID, SERVICE_RANKING, SERVICE_SCOPE, SINGLETON_DIRECTIVE, SYSTEMBUNDLE_ACTIVATORS_PROP, SYSTEM_BUNDLE_LOCATION, SYSTEM_BUNDLE_SYMBOLICNAME, TYPE_BUNDLE, TYPE_FRAGMENT, USES_DIRECTIVE, VERSION_ATTRIBUTE };\n","/**\n * Configuration property naming the location of the bundle that is associated with a Configuration object.\n *\n * This property can be searched for but must not appear in the configuration dictionary for security reason.\n *\n * The property's value is of type {@code string}.\n */\nconst SERVICE_BUNDLELOCATION = 'service.bundleLocation';\n/**\n * The name of the implementation capability for the Configuration Admin specification\n */\nconst CONFIGURATION_ADMIN_IMPLEMENTATION = 'pandino.cm';\n/**\n * The version of the implementation capability for the Configuration Admin specification\n */\nconst CONFIGURATION_ADMIN_SPECIFICATION_VERSION = '1.0.0';\nconst CONFIG_ADMIN_INTERFACE_KEY = '@pandino/configuration-management/ConfigurationAdmin';\nconst MANAGED_SERVICE_INTERFACE_KEY = '@pandino/configuration-management/ManagedService';\nconst CONFIGURATION_LISTENER_INTERFACE_KEY = '@pandino/configuration-management/ConfigurationListener';\nconst SERVICE_PID = 'service.pid';\n\nexport { CONFIGURATION_ADMIN_IMPLEMENTATION, CONFIGURATION_ADMIN_SPECIFICATION_VERSION, CONFIGURATION_LISTENER_INTERFACE_KEY, CONFIG_ADMIN_INTERFACE_KEY, MANAGED_SERVICE_INTERFACE_KEY, SERVICE_BUNDLELOCATION, SERVICE_PID };\n","/**\n * Service registration property to define a unique name for the persistence manager.\n */\nconst PROPERTY_NAME = 'name';\nconst INTERFACE_KEY = '@pandino/persistence-manager/PersistenceManager';\nconst SERVICE_DISCRIMINATOR_PROPERTY = 'type';\n\nexport { INTERFACE_KEY, PROPERTY_NAME, SERVICE_DISCRIMINATOR_PROPERTY };\n","import { Configuration, ConfigurationAdmin } from '@pandino/configuration-management-api';\nimport { Bundle, Logger } from '@pandino/pandino-api';\nimport { ConfigurationManager } from './configuration-manager';\n\nexport class ConfigurationAdminImpl implements ConfigurationAdmin {\n  private readonly bundle: Bundle;\n  private readonly logger: Logger;\n  private readonly configurationManager: ConfigurationManager;\n\n  constructor(configurationManager: ConfigurationManager, bundle: Bundle, logger: Logger) {\n    this.configurationManager = configurationManager;\n    this.bundle = bundle;\n    this.logger = logger;\n  }\n\n  getConfiguration(pid: string, location?: string): Configuration {\n    let config: Configuration = this.configurationManager.getConfiguration(pid);\n    if (!config) {\n      config = this.configurationManager.createConfiguration(pid, location);\n    }\n    return config;\n  }\n\n  listConfigurations(filter?: string): Configuration[] {\n    return this.configurationManager.listConfigurations(filter);\n  }\n}\n","import { SemVer, SemverFactory, ServiceReference } from '@pandino/pandino-api';\n\nimport { Activator } from '../activator';\n\nexport class TargetedPID {\n  private readonly rawPid: string;\n  private readonly servicePid: string;\n  private readonly symbolicName?: string;\n  private readonly version?: SemVer;\n  private readonly location?: string;\n  private readonly bindingLevel: number;\n\n  constructor(rawPid: string, semVerFactory: SemverFactory) {\n    this.rawPid = rawPid;\n\n    if (rawPid.indexOf('|') < 0) {\n      this.servicePid = rawPid;\n      this.bindingLevel = 0;\n    } else {\n      let start = 0;\n      let end = rawPid.indexOf('|');\n      this.servicePid = rawPid.substring(start, end);\n\n      start = end + 1;\n      end = rawPid.indexOf('|', start);\n      if (end >= 0) {\n        this.symbolicName = rawPid.substring(start, end);\n        start = end + 1;\n        end = rawPid.indexOf('|', start);\n        if (end >= 0) {\n          this.version = semVerFactory.build(rawPid.substring(start, end));\n          this.location = rawPid.substring(end + 1);\n          this.bindingLevel = 3;\n        } else {\n          this.version = semVerFactory.build(rawPid.substring(start));\n          this.bindingLevel = 2;\n        }\n      } else {\n        this.symbolicName = rawPid.substring(start);\n        this.bindingLevel = 1;\n      }\n    }\n  }\n\n  matchesTarget(reference: ServiceReference<any>): boolean {\n    let serviceBundle = reference.getBundle();\n    if (!serviceBundle) {\n      return false;\n    }\n\n    if (!this.symbolicName) {\n      return true;\n    }\n\n    if (this.symbolicName !== serviceBundle.getSymbolicName()) {\n      return false;\n    }\n\n    if (!this.version) {\n      return true;\n    }\n\n    if (serviceBundle.getVersion().compare(this.version) !== 0) {\n      return false;\n    }\n\n    return !this.location || this.location === Activator.getLocation(serviceBundle);\n  }\n\n  /**\n   * Gets the raw PID with which this instance has been created.\n   * <p>\n   * If an actual service PID contains pipe symbols that PID might be considered being targeted PID without it actually\n   * being one. This method provides access to the raw PID to allow for such services to be configured.\n   */\n  getRawPid(): string {\n    return this.rawPid;\n  }\n\n  /**\n   * Returns the service PID of this targeted PID which basically is the targeted PID without the targeting information.\n   */\n  getServicePid(): string {\n    return this.servicePid;\n  }\n\n  /**\n   * Returns <code>true</code> if this targeted PID binds stronger than the <code>other</code> {@link TargetedPID}.\n   * <p>\n   * This method assumes both targeted PIDs have already been checked for suitability for the bundle encoded in the\n   * targetting.\n   */\n  bindsStronger(other: TargetedPID): boolean {\n    return this.bindingLevel > other.bindingLevel;\n  }\n\n  equals(obj: any): boolean {\n    if (obj === null || obj === undefined) {\n      return false;\n    } else if (obj === this) {\n      return true;\n    }\n\n    if (obj instanceof TargetedPID) {\n      return this.rawPid === (obj as TargetedPID).rawPid;\n    }\n\n    return false;\n  }\n\n  toString(): string {\n    return this.rawPid;\n  }\n}\n","import { Configuration } from '@pandino/configuration-management-api';\nimport { SemverFactory, SERVICE_PID, ServiceProperties, ServiceReference } from '@pandino/pandino-api';\nimport { ConfigurationManager } from './configuration-manager';\nimport { TargetedPID } from './helper/targeted-pid';\n\nexport class ConfigurationImpl implements Configuration {\n  private readonly configurationManager: ConfigurationManager;\n  private readonly pid: TargetedPID;\n  private isDeleted = false;\n  private location?: string;\n  private properties?: ServiceProperties;\n\n  constructor(\n    configurationManager: ConfigurationManager,\n    pid: string,\n    semVerFactory: SemverFactory,\n    location?: string,\n    properties?: ServiceProperties,\n  ) {\n    this.configurationManager = configurationManager;\n    this.pid = new TargetedPID(pid, semVerFactory);\n    this.location = location;\n    if (properties) {\n      this.properties = {\n        ...properties,\n      };\n    }\n  }\n\n  delete(): void {\n    this.checkDeleted();\n    this.configurationManager.deleteConfiguration(this.pid.toString());\n    this.isDeleted = true;\n  }\n\n  equals(other: any): boolean {\n    if (other === undefined || other === null) {\n      return false;\n    }\n    if (other instanceof ConfigurationImpl) {\n      return this.pid.toString() === other.getPid();\n    }\n    return false;\n  }\n\n  getBundleLocation(): string {\n    this.checkDeleted();\n    return this.location;\n  }\n\n  getPid(): string {\n    this.checkDeleted();\n    return this.pid.toString();\n  }\n\n  getProcessedProperties(serviceReference: ServiceReference<any>): ServiceProperties | undefined {\n    return this.getProperties();\n  }\n\n  getProperties(): ServiceProperties | undefined {\n    this.checkDeleted();\n    return this.properties\n      ? {\n          ...this.properties,\n          [SERVICE_PID]: this.pid.toString(),\n        }\n      : undefined;\n  }\n\n  setBundleLocation(location?: string): void {\n    this.checkDeleted();\n    this.location = location;\n  }\n\n  update(properties?: ServiceProperties): void {\n    this.checkDeleted();\n    this.properties = properties;\n    this.configurationManager.updateConfiguration(this);\n  }\n\n  getServicePid(): string {\n    return this.pid.getServicePid();\n  }\n\n  getTargetedPid(): TargetedPID {\n    return this.pid;\n  }\n\n  private checkDeleted(): void {\n    if (this.isDeleted) {\n      throw new Error(`Configuration for PID: ${this.pid}already deleted!`);\n    }\n  }\n}\n","import { BundleContext, SemverFactory, SERVICE_PID, ServiceProperties } from '@pandino/pandino-api';\nimport { PersistenceManager } from '@pandino/persistence-manager-api';\nimport { ConfigurationImpl } from './configuration-impl';\nimport { ConfigurationManager } from './configuration-manager';\n\nexport class ConfigurationCache {\n  private readonly cache: Map<string, ConfigurationImpl> = new Map<string, ConfigurationImpl>();\n  private readonly persistenceManager: PersistenceManager;\n  private readonly cm: ConfigurationManager;\n  private readonly context: BundleContext;\n  private readonly semVerFactory: SemverFactory;\n\n  constructor(context: BundleContext, pm: PersistenceManager, cm: ConfigurationManager, semVerFactory: SemverFactory) {\n    this.context = context;\n    this.persistenceManager = pm;\n    this.cm = cm;\n    this.semVerFactory = semVerFactory;\n\n    this.persistenceManager.getProperties().forEach((props: ServiceProperties) => {\n      const configuration = new ConfigurationImpl(\n        this.cm,\n        props[SERVICE_PID],\n        this.semVerFactory,\n        this.context.getBundle().getLocation(),\n        props,\n      );\n      this.cache.set(props[SERVICE_PID], configuration);\n    });\n  }\n\n  has(pid: string): boolean {\n    if (this.cache.has(pid)) {\n      return true;\n    }\n    const stored = this.persistenceManager.load(pid);\n    if (stored) {\n      this.cache.set(\n        pid,\n        new ConfigurationImpl(this.cm, pid, this.semVerFactory, this.context.getBundle().getLocation(), stored),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  get(pid: string): ConfigurationImpl | undefined {\n    if (this.has(pid)) {\n      return this.cache.get(pid);\n    }\n\n    return undefined;\n  }\n\n  set(pid: string, configuration: ConfigurationImpl): void {\n    this.persistenceManager.store(pid, configuration.getProperties());\n    this.cache.set(pid, configuration);\n  }\n\n  values(): ConfigurationImpl[] {\n    return Array.from(this.cache.values());\n  }\n\n  delete(pid: string): void {\n    if (this.persistenceManager.exists(pid)) {\n      this.persistenceManager.delete(pid);\n    }\n    if (this.cache.has(pid)) {\n      this.cache.delete(pid);\n    }\n  }\n}\n","import {\n  BundleContext,\n  FilterParser,\n  Logger,\n  SemverFactory,\n  SERVICE_PID,\n  ServiceEvent,\n  ServiceEventType,\n  ServiceListener,\n  ServiceReference,\n} from '@pandino/pandino-api';\nimport {\n  ConfigurationEvent,\n  ConfigurationEventType,\n  ConfigurationListener,\n  MANAGED_SERVICE_INTERFACE_KEY,\n  ManagedService,\n} from '@pandino/configuration-management-api';\nimport { PersistenceManager } from '@pandino/persistence-manager-api';\nimport { ConfigurationImpl } from './configuration-impl';\nimport { TargetedPID } from './helper/targeted-pid';\nimport { ConfigurationCache } from './configuration-cache';\n\nexport class ConfigurationManager implements ServiceListener {\n  isSync: boolean = true;\n  private readonly context: BundleContext;\n  private readonly logger: Logger;\n  private readonly filterParser: FilterParser;\n  private readonly managedReferences: Map<string, Array<ServiceReference<ManagedService>>> = new Map<\n    string,\n    Array<ServiceReference<ManagedService>>\n  >();\n  private readonly eventListeners: Map<string, ConfigurationListener[]> = new Map<string, ConfigurationListener[]>();\n  private readonly configurationCache: ConfigurationCache;\n  private readonly semVerFactory: SemverFactory;\n\n  constructor(\n    context: BundleContext,\n    logger: Logger,\n    filterParser: FilterParser,\n    pm: PersistenceManager,\n    semVerFactory: SemverFactory,\n  ) {\n    this.context = context;\n    this.logger = logger;\n    this.filterParser = filterParser;\n    this.configurationCache = new ConfigurationCache(context, pm, this, this.semVerFactory);\n    this.semVerFactory = semVerFactory;\n  }\n\n  initReferencesAddedBeforeManagerActivation(): void {\n    const nonConfiguredReferences: ServiceReference<any>[] = [];\n    const freshReferences: ServiceReference<any>[] = [];\n    const references = this.context\n      .getServiceReferences(MANAGED_SERVICE_INTERFACE_KEY)\n      .filter((ref) => ref.getProperty(SERVICE_PID));\n    for (const config of this.configurationCache.values()) {\n      // multiple references can have the same pid\n      const configuredReferences = references.filter((ref) => ref.getProperty(SERVICE_PID) === config.getPid());\n      for (const reference of configuredReferences) {\n        const refPid = reference.getProperty(SERVICE_PID);\n        if (refPid && !this.managedReferences.has(refPid)) {\n          const targetedPid = new TargetedPID(refPid, this.semVerFactory);\n          const service: ManagedService = this.context.getService<ManagedService>(reference);\n          this.initManagedService(refPid, reference, config, targetedPid, service);\n        }\n        freshReferences.push(reference);\n      }\n    }\n\n    for (const origRef of references) {\n      if (!freshReferences.includes(origRef)) {\n        nonConfiguredReferences.push(origRef);\n      }\n    }\n\n    for (const ref of nonConfiguredReferences) {\n      const service = this.context.getService(ref);\n      if (service) {\n        const pid = ref.getProperty(SERVICE_PID);\n        this.logger.debug(`Updating non-configured Service for PID: ${pid}`);\n        service.updated(undefined);\n        if (!this.managedReferences.has(pid)) {\n          this.managedReferences.set(pid, []);\n        }\n        const refs = this.managedReferences.get(pid);\n        if (!refs.includes(ref)) {\n          refs.push(ref);\n        }\n      }\n    }\n  }\n\n  serviceChanged(event: ServiceEvent): void {\n    const reference = event.getServiceReference();\n    const refPid = reference.getProperty(SERVICE_PID);\n    const service = this.context.getService(reference);\n    if (service) {\n      if (refPid && typeof (service as ManagedService).updated === 'function') {\n        const config = this.configurationCache.has(refPid)\n          ? this.configurationCache.get(refPid)\n          : this.internalCreateConfiguration(refPid, reference.getBundle().getLocation());\n        this.handleManagedServiceEvent(event.getType(), refPid, reference, service, config);\n      } else if (typeof (service as ConfigurationListener).configurationEvent === 'function') {\n        const configurationListener: ConfigurationListener = service;\n        this.handleConfigurationEventListenerEvent(event.getType(), refPid, configurationListener);\n      }\n    }\n  }\n\n  private handleManagedServiceEvent(\n    eventType: ServiceEventType,\n    pid: string,\n    reference: ServiceReference<any>,\n    managedService: ManagedService,\n    config: ConfigurationImpl,\n  ): void {\n    const targetedPid = new TargetedPID(pid, this.semVerFactory);\n    if (eventType === 'REGISTERED') {\n      this.initManagedService(pid, reference, config, targetedPid, managedService);\n    } else if (eventType === 'UNREGISTERING') {\n      if (!this.managedReferences.has(pid)) {\n        this.managedReferences.set(pid, []);\n      }\n      const idx = this.managedReferences.get(pid).findIndex((ref) => ref === reference);\n      if (idx > -1) {\n        this.managedReferences.get(pid).splice(idx, 1);\n      }\n      if (targetedPid.matchesTarget(reference)) {\n        managedService.updated(undefined);\n        this.fireConfigurationChangeEvent('DELETED', pid, reference);\n      }\n    }\n  }\n\n  private initManagedService(\n    pid: string,\n    reference: ServiceReference<any>,\n    config: ConfigurationImpl,\n    targetedPid: TargetedPID,\n    managedService: ManagedService,\n  ) {\n    if (!this.managedReferences.has(pid)) {\n      this.managedReferences.set(pid, []);\n    }\n    if (!this.managedReferences.get(pid).includes(reference)) {\n      this.managedReferences.get(pid).push(reference);\n    }\n\n    // As per specification if config is missing, we need to assign the first registered Service's Bundle location.\n    if (!config.getBundleLocation()) {\n      config.setBundleLocation(reference.getBundle().getLocation());\n    }\n\n    if (targetedPid.matchesTarget(reference)) {\n      managedService.updated(config?.getProperties());\n      this.fireConfigurationChangeEvent('UPDATED', pid, reference);\n    }\n  }\n\n  private handleConfigurationEventListenerEvent(\n    eventType: ServiceEventType,\n    refPid: string,\n    configurationListener: ConfigurationListener,\n  ): void {\n    if (eventType === 'REGISTERED') {\n      if (!this.eventListeners.has(refPid)) {\n        this.eventListeners.set(refPid, []);\n      }\n      const listeners = this.eventListeners.get(refPid);\n      if (!listeners.includes(configurationListener)) {\n        listeners.push(configurationListener);\n      }\n    } else if (eventType === 'UNREGISTERING') {\n      if (this.eventListeners.has(refPid)) {\n        const listeners = this.eventListeners.get(refPid);\n        const listenerIdx = listeners.findIndex((l) => l === configurationListener);\n        if (listenerIdx > -1) {\n          listeners.splice(listenerIdx, 1);\n        }\n      }\n    }\n  }\n\n  getConfiguration(pid: string): ConfigurationImpl | undefined {\n    let config = this.configurationCache.get(pid);\n    if (config) {\n      this.logger.debug(`Found configuration ${pid} bound to ${config.getBundleLocation()}`);\n\n      return config;\n    }\n  }\n\n  createConfiguration(pid: string, location?: string): ConfigurationImpl {\n    let effectiveLocation = location;\n    let config = this.getConfiguration(pid);\n    if (config) {\n      return config;\n    }\n\n    const refs = this.managedReferences.get(pid);\n\n    if (refs && refs.length) {\n      effectiveLocation = refs[0].getBundle().getLocation();\n    }\n\n    return this.internalCreateConfiguration(pid, effectiveLocation);\n  }\n\n  listConfigurations(filterString?: string): ConfigurationImpl[] {\n    if (filterString) {\n      const filter = this.filterParser.parse(filterString);\n      this.logger.debug(`Listing configurations matching ${filterString}`);\n\n      return Array.from(this.configurationCache.values()).filter((config) => filter.match(config.getProperties()));\n    }\n\n    return [...this.configurationCache.values()];\n  }\n\n  deleteConfiguration(pid: string): void {\n    if (this.configurationCache.has(pid)) {\n      this.configurationCache.delete(pid);\n      if (this.managedReferences.has(pid)) {\n        const refs = this.managedReferences.get(pid);\n        for (const ref of refs) {\n          const service = this.context.getService(ref);\n          if (service) {\n            service.updated(undefined);\n          }\n          this.fireConfigurationChangeEvent('DELETED', pid, ref);\n        }\n      }\n    }\n    this.logger.debug(`Attempted to delete already removed configuration for pid: ${pid}, ignoring.`);\n  }\n\n  updateConfiguration(config: ConfigurationImpl): void {\n    this.configurationCache.set(config.getPid(), config);\n    if (this.managedReferences.has(config.getServicePid())) {\n      const refs = this.managedReferences.get(config.getServicePid());\n      for (const ref of refs) {\n        if (config.getTargetedPid().matchesTarget(ref)) {\n          const service = this.context.getService(ref);\n          if (service) {\n            service.updated({\n              ...config.getProperties(),\n            });\n            this.fireConfigurationChangeEvent('UPDATED', config.getPid(), ref);\n          }\n        }\n      }\n    }\n  }\n\n  private internalCreateConfiguration(pid: string, bundleLocation?: string): ConfigurationImpl {\n    this.logger.debug(`createConfiguration(${pid}, ${bundleLocation})`);\n    return new ConfigurationImpl(this, pid, this.semVerFactory, bundleLocation);\n  }\n\n  // private storeConfiguration(configuration: ConfigurationImpl): ConfigurationImpl {\n  //   const pid = configuration.getPid();\n  //   const existing = this.configurationCache.get(pid);\n  //   if (existing) {\n  //     return existing as ConfigurationImpl;\n  //   }\n  //\n  //   this.configurationCache.set(pid, configuration);\n  //   return configuration;\n  // }\n\n  private fireConfigurationChangeEvent(type: ConfigurationEventType, pid: string, ref: ServiceReference<any>): void {\n    const event: ConfigurationEvent = {\n      getPid(): string {\n        return pid;\n      },\n      getReference(): ServiceReference<any> {\n        return ref;\n      },\n      getType(): ConfigurationEventType {\n        return type;\n      },\n    };\n    const listeners = this.eventListeners.get(pid) || [];\n    for (const listener of listeners) {\n      listener.configurationEvent(event);\n    }\n  }\n}\n","import {\n  Bundle,\n  BundleActivator,\n  BundleContext,\n  FilterParser,\n  FRAMEWORK_FILTER_PARSER,\n  FRAMEWORK_LOGGER,\n  FRAMEWORK_SEMVER_FACTORY,\n  Logger,\n  OBJECTCLASS,\n  SemverFactory,\n  ServiceEvent,\n  ServiceListener,\n  ServiceReference,\n  ServiceRegistration,\n} from '@pandino/pandino-api';\nimport { ConfigurationAdmin, CONFIG_ADMIN_INTERFACE_KEY } from '@pandino/configuration-management-api';\nimport { INTERFACE_KEY, PersistenceManager } from '@pandino/persistence-manager-api';\nimport { ConfigurationAdminImpl } from './configuration-admin-impl';\nimport { ConfigurationManager } from './configuration-manager';\n\n/* istanbul ignore file */\nexport class Activator implements BundleActivator {\n  private context: BundleContext;\n  private loggerReference: ServiceReference<Logger>;\n  private logger: Logger;\n  private configManager: ConfigurationManager;\n  private configAdmin: ConfigurationAdmin;\n  private configAdminRegistration: ServiceRegistration<ConfigurationAdmin>;\n  private filterParser: FilterParser;\n  private filterParserReference: ServiceReference<FilterParser>;\n  private persistenceManagerReference?: ServiceReference<PersistenceManager>;\n  private persistenceManager: PersistenceManager;\n  private semVerFactoryReference?: ServiceReference<SemverFactory>;\n  private semVerFactory: SemverFactory;\n  private pmUsed = false;\n  private pmListener: ServiceListener;\n\n  async start(context: BundleContext): Promise<void> {\n    this.context = context;\n    this.loggerReference = context.getServiceReference<Logger>(FRAMEWORK_LOGGER);\n    this.logger = context.getService<Logger>(this.loggerReference);\n    this.filterParserReference = context.getServiceReference<FilterParser>(FRAMEWORK_FILTER_PARSER);\n    this.filterParser = context.getService(this.filterParserReference);\n    this.semVerFactoryReference = context.getServiceReference<SemverFactory>(FRAMEWORK_SEMVER_FACTORY);\n    this.semVerFactory = context.getService(this.semVerFactoryReference);\n\n    this.persistenceManagerReference = context.getServiceReference<PersistenceManager>(INTERFACE_KEY);\n\n    if (this.persistenceManagerReference) {\n      this.logger.info(\n        `Activating Configuration Management with immediate Persistence Manager Reference: ${this.persistenceManagerReference.getProperty(\n          OBJECTCLASS,\n        )}`,\n      );\n      this.persistenceManager = context.getService(this.persistenceManagerReference);\n      this.init(this.persistenceManager);\n      this.pmUsed = true;\n    } else {\n      this.pmListener = {\n        isSync: true,\n        serviceChanged: (event: ServiceEvent) => {\n          if (event.getType() === 'REGISTERED' && !this.pmUsed) {\n            this.persistenceManagerReference = event.getServiceReference();\n            this.persistenceManager = context.getService(this.persistenceManagerReference);\n            this.init(this.persistenceManager);\n            this.pmUsed = true;\n          } else if (event.getType() === 'UNREGISTERING' && this.pmUsed) {\n            context.ungetService(this.persistenceManagerReference);\n            context.removeServiceListener(this.configManager);\n\n            if (this.configAdminRegistration) {\n              this.configAdminRegistration.unregister();\n            }\n          }\n        },\n      };\n      this.logger.info(`Configuration Management activation delayed, waiting for a Persistence Manager Reference...`);\n      this.context.addServiceListener(this.pmListener, `(objectClass=${INTERFACE_KEY})`);\n    }\n  }\n\n  async stop(context: BundleContext): Promise<void> {\n    context.ungetService(this.loggerReference);\n    context.ungetService(this.filterParserReference);\n    context.ungetService(this.persistenceManagerReference);\n    context.ungetService(this.semVerFactoryReference);\n    context.removeServiceListener(this.configManager);\n\n    if (this.configAdminRegistration) {\n      this.configAdminRegistration.unregister();\n    }\n\n    if (this.pmListener) {\n      context.removeServiceListener(this.pmListener);\n    }\n  }\n\n  private init(pm: PersistenceManager): void {\n    this.logger.info(`Initializing Configuration Management...`);\n    if (!this.pmUsed) {\n      this.configManager = new ConfigurationManager(\n        this.context,\n        this.logger,\n        this.filterParser,\n        pm,\n        this.semVerFactory,\n      );\n      this.configAdmin = new ConfigurationAdminImpl(this.configManager, this.context.getBundle(), this.logger);\n      this.configAdminRegistration = this.context.registerService<ConfigurationAdmin>(\n        CONFIG_ADMIN_INTERFACE_KEY,\n        this.configAdmin,\n      );\n      this.configManager.initReferencesAddedBeforeManagerActivation();\n      this.context.addServiceListener(this.configManager);\n    } else {\n      this.logger.warn(`Tried to re-start Configuration Admin while is already in use. Ignoring`);\n    }\n  }\n\n  static getLocation(bundle: Bundle): string {\n    return bundle.getLocation();\n  }\n}\n"],"names":["LogLevel","INTERFACE_KEY","ConfigurationAdminImpl","bundle","logger","configurationManager","constructor","this","getConfiguration","pid","location","config","createConfiguration","listConfigurations","filter","TargetedPID","rawPid","servicePid","symbolicName","version","bindingLevel","semVerFactory","indexOf","start","end","substring","build","matchesTarget","reference","serviceBundle","getBundle","getSymbolicName","getVersion","compare","Activator","getLocation","getRawPid","getServicePid","bindsStronger","other","equals","obj","toString","ConfigurationImpl","isDeleted","properties","delete","checkDeleted","deleteConfiguration","getPid","getBundleLocation","getProcessedProperties","serviceReference","getProperties","undefined","setBundleLocation","update","updateConfiguration","getTargetedPid","Error","ConfigurationCache","cache","Map","persistenceManager","cm","context","pm","forEach","props","configuration","set","has","stored","load","get","store","values","Array","from","exists","ConfigurationManager","isSync","filterParser","managedReferences","eventListeners","configurationCache","initReferencesAddedBeforeManagerActivation","nonConfiguredReferences","freshReferences","references","getServiceReferences","ref","getProperty","configuredReferences","refPid","targetedPid","service","getService","initManagedService","push","origRef","includes","debug","updated","refs","serviceChanged","event","getServiceReference","internalCreateConfiguration","handleManagedServiceEvent","getType","configurationEvent","configurationListener","handleConfigurationEventListenerEvent","eventType","managedService","idx","findIndex","splice","fireConfigurationChangeEvent","listeners","listenerIdx","l","effectiveLocation","length","filterString","parse","match","bundleLocation","type","getReference","listener","loggerReference","configManager","configAdmin","configAdminRegistration","filterParserReference","persistenceManagerReference","semVerFactoryReference","pmUsed","pmListener","async","info","init","ungetService","removeServiceListener","unregister","addServiceListener","warn","registerService","static"],"mappings":"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"}