{"version":3,"file":"persistence-manager-localstorage.mjs","sources":["../../../pandino-api/dist/esm/pandino-api.mjs","../../src/service.ts","../../src/constants.ts","../../src/activator.ts","../../../persistence-manager-api/dist/esm/persistence-manager-api.mjs"],"sourcesContent":["/**\n * PANDINO\n */\nconst DEPLOYMENT_ROOT_PROP = 'pandino.deployment.root';\nconst LOG_LEVEL_PROP = 'pandino.log.level';\nconst LOG_LOGGER_PROP = 'pandino.log.logger';\nconst PANDINO_BUNDLE_IMPORTER_PROP = 'pandino.bundle.importer';\nconst PANDINO_MANIFEST_FETCHER_PROP = 'pandino.manifest.fetcher';\nconst BUNDLE_NAMESPACE = 'pandino.wiring.bundle';\nconst IDENTITY_NAMESPACE = 'pandino.identity';\nconst TYPE_BUNDLE = 'pandino.bundle';\nconst TYPE_FRAGMENT = 'pandino.fragment';\nconst SYSTEMBUNDLE_ACTIVATORS_PROP = 'pandino.systembundle.activators';\nconst PANDINO_VERSION_PROPERTY = 'pandino.version';\nconst PACKAGE_NAMESPACE = 'pandino.wiring.package';\nconst HOST_NAMESPACE = 'pandino.wiring.host';\n/**\n * Location identifier of the Pandino <i>system bundle </i>, which is defined to be &quot;System Bundle&quot;.\n */\nconst SYSTEM_BUNDLE_LOCATION = 'System Bundle';\n/**\n * Manifest header identifying the bundle's name.\n */\nconst BUNDLE_NAME = 'Bundle-Name';\n/**\n * Manifest header containing a brief description of the bundle's functionality.\n */\nconst BUNDLE_DESCRIPTION = 'Bundle-Description';\n/**\n * Manifest header identifying the bundle's vendor.\n */\nconst BUNDLE_VENDOR = 'Bundle-Vendor';\n/**\n * Manifest header identifying the bundle's version.\n *\n * (Required attribute)\n */\nconst BUNDLE_VERSION = 'Bundle-Version';\n/**\n * If the corresponding value is a path string, then the value <b>MUST</b> be a relative path calculated from the\n * {@link DEPLOYMENT_ROOT_PROP}'s value!\n *\n * (Required attribute)\n */\nconst BUNDLE_ACTIVATOR = 'Bundle-Activator';\n/**\n * Manifest header identifying the bundle's activation policy.\n *\n * (Not yet implemented)\n */\nconst BUNDLE_ACTIVATIONPOLICY = 'Bundle-ActivationPolicy';\n/**\n * Manifest header identifying the bundle's symbolic name.\n *\n * (Required attribute)\n */\nconst BUNDLE_SYMBOLICNAME = 'Bundle-SymbolicName';\n/**\n * Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in\n * which it is written by specifying a bundle manifest version.\n *\n * (Required attribute)\n */\nconst BUNDLE_MANIFESTVERSION = 'Bundle-ManifestVersion';\n/**\n * Manifest header identifying the bundle's copyright information.\n */\nconst BUNDLE_COPYRIGHT = 'Bundle-Copyright';\n/**\n * Manifest header identifying the symbolic names of other bundles required by the bundle.\n *\n * (Not yet implemented)\n */\nconst REQUIRE_BUNDLE = 'Require-Bundle';\n/**\n * Manifest header identifying the capabilities that the bundle offers to provide to other bundles.\n */\nconst PROVIDE_CAPABILITY = 'Provide-Capability';\n/**\n * Manifest header identifying the capabilities on which the bundle depends.\n */\nconst REQUIRE_CAPABILITY = 'Require-Capability';\n/**\n * Manifest header identifying the path to a LICENSE file (if any).\n */\nconst BUNDLE_LICENSE = 'Bundle-License';\n/**\n * Manifest header directive value identifying an optional resolution type. An optional resolution type indicates that\n * the import, require bundle or require capability is optional and the bundle may be resolved without the import,\n * require bundle or require capability being resolved. If the import, require bundle or require capability is not\n * resolved when the bundle is resolved, the import, require bundle or require capability may not be resolved until the\n * bundle is refreshed.\n *\n * (Not yet implemented)\n */\nconst RESOLUTION_OPTIONAL = 'optional';\nconst SYSTEM_BUNDLE_SYMBOLICNAME = '@pandino/pandino';\n/**\n * Bundle activation policy declaring the bundle must be activated when the first class load is made from the bundle.\n *\n * <p>\n * A bundle with the lazy activation policy that is started with the \"START_ACTIVATION_POLICY\" option will wait in the\n * \"STARTING\" state until the first class load from the bundle occurs. The bundle will then be activated before the\n * class is returned to the requester.\n *\n * (Not yet implemented)\n */\nconst ACTIVATION_LAZY = 'lazy';\n/**\n * Manifest header identifying the symbolic name of another bundle for which that the bundle is a fragment.\n *\n * (Not yet implemented)\n */\nconst FRAGMENT_HOST = 'Fragment-Host';\nconst FRAMEWORK_LOGGER = '@pandino/pandino/Logger';\nconst FRAMEWORK_MANIFEST_FETCHER = '@pandino/pandino/ManifestFetcher';\nconst FRAMEWORK_BUNDLE_IMPORTER = '@pandino/pandino/BundleImporter';\nconst FRAMEWORK_FILTER_PARSER = '@pandino/pandino/FilterParser';\nconst FRAMEWORK_SEMVER_FACTORY = '@pandino/pandino/SemVerFactory';\nconst FRAMEWORK_UUID = '@pandino/pandino/uuid';\nconst FRAMEWORK_VERSION = '@pandino/pandino/version';\nconst FRAMEWORK_VENDOR = '@pandino/pandino/vendor';\nconst SERVICE_DEFAULT_RANK = 0;\nconst SERVICE_EVENT_INTERFACE_KEY = '@pandino/pandino/service/ServiceEvent';\nconst SERVICE_LISTENER_INTERFACE_KEY = '@pandino/pandino/service/ServiceListener';\n/**\n * Service property identifying a service's registration number. The value of this property must be of type\n * {@code number}.\n *\n * <p>\n * The value of this property is assigned by the Framework when a service is registered. The Framework assigns a unique,\n * non-negative value that is larger than all previously assigned values since the Framework was started. These values\n * are NOT persistent across restarts of the Framework.\n */\nconst SERVICE_ID = 'service.id';\n/**\n * Service property identifying a service's ranking number.\n *\n * <p>\n * This property may be supplied in the {@code properties Record} object passed to the\n * {@code BundleContext.registerService} method. The value of this property must be of type {@code number}.\n *\n * <p>\n * The service ranking is used by the Framework to determine the <i>natural order</i> of services, see\n * {@link ServiceReference#compareTo(Object)}, and the <i>default</i> service to be returned from a call to the\n * {@link BundleContext#getServiceReference(Class)} or\n * {@link BundleContext#getServiceReference(String)} method.\n *\n * <p>\n * The default ranking is zero (0). A service with a ranking of {@code Number.MAX_VALUE} is very likely to be returned\n * as the default service, whereas a service with a ranking of {@code Number.MIN_VALUE} is very unlikely to be\n * returned.\n */\nconst SERVICE_RANKING = 'service.ranking';\n/**\n * Service property identifying the {@link Bundle#getBundleId() bundle id} of the {@link ServiceReference#getBundle()\n * bundle registering the service}.\n *\n * <p>\n * This property is set by the Framework when a service is registered. The value of this property must be of type\n * {@code number}.\n */\nconst SERVICE_BUNDLEID = 'service.bundleid';\n/**\n * Service property identifying a service's description.\n */\nconst SERVICE_DESCRIPTION = 'service.description';\n/**\n * Service property identifying a service's scope.\n *\n * <p>\n * This property is set by the Framework when a service is registered. If the registered object implements\n * {@link PrototypeServiceFactory}, then the value of this service property will be {@link #SCOPE_PROTOTYPE}. Otherwise,\n * if the registered object implements {@link ServiceFactory}, then the value of this service property will be\n * {@link #SCOPE_BUNDLE}. Otherwise, the value of this service property will be {@link #SCOPE_SINGLETON}.\n */\nconst SERVICE_SCOPE = 'service.scope';\nconst SERVICE_PID = 'service.pid';\n/**\n * Service scope is singleton. All bundles using the service receive the same service object.\n */\nconst SCOPE_SINGLETON = 'singleton';\n/**\n * Service scope is bundle. Each bundle using the service receives a customized service object.\n */\nconst SCOPE_BUNDLE = 'bundle';\n/**\n * Service scope is prototype. Each bundle using the service receives either a customized service object or can request\n * multiple customized service objects.\n */\nconst SCOPE_PROTOTYPE = 'prototype';\n/**\n * Service property identifying all of the class names under which a service was registered in the Framework. The value\n * of this property must be of type {@code string | string[]}.\n *\n * <p>\n * This property is set by the Framework when a service is registered.\n */\nconst OBJECTCLASS = 'objectClass';\n/**\n * Manifest header attribute identifying a range of versions for a bundle specified in the {@code Require-Bundle} or\n * {@code Fragment-Host} manifest headers. The default value is {@code 0.0.0}.\n */\nconst BUNDLE_VERSION_ATTRIBUTE = 'bundle-version';\n/**\n * Manifest header attribute identifying the version of a package specified in the Export-Package or Import-Package\n * manifest header.\n */\nconst VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute identifying the {@code SemVer} of the resource if one is specified or {@code 0.0.0} if not\n * specified. The value of this attribute must be of type {@code SemVer}.\n */\nconst CAPABILITY_VERSION_ATTRIBUTE = 'version';\n/**\n * The capability attribute that contains a human readable copyright notice for the resource. See the\n * {@code Bundle-Copyright} manifest header.\n */\nconst CAPABILITY_COPYRIGHT_ATTRIBUTE = 'copyright';\n/**\n * The attribute value that contains tags for the resource. A tag is used to identify an aspect of the resource that is\n * not otherwise expressed by the capabilities of the resource. The value of this attribute must be of type\n * {@code Array<string>}.\n */\nconst CAPABILITY_TAGS_ATTRIBUTE = 'tags';\n/**\n * The capability attribute identifying the resource type. If the resource has no type then the value\n * {@link #TYPE_UNKNOWN unknown} must be used for the attribute.\n */\nconst CAPABILITY_TYPE_ATTRIBUTE = 'type';\n/**\n * The capability attribute that contains a human readable description for the resource. See the\n * {@code Bundle-Description} manifest header.\n */\nconst CAPABILITY_DESCRIPTION_ATTRIBUTE = 'description';\n/**\n * Manifest header directive identifying a list of packages that an exported package or provided capability uses.\n */\nconst USES_DIRECTIVE = 'uses';\n/**\n * Manifest header directive identifying names of matching attributes which must be specified by matching Import-Package\n * statements in the Export-Package manifest header.\n */\nconst MANDATORY_DIRECTIVE = 'mandatory';\n/**\n * Manifest header directive identifying the capability filter specified in the Require-Capability manifest header.\n */\nconst FILTER_DIRECTIVE = 'filter';\n/**\n * Manifest header directive identifying a list of classes to include in the exported package.\n *\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must be allowed to be exported.\n */\nconst INCLUDE_DIRECTIVE = 'include';\n/**\n * Manifest header directive identifying a list of classes to exclude in the exported package..\n * <p>\n * This directive is used by the Export-Package manifest header to identify a list of classes of the specified package\n * which must not be allowed to be exported.\n */\nconst EXCLUDE_DIRECTIVE = 'exclude';\n/**\n * Manifest header directive identifying the resolution type in the Import-Package, Require-Bundle or Require-Capability\n * manifest header. The default value is {@link #RESOLUTION_MANDATORY mandatory}.\n */\nconst RESOLUTION_DIRECTIVE = 'resolution';\n/**\n * Manifest header directive identifying whether a bundle is a singleton. The default value is {@code false}.\n */\nconst SINGLETON_DIRECTIVE = 'singleton';\n/**\n * The capability directive identifying if the resource is a singleton. A {@code string} value of &quot;true&quot;\n * indicates the resource is a singleton; any other value or {@code undefined} indicates the resource is not a\n * singleton.\n */\nconst CAPABILITY_SINGLETON_DIRECTIVE = 'singleton';\n/**\n * Manifest header directive identifying the effective time of the provided capability. The default value is\n * {@link #EFFECTIVE_RESOLVE resolve}.\n */\nconst EFFECTIVE_DIRECTIVE = 'effective';\n/**\n * Manifest header directive value identifying a capability that is effective at resolve time. Capabilities with an\n * effective time of resolve are the only capabilities which are processed by the resolver.\n */\nconst EFFECTIVE_RESOLVE = 'resolve';\n/**\n * The requirement directive used to specify a capability filter. This filter is used to match against a capability's\n * attributes.\n */\nconst REQUIREMENT_FILTER_DIRECTIVE = 'filter';\n/**\n * The requirement directive used to specify the cardinality for a requirement. The default value is {@link #CARDINALITY_SINGLE single}.\n */\nconst REQUIREMENT_CARDINALITY_DIRECTIVE = 'cardinality';\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"TRACE\"] = 5] = \"TRACE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 4] = \"DEBUG\";\n    LogLevel[LogLevel[\"LOG\"] = 3] = \"LOG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\n\nexport { ACTIVATION_LAZY, BUNDLE_ACTIVATIONPOLICY, BUNDLE_ACTIVATOR, BUNDLE_COPYRIGHT, BUNDLE_DESCRIPTION, BUNDLE_LICENSE, BUNDLE_MANIFESTVERSION, BUNDLE_NAME, BUNDLE_NAMESPACE, BUNDLE_SYMBOLICNAME, BUNDLE_VENDOR, BUNDLE_VERSION, BUNDLE_VERSION_ATTRIBUTE, CAPABILITY_COPYRIGHT_ATTRIBUTE, CAPABILITY_DESCRIPTION_ATTRIBUTE, CAPABILITY_SINGLETON_DIRECTIVE, CAPABILITY_TAGS_ATTRIBUTE, CAPABILITY_TYPE_ATTRIBUTE, CAPABILITY_VERSION_ATTRIBUTE, DEPLOYMENT_ROOT_PROP, EFFECTIVE_DIRECTIVE, EFFECTIVE_RESOLVE, EXCLUDE_DIRECTIVE, FILTER_DIRECTIVE, FRAGMENT_HOST, FRAMEWORK_BUNDLE_IMPORTER, FRAMEWORK_FILTER_PARSER, FRAMEWORK_LOGGER, FRAMEWORK_MANIFEST_FETCHER, FRAMEWORK_SEMVER_FACTORY, FRAMEWORK_UUID, FRAMEWORK_VENDOR, FRAMEWORK_VERSION, HOST_NAMESPACE, IDENTITY_NAMESPACE, INCLUDE_DIRECTIVE, LOG_LEVEL_PROP, LOG_LOGGER_PROP, LogLevel, MANDATORY_DIRECTIVE, OBJECTCLASS, PACKAGE_NAMESPACE, PANDINO_BUNDLE_IMPORTER_PROP, PANDINO_MANIFEST_FETCHER_PROP, PANDINO_VERSION_PROPERTY, PROVIDE_CAPABILITY, REQUIREMENT_CARDINALITY_DIRECTIVE, REQUIREMENT_FILTER_DIRECTIVE, REQUIRE_BUNDLE, REQUIRE_CAPABILITY, RESOLUTION_DIRECTIVE, RESOLUTION_OPTIONAL, SCOPE_BUNDLE, SCOPE_PROTOTYPE, SCOPE_SINGLETON, SERVICE_BUNDLEID, SERVICE_DEFAULT_RANK, SERVICE_DESCRIPTION, SERVICE_EVENT_INTERFACE_KEY, SERVICE_ID, SERVICE_LISTENER_INTERFACE_KEY, SERVICE_PID, SERVICE_RANKING, SERVICE_SCOPE, SINGLETON_DIRECTIVE, SYSTEMBUNDLE_ACTIVATORS_PROP, SYSTEM_BUNDLE_LOCATION, SYSTEM_BUNDLE_SYMBOLICNAME, TYPE_BUNDLE, TYPE_FRAGMENT, USES_DIRECTIVE, VERSION_ATTRIBUTE };\n","import { PersistenceManager } from '@pandino/persistence-manager-api';\nimport { Logger, ServiceProperties } from '@pandino/pandino-api';\n\nexport class LocalstoragePersistenceManager implements PersistenceManager {\n  private readonly storage: Storage;\n  private readonly logger: Logger;\n  private readonly managedKeysKey: string;\n\n  constructor(storage: Storage, managedKeysKey: string, logger: Logger) {\n    this.storage = storage;\n    this.managedKeysKey = managedKeysKey;\n    this.logger = logger;\n\n    this.initManagedKeys();\n  }\n\n  exists(pid: string): boolean {\n    const value = this.storage.getItem(pid);\n    return value !== null && value !== undefined;\n  }\n\n  delete(pid: string): void {\n    if (this.exists(pid)) {\n      if (this.isKeyManaged(pid)) {\n        this.storage.removeItem(pid);\n        this.removeFromManagedKeys(pid);\n      } else {\n        this.logger.warn(`Skipping deletion of PID: ${pid}, because it's not in the list of Managed Keys!`);\n      }\n    }\n  }\n\n  getProperties(): ServiceProperties[] {\n    const props: ServiceProperties[] = [];\n    const managedKeys = this.getManagedKeys();\n    for (const pid of managedKeys) {\n      try {\n        const value = this.storage.getItem(pid);\n        const parsed = JSON.parse(value) as ServiceProperties;\n        props.push(parsed);\n      } catch (err) {\n        this.logger.error(`Error while trying to parse persisted Configuration for PID: ${pid}!`);\n      }\n    }\n    return props;\n  }\n\n  load(pid: string): ServiceProperties | undefined {\n    if (this.exists(pid)) {\n      if (this.isKeyManaged(pid)) {\n        const value = this.storage.getItem(pid);\n        return JSON.parse(value);\n      } else {\n        this.logger.warn(`Cannot load Configuration for PID: ${pid}, because it's not in the list of Managed Keys!`);\n      }\n    }\n  }\n\n  store(pid: string, properties: ServiceProperties): void {\n    if (!this.isKeyManaged(pid)) {\n      this.logger.debug(`Adding new PID to Managed Keys: ${pid}`);\n      this.addToManagedKeys(pid);\n    }\n    try {\n      const value = JSON.stringify(properties);\n      this.storage.setItem(pid, value);\n    } catch (err) {\n      this.logger.error(`Cannot store Configuration for PID: ${pid}: ${err}`);\n    }\n  }\n\n  getManagedKeys(): string[] {\n    try {\n      return JSON.parse(this.storage.getItem(this.managedKeysKey));\n    } catch (err) {\n      this.logger.error(`Could not load contents of Managed Keys!`);\n    }\n  }\n\n  private isKeyManaged(key: string): boolean {\n    return this.getManagedKeys().includes(key);\n  }\n\n  private initManagedKeys(...keys: string[]): void {\n    if (!this.storage.getItem(this.managedKeysKey)) {\n      this.storage.setItem(this.managedKeysKey, JSON.stringify(keys));\n    }\n  }\n\n  private addToManagedKeys(key: string): void {\n    try {\n      const catalogue = this.getManagedKeys();\n      if (!catalogue.find((k) => k === key)) {\n        catalogue.push(key);\n      }\n      this.storeManagedKeys(catalogue);\n    } catch (err) {\n      this.logger.error(`Could not add \"${key}\" to Managed Keys: ${err}`);\n    }\n  }\n\n  private removeFromManagedKeys(key: string): void {\n    try {\n      const catalogue = this.getManagedKeys();\n      const idx = catalogue.findIndex((k) => k === key);\n      if (idx > -1) {\n        catalogue.splice(idx, 1);\n      }\n      this.storeManagedKeys(catalogue);\n    } catch (err) {\n      this.logger.error(`Could not remove \"${key}\" from Managed Keys: ${err}`);\n    }\n  }\n\n  private storeManagedKeys(keys: string[]): void {\n    try {\n      this.storage.setItem(this.managedKeysKey, JSON.stringify(keys));\n    } catch (err) {\n      this.logger.error(`Could not store contents of Managed Keys: ${err}`);\n    }\n  }\n}\n","export const PM_MANAGED_KEYS_KEY = 'pandino.pm.managed-keys';\n","import {\n  BundleActivator,\n  BundleContext,\n  FRAMEWORK_LOGGER,\n  Logger,\n  ServiceReference,\n  ServiceRegistration,\n} from '@pandino/pandino-api';\nimport { INTERFACE_KEY, PersistenceManager, SERVICE_DISCRIMINATOR_PROPERTY } from '@pandino/persistence-manager-api';\nimport { LocalstoragePersistenceManager } from './service';\nimport { PM_MANAGED_KEYS_KEY } from './constants';\n\nexport class Activator implements BundleActivator {\n  private serviceRegistration: ServiceRegistration<PersistenceManager>;\n  private service: PersistenceManager;\n  private loggerReference: ServiceReference<Logger>;\n  private logger: Logger;\n  private managedKeysKey: string;\n\n  async start(context: BundleContext): Promise<void> {\n    this.managedKeysKey = context.getProperty('persistence-manager-managed-keys') || PM_MANAGED_KEYS_KEY;\n    this.loggerReference = context.getServiceReference<Logger>(FRAMEWORK_LOGGER);\n    this.logger = context.getService<Logger>(this.loggerReference);\n    this.service = new LocalstoragePersistenceManager(window.localStorage, this.managedKeysKey, this.logger);\n    this.serviceRegistration = context.registerService<PersistenceManager>(INTERFACE_KEY, this.service, {\n      [SERVICE_DISCRIMINATOR_PROPERTY]: 'dom-localstorage',\n    });\n  }\n\n  async stop(context: BundleContext): Promise<void> {\n    context.ungetService(this.loggerReference);\n    if (this.serviceRegistration) {\n      this.serviceRegistration.unregister();\n    }\n  }\n}\n","/**\n * Service registration property to define a unique name for the persistence manager.\n */\nconst PROPERTY_NAME = 'name';\nconst INTERFACE_KEY = '@pandino/persistence-manager/PersistenceManager';\nconst SERVICE_DISCRIMINATOR_PROPERTY = 'type';\n\nexport { INTERFACE_KEY, PROPERTY_NAME, SERVICE_DISCRIMINATOR_PROPERTY };\n"],"names":["LogLevel","LocalstoragePersistenceManager","storage","logger","managedKeysKey","constructor","this","initManagedKeys","exists","pid","value","getItem","delete","isKeyManaged","removeItem","removeFromManagedKeys","warn","getProperties","props","managedKeys","getManagedKeys","parsed","JSON","parse","push","err","error","load","store","properties","debug","addToManagedKeys","stringify","setItem","key","includes","keys","catalogue","find","k","storeManagedKeys","idx","findIndex","splice","PM_MANAGED_KEYS_KEY","Activator","serviceRegistration","service","loggerReference","async","context","getProperty","getServiceReference","getService","window","localStorage","registerService","type","ungetService","unregister"],"mappings":"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"}